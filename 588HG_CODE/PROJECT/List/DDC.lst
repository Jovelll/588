C51 COMPILER V9.60.0.0   DDC                                                               12/22/2020 19:50:33 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE DDC
OBJECT MODULE PLACED IN .\Obj\DDC.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\kernel\Scaler\DDC.c OPTIMIZE(9,SPEED) BROWSE INCDIR(..\KERNEL\SYSTEM\
                    -INC;..\KERNEL\SCALER\INC;..\DRIVER\extDEVICE\INC;..\LIB\INC;..\PANEL\INC;..\UI\BOARD;..\UI\INC;..\UI\MODEL;..\DRIVER\INC
                    -;..\Customer) DEFINE(ModelName=TSUMXX9_DEMO) DEBUG OBJECTEXTEND PRINT(.\List\DDC.lst) TABS(2) OBJECT(.\Obj\DDC.obj)

line level    source

   1          #include "types.h"
   2          #include "ms_reg.h"
   3          #include "ms_rwreg.h"
   4          #include "global.h"
   5          #include "msflash.h"
   6          #include "power.h"
   7          #include "NVRam.h"
   8          #include "UserPref.h"
   9          
  10          
  11          #ifdef UseInternalDDCRam
              void mStar_WriteDDC( BYTE EDIDType );
              
              void mStar_ClrDDC_WP( void )  //turn off Ram WP
              {
                  msWriteByte( BK0_B8, BIT7 );
                  #if INPUT_TYPE!=INPUT_1A
                  mStar_WriteByteMask( BK0_B4, (BIT5 | BIT7), (BIT5 | BIT7) );    // DVI
                  #endif
              }
              void mStar_SetDDC_WP( void )  //turn on Ram WP
              {
                  mStar_WriteByteMask( BK0_B8, (BIT7 | BIT5), (BIT7 | BIT5 | BIT0) );
                  #if INPUT_TYPE!=INPUT_1A
                  msWriteByte( BK0_B4, BIT7 );
                  #endif
              }
              
              void mStar_InitDDC( void )
              {
                  BYTE xdata i;
                  BYTE xdata dd;
              
                  msWriteByte( BK0_B8, BIT7 );
                  msWriteByte( BK0_B9, BIT7 );
              
                  for( i = 0; i < 128; i++ )
                  {
                      dd = FlashReadByte( DDCAKEYSET_START + i );
                      msWriteByte( BK0_BA, i );
                      msWriteByte( BK0_BB, dd );
                  }
                  #if INPUT_TYPE!=INPUT_1A
                  #ifndef DVI_EDID_OnlyINEEPROM  //DVI in eeprom ,VGA in flash  //AMY 2008/5/13
                  mStar_WriteByteMask( BK0_B4, BIT7, BIT7 );
                  msWriteByte( BK0_B5, BIT7 );
                  for( i = 0; i < 128; i++ )
                  {
                      dd = FlashReadByte( DDCDKEYSET_START + i );
                      msWriteByte( BK0_B6, i );
                      msWriteByte( BK0_B7, dd );
                  }
                  #endif
C51 COMPILER V9.60.0.0   DDC                                                               12/22/2020 19:50:33 PAGE 2   

                  #endif
                  // VGA set B8h[5], enable iic write protection.
                  // DVI clr B4h[5], enable iic write protection
                  mStar_WriteByteMask( BK0_B8, (BIT5 | BIT7), (BIT5 | BIT7) );
                  #ifndef DVI_EDID_OnlyINEEPROM  //DVI in eeprom ,VGA in flash  //AMY 2008/5/13
                  mStar_WriteByteMask( BK0_B4, (BIT5 | BIT7), (BIT5 | BIT7) );    // DVI
                  #endif
              
                  mStar_SetDDC_WP();
              }
              
              Bool mStar_ReadDDC( BYTE EDIDType ) //read DDC from RAM and prepare for write to flash
              {
                  BYTE i;
                  BYTE CheckSum = 0;
                  if( EDIDType == VGA_EDID )
                  {
                      msWriteByte( BK0_BA, BIT7 );
                      for( i = 0; i < 128; i++ )
                      {
                          DDC1[i] = msReadByte( BK0_BB );
                          CheckSum += ( ~DDC1[i] );
                      }
                  }
              #if INPUT_TYPE!=INPUT_1A
              #ifndef DVI_EDID_OnlyINEEPROM  //DVI in eeprom ,VGA in flash  //AMY 2008/5/13
                  else if( EDIDType == DVI_EDID )
                  {
                      msWriteByte( BK0_B6, BIT7 );
                      for( i = 0; i < 128; i++ )
                      {
                          DDC1[i] = msReadByte( BK0_B7 );
                          CheckSum += ( ~DDC1[i] );
                      }
                  }
              #endif
              #endif
                  if( CheckSum == 0 )//EDID Data is right
                      return TRUE;
                  else
                      return FALSE;
              }
              
              Bool CheckEDIDData( BYTE EDIDType )
              {
                  BYTE i;
                  BYTE CheckSum = 0;
                  if( EDIDType == VGA_EDID )
                  {
                      msWriteByte( BK0_BA, BIT7 );
                      for( i = 0; i < 8; i++ )
                      {
                          DDC1[i] = msReadByte( BK0_BB );
                          CheckSum += ( ~DDC1[i] );
                      }
                  }
                  #if INPUT_TYPE!=INPUT_1A
                  #ifndef DVI_EDID_OnlyINEEPROM  //DVI in eeprom ,VGA in flash  //AMY 2008/5/13
                  else if( EDIDType == DVI_EDID )
                  {
                      msWriteByte( BK0_B6, BIT7 );
                      for( i = 0; i < 8; i++ )
C51 COMPILER V9.60.0.0   DDC                                                               12/22/2020 19:50:33 PAGE 3   

                      {
                          DDC1[i] = msReadByte( BK0_B7 );
                          CheckSum += ( ~DDC1[i] );
                      }
                  }
                  #endif
                  #endif
                  if( DDC1[0] == 0x00 && DDC1[1] == 0xFF && DDC1[2] == 0xFF && DDC1[3] == 0xFF && DDC1[4] == 0xFF && DDC
             -1[5] == 0xFF && DDC1[6] == 0xFF && DDC1[7] == 0x00 )
                  {
                      mStar_WriteDDC( EDIDType );
                  }
                  //mStar_ReadDDC(EDIDType);
                  if( DDC1[0] == 0xFF && DDC1[1] == 0x00 && DDC1[2] == 0x00 && DDC1[3] == 0x00 && DDC1[4] == 0x00 && DDC
             -1[5] == 0x00 && DDC1[6] == 0x00 && DDC1[7] == 0xFF )
                      return TRUE;
                  else
                      return FALSE;
              }
              void mStar_WriteDDC( BYTE EDIDType )
              {
                  BYTE i;
                  BYTE dd;
              
                  if( EDIDType == VGA_EDID )
                  {
                      msWriteByte( BK0_B8, BIT7 );
                      for( i = 0; i < 128; i++ )
                      {
                          dd = FlashReadByte( DDCAKEYSET_START + i );
                          msWriteByte( BK0_BA, i );
                          msWriteByte( BK0_BB, dd );
                      }
                  }
                  #if INPUT_TYPE!=INPUT_1A
                  #ifndef DVI_EDID_OnlyINEEPROM  //DVI in eeprom ,VGA in flash  //AMY 2008/5/13
                  else if( EDIDType == DVI_EDID )
                  {
                      mStar_WriteByteMask( BK0_B4, (BIT7), (BIT7) );
                      for( i = 0; i < 128; i++ )
                      {
                          dd = FlashReadByte( DDCDKEYSET_START + i );
                          msWriteByte( BK0_B6, i );
                          msWriteByte( BK0_B7, dd );
                      }
                  }
                  #endif
                  #endif
                  //mStar_WriteByteMask(BK0_B8, (BIT7|BIT5), (BIT7|BIT5|BIT0) );
              }
              extern void Delay1ms( WORD msNums );
              extern void ForceDelay1ms( WORD msNums );
              
              void mStar_CheckRAM( void )
              {
                  BYTE temp, temp2;
                  bit WriteVGAEDID = 0;
              #if INPUT_TYPE!=INPUT_1A
                  bit WriteDVIEDID = 0;
              #endif
                  temp = msReadByte( BK0_B8 );
                  temp2 = msReadByte( BK0_B4 );
C51 COMPILER V9.60.0.0   DDC                                                               12/22/2020 19:50:33 PAGE 4   

              
              #if INPUT_TYPE!=INPUT_1A
                  if((( temp & BIT0 ) && ( temp & ( BIT2 | BIT5 ) ) == 0x00 ) || (( temp2 & BIT0 ) && ( temp2 & ( BIT2 |
             - BIT5 ) ) == 0x20 ) )
              #else
                  if(( temp & BIT0 ) && ( temp & ( BIT2 | BIT5 ) ) == 0x00 )
              #endif
                  {
                      temp = 0;
                      while( temp < 60 ) //while( temp < 100 )  // xiacong 20080401 modify
                      {
                          ForceDelay1ms( 2 );
              #if INPUT_TYPE!=INPUT_1A
                          if(( msReadByte( BK0_B8 ) & BIT2 ) || ( msReadByte( BK0_B4 ) & BIT2 ) )
              #else
                          if( msReadByte( BK0_B8 ) & BIT2 )
              #endif
                          {
                              temp = 0;   // DDC busy
                          }
                          else
                          {
                              temp++;
                          }
                      }
                      
                      if( CheckEDIDData( VGA_EDID ) )
                          WriteVGAEDID = 1;
              #if INPUT_TYPE!=INPUT_1A
                      if( CheckEDIDData( DVI_EDID ) )
                          WriteDVIEDID = 1;
              #endif
                      if( WriteVGAEDID
              #if INPUT_TYPE!=INPUT_1A
                              || WriteDVIEDID
              #endif
                        )
                          ForceDelay1ms( 100 );
                      else
                          return;
                      if( WriteVGAEDID ) //CheckEDIDData(VGA_EDID))
                      {
              #if Enable_LED
                    Power_TurnOnAmberLed();//ºìµÆ
                    printMsg("22222");
              #else
                    Power_TurnOffLed();
              #endif         
                          if( mStar_ReadDDC( VGA_EDID ) )
                          {
                              Flash_Write_Factory_KeySet( FLASH_KEY_DDCA, 0, DDCAKEY_SIZE, DDC1, DDCAKEY_SIZE );
                          }
                          mStar_WriteDDC( VGA_EDID );
              #if Enable_LED
                    Power_TurnOnAmberLed();//ºìµÆ
                    printMsg("33333");
              #else
                    Power_TurnOnGreenLed();
              #endif
                          
                      }
              #if INPUT_TYPE!=INPUT_1A
C51 COMPILER V9.60.0.0   DDC                                                               12/22/2020 19:50:33 PAGE 5   

                      #ifndef DVI_EDID_OnlyINEEPROM  //DVI in eeprom ,VGA in flash  //AMY 2008/5/13
                      if( WriteDVIEDID ) //CheckEDIDData(DVI_EDID))
                      {
                          if( mStar_ReadDDC( DVI_EDID ) )
                          {
                              Flash_Write_Factory_KeySet( FLASH_KEY_DDCD, 0, 128, DDC1, 128 );
                          }
                          mStar_WriteDDC( DVI_EDID );
                          mStar_WriteByteMask( BK0_B4, (BIT5), (BIT5) );
                      #if Enable_LED
                    Power_TurnOnAmberLed();//ºìµÆ
                    printMsg("444444");
                  #else
                    Power_TurnOnGreenLed();
                  #endif
                      }
              #endif
              #endif
                  }
              }
              #endif
 258          
 259          #ifdef ENABLE_INTERNAL_HDMIEDID
              
              BYTE code Default_EDID_HDMI[256]=
              {
                0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x06, 0xaf, 0x17, 0x55, 0x00, 0x00, 0x00, 0x00,
                0x0c, 0x1a, 0x01, 0x03, 0x80, 0x3e, 0x22, 0x78, 0xea, 0x55, 0x25, 0xa1, 0x57, 0x4f, 0xa0, 0x28,
                0x0f, 0x50, 0x54, 0xbf, 0xef, 0x80, 0x81, 0x00, 0x81, 0xc0, 0x81, 0x80, 0x95, 0x00, 0xa9, 0xc0,
                0xb3, 0x00, 0xd1, 0xc0, 0xd1, 0x00, 0x04, 0x74, 0x00, 0x30, 0xf2, 0x70, 0x5a, 0x80, 0xb0, 0x58,
                0x8a, 0x00, 0x6d, 0x55, 0x21, 0x00, 0x00, 0x1e, 0x56, 0x5e, 0x00, 0xa0, 0xa0, 0xa0, 0x29, 0x50,
                0x30, 0x20, 0x35, 0x00, 0x5f, 0x59, 0x21, 0x00, 0x00, 0x1a, 0x00, 0x00, 0x00, 0xfd, 0x00, 0x18,
                0x46, 0x1a, 0x8c, 0x1e, 0x00, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00, 0x00, 0x00, 0xfc,
                0x00, 0x4c, 0x43, 0x44, 0x20, 0x4d, 0x4f, 0x4e, 0x49, 0x54, 0x4f, 0x52, 0x0a, 0x20, 0x01, 0x12,
                0x02, 0x03, 0x2b, 0xf1, 0x50, 0x90, 0x05, 0x04, 0x03, 0x02, 0x07, 0x16, 0x01, 0x1f, 0x12, 0x13,
                0x14, 0x20, 0x15, 0x11, 0x06, 0x23, 0x09, 0x7f, 0x07, 0x83, 0x01, 0x00, 0x00, 0x6d, 0x03, 0x0c,
                0x00, 0x10, 0x00, 0x38, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0x21, 0x50, 0xb0, 0x51,
                0x00, 0x1b, 0x30, 0x70, 0x40, 0x36, 0x00, 0x6d, 0x55, 0x21, 0x00, 0x00, 0x1e, 0x56, 0x5e, 0x00,
                0xa0, 0xa0, 0xa0, 0x29, 0x50, 0x30, 0x20, 0x35, 0x00, 0x6d, 0x55, 0x21, 0x00, 0x00, 0x1c, 0xe2,
                0x68, 0x00, 0xa0, 0xa0, 0x40, 0x2e, 0x60, 0x30, 0x20, 0x36, 0x00, 0x6d, 0x55, 0x21, 0x00, 0x00,
                0x1c, 0x04, 0x74, 0x80, 0x18, 0x71, 0x70, 0x5a, 0x80, 0x58, 0x2c, 0x8a, 0x00, 0x6d, 0x55, 0x21,
                0x00, 0x00, 0x1e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xa7,
              
              };
              
              
              void msInitInternalEDID(void)
              {
                
              #if CHIP_ID == CHIP_TSUMU
                WORD i;
                msWriteBit(REG_3E4D, 0,BIT7);
                msWriteBit(REG_3E4D, 0,BIT5);
                msWriteBit(REG_3E43, 0,BIT1);
                //msWriteByteMask(REG_28EF, BIT5|BIT7,BIT5|BIT6|BIT7);
                for(i = 0; i < 256; i++)
                {
                //printData("i==%d",i);
                msWriteByte(REG_3E47, i);
                msWriteByte(REG_3E48, Default_EDID_HDMI[i]);
                msWriteByteMask( REG_3E43, BIT7, BIT7);    //ADC sram write data pulse gen when cpu write
                     while(msReadByte(REG_3E7B) & 0x08);
C51 COMPILER V9.60.0.0   DDC                                                               12/22/2020 19:50:33 PAGE 6   

                }
                msWriteBit(REG_3E43, 1,BIT1);
                msWriteBit(REG_3E4D, 1,BIT5);
                msWriteBit(REG_3E4D, 1,BIT7);
              #endif
              
              }
              #endif
 307          
 308          #ifdef Internal_EDID_Write_To_24C02
              #define NVRAM_ADDR_EDID          0x00
              #if 1  //planar
              #if 0
              BYTE code Default_EDID_VGA[128]=
              {
                0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x41, 0x8e, 0x00, 0x24, 0x81, 0x38, 0x01, 0x00,
              0x0d, 0x1d, 0x01, 0x03, 0x00, 0x34, 0x1e, 0x78, 0x2a, 0xa1, 0x95, 0xa7, 0x55, 0x52, 0x9f, 0x27,
              0x14, 0x50, 0x54, 0xbf, 0xef, 0x80, 0xb3, 0x00, 0xa9, 0xc0, 0x95, 0x00, 0x81, 0x80, 0x71, 0x4f,
              0x90, 0x40, 0x01, 0x01, 0x01, 0x01, 0x02, 0x3a, 0x80, 0x18, 0x71, 0x38, 0x2d, 0x40, 0x58, 0x2c,
              0x45, 0x00, 0x0f, 0x28, 0x21, 0x00, 0x00, 0x1e, 0x00, 0x00, 0x00, 0xff, 0x00, 0x4e, 0x41, 0x0a,
              0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00, 0x00, 0x00, 0xfd, 0x00, 0x37,
              0x4c, 0x1e, 0x52, 0x11, 0x00, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00, 0x00, 0x00, 0xfc,
              0x00, 0x50, 0x4c, 0x4e, 0x32, 0x34, 0x30, 0x30, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00, 0x9f
              };
              BYTE code Default_EDID_DVI[128]=
              {
              //--terra   2016//  2462---dvi
              0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x5D,0xF2,0x62,0x24,0x81,0x38,0x01,0x00,
              0x05,0x1A,0x01,0x03,0x80,0x34,0x1D,0x78,0x2A,0xA1,0x95,0xA7,0x55,0x52,0x9F,0x27,
              0x14,0x50,0x54,0xBF,0xEF,0x80,0xB3,0x00,0xA9,0xC0,0x95,0x00,0x81,0x80,0x71,0x4F,
              0x90,0x40,0x01,0x01,0x01,0x01,0x02,0x3A,0x80,0x18,0x71,0x38,0x2D,0x40,0x58,0x2C,
              0x45,0x00,0x0F,0x28,0x21,0x00,0x00,0x1E,0x00,0x00,0x00,0xFF,0x00,0x4A,0x54,0x32,
              0x30,0x31,0x36,0x30,0x31,0x30,0x30,0x30,0x31,0x0A,0x00,0x00,0x00,0xFD,0x00,0x37,
              0x4C,0x1E,0x52,0x11,0x00,0x0A,0x20,0x20,0x20,0x20,0x20,0x20,0x00,0x00,0x00,0xFC,
              0x00,0x54,0x45,0x52,0x52,0x41,0x20,0x32,0x34,0x36,0x32,0x57,0x0A,0x20,0x00,0xFC,
              };
              #endif
              
              BYTE code Default_EDID_HDMI[]=                      
              {
                0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x41, 0x8e, 0x00, 0x24, 0x01, 0x01, 0x01, 0x01,
              0x0d, 0x1d, 0x01, 0x03, 0x80, 0x34, 0x1e, 0x78, 0x2a, 0xa1, 0x95, 0xa7, 0x55, 0x52, 0x9f, 0x27,
              0x14, 0x50, 0x54, 0xbf, 0xef, 0x80, 0xb3, 0x00, 0xa9, 0xc0, 0x95, 0x00, 0x81, 0x80, 0x71, 0x4f,
              0x90, 0x40, 0x01, 0x01, 0x01, 0x01, 0x0f, 0x3b, 0x80, 0x40, 0x71, 0x38, 0x2d, 0x40, 0x58, 0x2c,
              0x45, 0x00, 0x0f, 0x28, 0x21, 0x00, 0x00, 0x1e, 0x00, 0x00, 0x00, 0xff, 0x00, 0x4e, 0x41, 0x0a,
              0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00, 0x00, 0x00, 0xfd, 0x00, 0x37,
              0x4c, 0x0f, 0x52, 0x11, 0x00, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00, 0x00, 0x00, 0xfc,
              0x00, 0x50, 0x4c, 0x4e, 0x32, 0x34, 0x30, 0x30, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x01, 0xad,
              0x02, 0x03, 0x22, 0xf2, 0x4f, 0x90, 0x05, 0x04, 0x03, 0x02, 0x07, 0x06, 0x9f, 0x14, 0x13, 0x12,
              0x11, 0x16, 0x15, 0x01, 0x23, 0x09, 0x07, 0x07, 0x83, 0x01, 0x00, 0x00, 0x65, 0x03, 0x0c, 0x00,
              0x10, 0x00, 0x02, 0x3a, 0x80, 0x18, 0x71, 0x38, 0x2d, 0x40, 0x58, 0x2c, 0x45, 0x00, 0x0f, 0x28,
              0x21, 0x00, 0x00, 0x1f, 0x01, 0x1d, 0x80, 0x18, 0x71, 0x1c, 0x16, 0x20, 0x58, 0x2c, 0x25, 0x00,
              0x0f, 0x28, 0x21, 0x00, 0x00, 0x9f, 0x01, 0x1d, 0x00, 0x72, 0x51, 0xd0, 0x1e, 0x20, 0x6e, 0x28,
              0x55, 0x00, 0x0f, 0x28, 0x21, 0x00, 0x00, 0x1e, 0x8c, 0x0a, 0xd0, 0x8a, 0x20, 0xe0, 0x2d, 0x10,
              0x10, 0x3e, 0x96, 0x00, 0x0f, 0x28, 0x21, 0x00, 0x00, 0x18, 0x02, 0x3a, 0x80, 0xd0, 0x72, 0x38,
              0x2d, 0x40, 0x10, 0x2c, 0x45, 0x80, 0x0f, 0x28, 0x21, 0x00, 0x00, 0x1e, 0x00, 0x00, 0x00, 0x68
              };
              
              #else
              BYTE code Default_EDID_VGA[128]=
              {
              //--terra   2016//  2462--vga
C51 COMPILER V9.60.0.0   DDC                                                               12/22/2020 19:50:33 PAGE 7   

              0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x5D,0xF2,0x62,0x24,0x81,0x38,0x01,0x00,
              0x05,0x1A,0x01,0x03,0x00,0x34,0x1D,0x78,0x2A,0xA1,0x95,0xA7,0x55,0x52,0x9F,0x27,
              0x14,0x50,0x54,0xBF,0xEF,0x80,0xB3,0x00,0xA9,0xC0,0x95,0x00,0x81,0x80,0x71,0x4F,
              0x90,0x40,0x01,0x01,0x01,0x01,0x02,0x3A,0x80,0x18,0x71,0x38,0x2D,0x40,0x58,0x2C,
              0x45,0x00,0x0F,0x28,0x21,0x00,0x00,0x1E,0x00,0x00,0x00,0xFF,0x00,0x4A,0x54,0x32,
              0x30,0x31,0x36,0x30,0x31,0x30,0x30,0x30,0x31,0x0A,0x00,0x00,0x00,0xFD,0x00,0x37,
              0x4C,0x1E,0x52,0x11,0x00,0x0A,0x20,0x20,0x20,0x20,0x20,0x20,0x00,0x00,0x00,0xFC,
              0x00,0x54,0x45,0x52,0x52,0x41,0x20,0x32,0x34,0x36,0x32,0x57,0x0A,0x20,0x00,0x7C,
              
              };
              BYTE code Default_EDID_DVI[128]=
              {
              //--terra   2016//  2462---dvi
              0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x5D,0xF2,0x62,0x24,0x81,0x38,0x01,0x00,
              0x05,0x1A,0x01,0x03,0x80,0x34,0x1D,0x78,0x2A,0xA1,0x95,0xA7,0x55,0x52,0x9F,0x27,
              0x14,0x50,0x54,0xBF,0xEF,0x80,0xB3,0x00,0xA9,0xC0,0x95,0x00,0x81,0x80,0x71,0x4F,
              0x90,0x40,0x01,0x01,0x01,0x01,0x02,0x3A,0x80,0x18,0x71,0x38,0x2D,0x40,0x58,0x2C,
              0x45,0x00,0x0F,0x28,0x21,0x00,0x00,0x1E,0x00,0x00,0x00,0xFF,0x00,0x4A,0x54,0x32,
              0x30,0x31,0x36,0x30,0x31,0x30,0x30,0x30,0x31,0x0A,0x00,0x00,0x00,0xFD,0x00,0x37,
              0x4C,0x1E,0x52,0x11,0x00,0x0A,0x20,0x20,0x20,0x20,0x20,0x20,0x00,0x00,0x00,0xFC,
              0x00,0x54,0x45,0x52,0x52,0x41,0x20,0x32,0x34,0x36,0x32,0x57,0x0A,0x20,0x00,0xFC,
              };
              
              BYTE code Default_EDID_HDMI[]=                      
              {
                //--terra   2016//  2462--hdmi
                0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x5D,0xF2,0x62,0x24,0x01,0x01,0x01,0x01,
                0x05,0x1A,0x01,0x03,0x80,0x34,0x1D,0x78,0x2A,0xA1,0x95,0xA7,0x55,0x52,0x9F,0x27,
                0x14,0x50,0x54,0xBF,0xEF,0x80,0xB3,0x00,0xA9,0xC0,0x95,0x00,0x81,0x80,0x71,0x4F,
                0x90,0x40,0x01,0x01,0x01,0x01,0x02,0x3A,0x80,0x18,0x71,0x38,0x2D,0x40,0x58,0x2C,
                0x45,0x00,0x0F,0x28,0x21,0x00,0x00,0x1E,0x00,0x00,0x00,0xFF,0x00,0x4A,0x54,0x32,
                0x30,0x31,0x36,0x30,0x31,0x30,0x30,0x30,0x31,0x0A,0x00,0x00,0x00,0xFD,0x00,0x37,
                0x4C,0x0F,0x52,0x11,0x00,0x0A,0x20,0x20,0x20,0x20,0x20,0x20,0x00,0x00,0x00,0xFC,
                0x00,0x54,0x45,0x52,0x52,0x41,0x20,0x32,0x34,0x36,0x32,0x57,0x0A,0x20,0x01,0xC0,
                0x02,0x03,0x22,0xF2,0x4F,0x90,0x05,0x04,0x03,0x02,0x07,0x06,0x9F,0x14,0x13,0x12,
                0x11,0x16,0x15,0x01,0x23,0x09,0x07,0x07,0x83,0x01,0x00,0x00,0x65,0x03,0x0C,0x00,
                0x10,0x00,0x02,0x3A,0x80,0x18,0x71,0x38,0x2D,0x40,0x58,0x2C,0x45,0x00,0x0F,0x28,
                0x21,0x00,0x00,0x1F,0x01,0x1D,0x80,0x18,0x71,0x1C,0x16,0x20,0x58,0x2C,0x25,0x00,
                0x0F,0x28,0x21,0x00,0x00,0x9F,0x01,0x1D,0x00,0x72,0x51,0xD0,0x1E,0x20,0x6E,0x28,
                0x55,0x00,0x0F,0x28,0x21,0x00,0x00,0x1E,0x8C,0x0A,0xD0,0x8A,0x20,0xE0,0x2D,0x10,
                0x10,0x3E,0x96,0x00,0x0F,0x28,0x21,0x00,0x00,0x18,0x02,0x3A,0x80,0xD0,0x72,0x38,
                0x2D,0x40,0x10,0x2C,0x45,0x80,0x0F,0x28,0x21,0x00,0x00,0x1E,0x00,0x00,0x00,0x68,
              
              };
              #endif
              
              void Mstar_Init_VGA_DVI_HDMI_24C02_EDID(void )
              {
                     WORD  i;
                BYTE RamCheckSum=0, dd=0;
                #if VGA_EDID_Write_To_24C02 
                  bit CheckVGADoubleFlag=0;
                #endif
                #if DVI_EDID_Write_To_24C02 
                  bit CheckDVIDoubleFlag=0;
                #endif
                #if HDMI_EDID_Write_To_24C02
                  bit CheckHDMIDoubleFlag=0;
                #endif
              //----VGA-------------------------------------
              #if VGA_EDID_Write_To_24C02
                if(LoadVGAEDIDFlag)
C51 COMPILER V9.60.0.0   DDC                                                               12/22/2020 19:50:33 PAGE 8   

                {
              #if ENABLE_DEBUG
                  printMsg("No Load VGA_EDID");
              #endif
                          hw_ClrDDC_WP();
              
                  EnableReadDDCType=VGA_EDID;
              
                  //VGA
                  for(i=0; i<128; i++)
                   {
                     //  dd=DVItDDC[i];     
                     NVRam_WriteByte(NVRAM_ADDR_EDID+i, Default_EDID_VGA[i]);
                   }  
                  hw_SetDDC_WP(); 
                     //Read
                  for(i=0; i<128; i++)
                  {
                  NVRam_ReadByte(NVRAM_ADDR_EDID+i, &dd);
                  DDC1[i]=dd;     
                  //printData("%x",dd);
                  }
                  
              
                  ////////Check
                  if((DDC1[0]==0x00)&&(DDC1[1]==0xFF)&&(DDC1[2]==0xFF)&&(DDC1[3]==0xFF)&&(DDC1[4]==0xFF)
                  &&(DDC1[5]==0xFF)&&(DDC1[6]==0xFF)&&(DDC1[7]==0x00)&&(DDC1[0x7F]==Default_EDID_VGA[0x7F]))
                  {
                           for(i=0; i<128; i++)
                           {
                            RamCheckSum += ( DDC1[i] );
                           }
                             
                            // printData("RamCheckSum==%x",RamCheckSum);
                           if((RamCheckSum==0)&&((DDC1[0x14]&0x80)==0x00)) //Analog
                           CheckVGADoubleFlag=1;  
                           else 
                           CheckVGADoubleFlag=0;
                  }
              
                  if(CheckVGADoubleFlag)
                  {
                  EnableReadDDCType=I2C_EEPROM;
                  Clr_LoadVGAEDIDFlag();
                  //Flash_Write_Factory_KeySet(FLASH_KEY_DDCA, 0, DDCAKEY_SIZE, DDC1, DDCAKEY_SIZE);
              #if USEFLASH
                  UserPref_EnableFlashSaveBit( bFlashSaveMonitorBit );
              #else 
                  NVRam_WriteByte(nvrMonitorAddr(OtherFlag), UserPrefOtherFlag);
              #endif
              
              #if ENABLE_DEBUG
                  printMsg("Check VGA DDC Pass");
              #endif
                  }
                  else//DDC Error Reloads 
                  {
                  ////////Load    
                 #if ENABLE_DEBUG
                  printMsg("Check VGA DDC Fail");
                 #endif
                 
C51 COMPILER V9.60.0.0   DDC                                                               12/22/2020 19:50:33 PAGE 9   

                        EnableReadDDCType=I2C_EEPROM;
                  Delay1ms(2);   
                  Set_LoadVGAEDIDFlag();  //Check Next Time
                 
                 #if USEFLASH
                  UserPref_EnableFlashSaveBit( bFlashSaveMonitorBit );
                 #else  
                  NVRam_WriteByte(nvrMonitorAddr(OtherFlag), UserPrefOtherFlag);
                 #endif
                  }
              
                    }
              #endif  
              
              //---DVI--------------------------------------
              #if DVI_EDID_Write_To_24C02
                if(LoadDVIEDIDFlag)
                {
                RamCheckSum=0;
              #if ENABLE_DEBUG
                  printMsg("No Load DVI_EDID");
              #endif
                          hw_ClrDDC_WP();
              
                  EnableReadDDCType=DVI_EDID;
              
                  //HDMI
                  for(i=0; i<128; i++)
                   {
                     //  dd=DVItDDC[i];     
                     NVRam_WriteByte(NVRAM_ADDR_EDID+i, Default_EDID_DVI[i]);
                   }  
              
                  hw_SetDDC_WP(); 
                     //Read
                  for(i=0; i<128; i++)
                  {
                  NVRam_ReadByte(NVRAM_ADDR_EDID+i, &dd);
                  DDC1[i]=dd;     
                  //printData("%x",dd);
                  }
              
                  
                  ////////Check
                  if((DDC1[0]==0x00)&&(DDC1[1]==0xFF)&&(DDC1[2]==0xFF)&&(DDC1[3]==0xFF)&&(DDC1[4]==0xFF)
                  &&(DDC1[5]==0xFF)&&(DDC1[6]==0xFF)&&(DDC1[7]==0x00)&&(DDC1[0x7F]==Default_EDID_DVI[0x7F]))
                  {
                           for(i=0; i<128; i++)
                           {
                            RamCheckSum += ( DDC1[i] );
                           }
                             
                            // printData("RamCheckSum==%x",RamCheckSum);
                           if((RamCheckSum==0)&&((DDC1[0x14]&0x80)==0x80))//Digital
                           CheckDVIDoubleFlag=1;  
                           else
                           CheckDVIDoubleFlag=0;
                  }
              
                  if(CheckDVIDoubleFlag)
                  {
                  EnableReadDDCType=I2C_EEPROM;
C51 COMPILER V9.60.0.0   DDC                                                               12/22/2020 19:50:33 PAGE 10  

                  Clr_LoadDVIEDIDFlag();
                  //Flash_Write_Factory_KeySet(FLASH_KEY_DDCD, 0, DDCDKEY_SIZE, DDC1, DDCDKEY_SIZE);
              #if USEFLASH
                  UserPref_EnableFlashSaveBit( bFlashSaveMonitorBit );
              #else 
                  NVRam_WriteByte(nvrMonitorAddr(OtherFlag), UserPrefOtherFlag);
              #endif
              
              #if ENABLE_DEBUG
                  printMsg("Check DVI DDC Pass");
              #endif
                  }
                  else//DDC Error Reloads 
                  {
                  ////////Load    
                 #if ENABLE_DEBUG
                  printMsg("Check DVI DDC Fail");
                 #endif
                 
                        EnableReadDDCType=I2C_EEPROM;
                  Delay1ms(2);   
                  Set_LoadDVIEDIDFlag();  //Check Next Time
                 
                 #if USEFLASH
                  UserPref_EnableFlashSaveBit( bFlashSaveMonitorBit );
                 #else  
                  NVRam_WriteByte(nvrMonitorAddr(OtherFlag), UserPrefOtherFlag);
                 #endif
                  }
              
                    }
              #endif  
              //--HDMI---------------------------------------
              #if HDMI_EDID_Write_To_24C02
                if(LoadHDMIEDIDFlag)
                {
                RamCheckSum=0;
                CheckHDMIDoubleFlag=1;
                       #if ENABLE_DEBUG
                       printMsg(" Load HDMI_EDID");
                       #endif
                        hw_ClrDDC_WP();
              
                EnableReadDDCType=HDMI_EDID;
              
                //HDMI
                for(i=0; i<256; i++)
                 {
                   //  dd=DVItDDC[i];     
                   NVRam_WriteByte(NVRAM_ADDR_EDID+i, Default_EDID_HDMI[i]);
                 }  
              
                hw_SetDDC_WP(); 
                   //Read
                for(i=0; i<256; i++)
                {
                NVRam_ReadByte(NVRAM_ADDR_EDID+i, &dd);
                DDC1[i]=dd;     
                //printData("%x",dd);
                }
              
              
C51 COMPILER V9.60.0.0   DDC                                                               12/22/2020 19:50:33 PAGE 11  

                  for(i=0;i<256;i++)
                  {
                    if(Default_EDID_HDMI[i]!=DDC1[i])
                        {
                            CheckHDMIDoubleFlag=0;
                            break;
                        }
                  }
                ////////Check
                
              
                if(CheckHDMIDoubleFlag)
                {
                EnableReadDDCType=I2C_EEPROM;
                Clr_LoadHDMIEDIDFlag();
                //Flash_Write_Factory_KeySet(FLASH_KEY_DDCH, 0, DDCHKEY_SIZE, DDC1, DDCHKEY_SIZE);
              #if USEFLASH
                UserPref_EnableFlashSaveBit( bFlashSaveMonitorBit );
              #else 
                NVRam_WriteByte(nvrMonitorAddr(OtherFlag), UserPrefOtherFlag);
              #endif
              
              #if ENABLE_DEBUG
                printMsg("Check HDMI DDC Pass");
              #endif
                }
                else//DDC Error Reloads 
                {
                ////////Load    
               #if ENABLE_DEBUG
                printMsg("Check HDMI DDC Fail");
               #endif
               
                      EnableReadDDCType=I2C_EEPROM;
                Delay1ms(2);   
                Set_LoadHDMIEDIDFlag(); //Check Next Time
               
               #if USEFLASH
                UserPref_EnableFlashSaveBit( bFlashSaveMonitorBit );
               #else  
                NVRam_WriteByte(nvrMonitorAddr(OtherFlag), UserPrefOtherFlag);
               #endif
                }
              
              
                  }
              #endif
              //-----------------------------------------
              
                hw_SetDDC_WP(); 
              
                Init_NVRAM_I2C_SCL_Pin();
                Init_NVRAM_I2C_SDA_Pin();
                
              }
              
              
              
              
              
              
              
C51 COMPILER V9.60.0.0   DDC                                                               12/22/2020 19:50:33 PAGE 12  

              
              
              #endif
 674          
 675          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   ----    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
