C51 COMPILER V9.60.0.0   MSOSD                                                             12/25/2020 09:24:10 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE MSOSD
OBJECT MODULE PLACED IN .\Obj\msOSD.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\UI\msOSD.c OPTIMIZE(9,SPEED) BROWSE INCDIR(..\KERNEL\SYSTEM\INC;..\KE
                    -RNEL\SCALER\INC;..\DRIVER\extDEVICE\INC;..\LIB\INC;..\PANEL\INC;..\UI\BOARD;..\UI\INC;..\UI\MODEL;..\DRIVER\INC;..\Custo
                    -mer) DEFINE(ModelName=TSUMXX9_DEMO) DEBUG OBJECTEXTEND PRINT(.\List\msOSD.lst) TABS(2) OBJECT(.\Obj\msOSD.obj)

line level    source

   1          #include <stdlib.h>
   2          #include "types.h"
   3          #include "ms_reg.h"
   4          //#include "panel.h"
   5          #include "Board.h"
   6          #include "debug.h"
   7          #include "Common.h"
   8          #include "ms_rwreg.h"
   9          #include "mstar.h"
  10          #include "misc.h"
  11          #include "global.h"
  12          #include "menudef.h"
  13          #include "font.h"
  14          //#include "extlib.h"
  15          #include "LoadCommonFont.h"
  16          //#include "msid_v1.h"
  17          #include "drvosd.h"
  18          #include "msosd.h"
  19          #include "colorpalette.h"
  20          #include "loadpropfont1218.h"
  21          
  22          #if CHIP_ID>=CHIP_TSUMV
  23          BYTE xdata g_u8OsdWndNo=OSD_MAIN_WND;
  24          BYTE xdata g_u8FontAddrHiBits=0;
  25          BYTE xdata g_u8OsdFontDataHighByte=0;
  26          #endif
  27          extern void LoadCompressColorFont(BYTE *pu8FontTbl, WORD *pu16MapPtr, BYTE countu8Count);
  28          #if EN_HotKeyXINGZHUN
              
              extern WORD code tXZ_JSIconFont[];
              extern WORD code tXZ1IconFont[];
              extern WORD code tXZ2IconFont[];
              extern WORD code tXZ3IconFont[];
              
              
              
              extern void Osd_LoadCompressMonoFont(BYTE u8Addr, WORD *pu16FontPtr, WORD u16Count);
              #endif
  39          #define DoubleXSize 0
  40          #define DoubleYSize 0
  41          //==================================================================================
  42          // Local function declaration
  43          //
  44          //void mStar_WriteOSDByte( BYTE address, BYTE value );
  45          BYTE mStar_ReadOSDByte( BYTE address );
  46          void Osd_SetWindowSize( BYTE width, BYTE height );
  47          void Osd_SetPosition( BYTE xPos, BYTE yPos );
  48          //void Osd_DrawChar(BYTE xPos, BYTE yPos, BYTE ch);
  49          void msOSDuncall(void);
  50          
  51          extern void mStar_WaitForDataBlanking();
  52          //==================================================================================
  53          // variable declaration
C51 COMPILER V9.60.0.0   MSOSD                                                             12/25/2020 09:24:10 PAGE 2   

  54          //
  55          xdata BYTE OsdWindowWidth = 10;
  56          xdata BYTE OsdWindowHeight = 10;
  57          xdata BYTE OsdFontColor = 0x01;
  58          extern xdata BYTE MenuPageIndex;
  59          extern xdata BYTE MenuItemIndex;
  60          //PropFontType * PropFont_TablePointer;
  61          //WORD * PropFont_MapTablePointer;
  62          
  63          #if 0//CHIP_ID == CHIP_TSUMU
              extern void ColorPaletteUncall(void);
              #endif
  66          //==================================================================================
  67          
  68          
  69          void Osd_InitOSD( void )
  70          {
  71   1          BYTE u8Retry=10;
  72   1      
  73   1          if(!u8Retry)
  74   1          {
  75   2              drvOSD_uncall();
  76   2              msOSDuncall();
  77   2          }
  78   1      
  79   1      #if CHIP_ID>=CHIP_TSUMV
  80   1      
  81   1          msWriteByte(OSD1_00, 0x00); //Set to OSD1 BK0
  82   1      
  83   1          while (u8Retry--)
  84   1          {
  85   2              msWriteByteMask(OSD1_65, BIT1, BIT1);       //clear cafsram
  86   2              ForceDelay1ms(3);
  87   2              if (!(msReadByte(OSD1_65)&BIT1))
  88   2                  break;
  89   2          }
  90   1            msWriteByteMask(OSD1_03, BIT2, BIT2);       //OSD wr priority is over display for both cafsram/psram
  91   1      
  92   1          msWrite2Byte(OSD1_0A, 0x03FF); // 4 color start
  93   1          msWrite2Byte(OSD1_0C, 0x03FF); // 8 color start
  94   1          msWrite2Byte(OSD1_0E, 0x03FF); // 16 color start
  95   1      
  96   1          msWrite2Byte(OSD1_04, PANEL_WIDTH);         //set osd h range size
  97   1          msWrite2Byte(OSD1_06, PANEL_HEIGHT);        //set osd v range size
  98   1          //msWriteByteMask(OSD1_02,BIT1,BIT1);         //force blending
  99   1          //Init cafsram
 100   1          msWrite2Byte(OSD1_08, OSD_FONT_START_ENTRY);               //set font data entry base,
 101   1          msWriteByteMask(OSD1_0B, (OSD_FONT_UNIT_SIZE-1)<<4, BIT4|BIT5);  //Set unit size to 3 entries, [5:4] v
             -alue+1 entries
 102   1      
 103   1          drvOSD_SetWndCABaseAddr(OSD_WIN0,0x0000);
 104   1          drvOSD_SetWndShiftPixel(OSD_WIN0, 0, 0);    //avoid compiler warning
 105   1          drvOSD_SetWndFixColor(OSD_WIN0, 0, 0, 0);   //avoid compiler warning
 106   1      
 107   1          //init OSD_MAIN_WND
 108   1          drvOSD_SetWndCtrl(OSD_MAIN_WND, OSD_WND_CTRL0,
 109   1                            (OWC0_FP_MODE|
 110   1                             OWC0_GROUP_SEL0|
 111   1                             OWC0_LV1_ALPHA_SRC(OSD_A_FIX)|
 112   1                             OWC0_LV2_ALPHA_SRC(OSD_A_FIX)|
 113   1                             OWC0_OUT_ALPHA_SRC(OSD_A_FIX)),
 114   1                             OWC0MASK_ALL);
C51 COMPILER V9.60.0.0   MSOSD                                                             12/25/2020 09:24:10 PAGE 3   

 115   1          drvOSD_SetWndCtrl(OSD_MAIN_WND, OSD_WND_CTRL1,
 116   1                           (OWC1_1BP_44MODE_EN|
 117   1                            OWC1_44MODE_TRS_EN|
 118   1                            OWC1_FONT_HEIGHT(18)),
 119   1                            OWC1MASK_ALL);
 120   1          drvOSD_SetWndCtrl(OSD_MAIN_WND, OSD_WND_CTRL2,
 121   1                           (OWC2_GD_COLOR_R(OSD_COLOR_FIX)|
 122   1                            OWC2_GD_COLOR_G(OSD_COLOR_FIX)|
 123   1                            OWC2_GD_COLOR_B(OSD_COLOR_FIX)),
 124   1                            OWC2MASK_ALL);
 125   1          drvOSD_SetWndCtrl(OSD_MAIN_WND, OSD_WND_CTRL3,
 126   1                           (OWC3_LV1_KM_SWITCH|OWC3MASK_CKEY_INV),
 127   1                            OWC3MASK_ALL);
 128   1      
 129   1          drvOSD_SetWndFixAlpha(OSD_MAIN_WND,OSD_ALPHA_LV2,0x00); //PG   //(1-a)*low_lvl+a*top_lvl
 130   1          drvOSD_SetWndFixAlpha(OSD_MAIN_WND,OSD_ALPHA_LV1,0x3F); //FG
 131   1          drvOSD_SetWndFixAlpha(OSD_MAIN_WND,OSD_ALPHA_OUT,0x3F); //OSD
 132   1          drvOSD_SetWndCABaseAddr(OSD_MAIN_WND,OSD_MAIN_WND_CA_BASE);
 133   1      
 134   1          //init OSD_BUTTON_WND
 135   1          drvOSD_SetWndCtrl(OSD_BUTTON_WND, OSD_WND_CTRL0,
 136   1                           (OWC0_FP_MODE|
 137   1                            OWC0_GROUP_SEL0|
 138   1                            OWC0_LV1_ALPHA_SRC(OSD_A_FIX)|
 139   1                            OWC0_LV2_ALPHA_SRC(OSD_A_FIX)|
 140   1                            OWC0_OUT_ALPHA_SRC(OSD_A_FIX)),
 141   1                            OWC0MASK_ALL);
 142   1          drvOSD_SetWndCtrl(OSD_BUTTON_WND, OSD_WND_CTRL1,
 143   1                           (OWC1_1BP_44MODE_EN|
 144   1                            OWC1_44MODE_TRS_EN|
 145   1                            OWC1_FONT_HEIGHT(18)),
 146   1                            OWC1MASK_ALL);
 147   1          drvOSD_SetWndCtrl(OSD_BUTTON_WND, OSD_WND_CTRL2,
 148   1                           (OWC2_GD_COLOR_R(OSD_COLOR_FIX)|
 149   1                            OWC2_GD_COLOR_G(OSD_COLOR_FIX)|
 150   1                            OWC2_GD_COLOR_B(OSD_COLOR_FIX)),
 151   1                            OWC2MASK_ALL);
 152   1          drvOSD_SetWndCtrl(OSD_BUTTON_WND, OSD_WND_CTRL3,
 153   1                           (OWC3_LV1_KM_SWITCH|OWC3MASK_CKEY_INV),
 154   1                            OWC3MASK_ALL);
 155   1          drvOSD_SetWndFixAlpha(OSD_BUTTON_WND,OSD_ALPHA_LV2,0x00); //PG   //(1-a)*low_lvl+a*top_lvl
 156   1          drvOSD_SetWndFixAlpha(OSD_BUTTON_WND,OSD_ALPHA_LV1,0x3F); //FG
 157   1          drvOSD_SetWndFixAlpha(OSD_BUTTON_WND,OSD_ALPHA_OUT,0x3F); //OSD
 158   1          drvOSD_SetWndCABaseAddr(OSD_BUTTON_WND,OSD_BUTTON_WND_CA_BASE);
 159   1      
 160   1          //init OSD_CURSOR_WND
 161   1          drvOSD_SetWndCtrl(OSD_CURSOR_WND, OSD_WND_CTRL0,
 162   1                           (OWC0_FP_MODE|
 163   1                            OWC0_GROUP_SEL0|
 164   1                            OWC0_LV1_ALPHA_SRC(OSD_A_FIX)|
 165   1                            OWC0_LV2_ALPHA_SRC(OSD_A_FIX)|
 166   1                            OWC0_OUT_ALPHA_SRC(OSD_A_FIX)),
 167   1                            OWC0MASK_ALL);
 168   1          drvOSD_SetWndCtrl(OSD_CURSOR_WND, OSD_WND_CTRL1,
 169   1                           (OWC1_1BP_44MODE_EN|
 170   1                            OWC1_44MODE_TRS_EN|
 171   1                            OWC1_FONT_HEIGHT(18)),
 172   1                            OWC1MASK_ALL);
 173   1          drvOSD_SetWndCtrl(OSD_CURSOR_WND, OSD_WND_CTRL2,
 174   1                           (OWC2_GD_COLOR_R(OSD_GD_EG3)|
 175   1                            OWC2_GD_COLOR_G(OSD_GD_EG4)|
 176   1                            OWC2_GD_COLOR_B(OSD_GD_EG5)),
C51 COMPILER V9.60.0.0   MSOSD                                                             12/25/2020 09:24:10 PAGE 4   

 177   1                            OWC2MASK_ALL);
 178   1          drvOSD_SetWndCtrl(OSD_CURSOR_WND, OSD_WND_CTRL3,
 179   1                            (OWC3_1BPP_ATTR_BIT1|OWC3MASK_CKEY_INV),
 180   1                            OWC3MASK_ALL);
 181   1      
 182   1          drvOSD_SetWndFixAlpha(OSD_CURSOR_WND,OSD_ALPHA_LV2,0x00); //PG   //(1-a)*low_lvl+a*top_lvl
 183   1          drvOSD_SetWndFixAlpha(OSD_CURSOR_WND,OSD_ALPHA_LV1,0x00); //PG
 184   1          drvOSD_SetWndFixAlpha(OSD_CURSOR_WND,OSD_ALPHA_OUT,0x3F); //OSD
 185   1      
 186   1          drvOSD_SetGDEngineEnableWnd(OSD_GD_EG3,OSD_CURSOR_WIN_BIT,OSD_CURSOR_WIN_BIT);
 187   1          drvOSD_SetGDEngineEnableWnd(OSD_GD_EG4,OSD_CURSOR_WIN_BIT,OSD_CURSOR_WIN_BIT);
 188   1          drvOSD_SetGDEngineEnableWnd(OSD_GD_EG5,OSD_CURSOR_WIN_BIT,OSD_CURSOR_WIN_BIT);
 189   1      
 190   1          OSD_SET_WND(OSD_MAIN_WND);
 191   1      #else
                  {
                      BYTE retry = 10;
                          while( retry-- )
                          {
                              msWriteByte( OSD2_A0, BIT6 );
                              Delay1ms( 3 );
                              if( !( msReadByte( OSD2_A0 )&BIT6 ) )
                                  break;
                          }
                  }
                  //msWriteByte( BLENDC, 0 ); //111102 Rick modified cal pipedelay condition - B39842
                  //msWriteByte( BLENDL, 0 );
                  msWriteByte( OSD1_10, 0x80 );
                  msWriteByte( OSDDBC, 0x5 ); // enable double
                  msWriteByte( OCBUFO, 0x00 ); // disable OSD code buffer Base/Offset address
                  msWriteByte( IOSDC3, 0x00 ); //0x0F); // shadow function control
                  msWriteByte( OSDHC, 0x11 ); // shadow width control
                  Osd_SetWindowSize( 20, 10 ); // set osd window
                  msWriteByte( IOSDC2, 0x00 ); // color bit setting
                  msWriteByte( OSD1_70, BIT4 | BIT2 ); // [4]: set osd move step by 1 pixel; [2] add 9 pixels
              #endif
 213   1          Osd_SetPosition(50, 50); // set osd position
 214   1          LoadCommonFont();
 215   1      
 216   1        #if ENABLE_OSD_MASK0_VALUE // initial Mask value for transprent
 217   1        {
 218   2        BYTE i = 0;
 219   2        for (i=0;i<0xFF;i++)
 220   2              drvOSDSetMask0(i,0);
 221   2        }
 222   1        #endif
 223   1      
 224   1      }
 225          
 226          
 227          void MonoColorSetting( void )
 228          {
 229   1          #if CHIP_ID>=CHIP_TSUMV
 230   1          Osd_LoadColorPalette(); // load osd color
 231   1          #else
                  //msWriteByteMask( OCFF, 0xC0, ~BIT5 );//mStar_WriteOSDByteMask( OSD_10, 0xC0, ~BIT5 );
                  msWriteByte( OSDDBC, 0x5 );//mStar_WriteOSDByte( OSDDBC, 0x5 ); // enable double
                  msWriteByte( OCBUFO, 0x00 );//mStar_WriteOSDByte( OCBUFO, 0x00 ); // disable OSD code buffer Base
                  msWriteByte( IOSDC3, 0x00 );// mStar_WriteOSDByte( IOSDC3, 0x00 ); //0x0F); // shadow function control
                  msWriteByte( OSDHC, 0x11 );// mStar_WriteOSDByte( OSDHC, 0x11 ); // shadow width control
                  msWriteByte( IOSDC2, 0x00 );//mStar_WriteOSDByte( IOSDC2, 0x00 ); // color bit setting
                  Osd_LoadColorPalette();
C51 COMPILER V9.60.0.0   MSOSD                                                             12/25/2020 09:24:10 PAGE 5   

                  #endif
 240   1      }
 241          
 242          // setup osd window size
 243          void Osd_SetWindowSize( BYTE width, BYTE height )
 244          {
 245   1          OsdWindowWidth = width;
 246   1          OsdWindowHeight = height;
 247   1      
 248   1      #if CHIP_ID>=CHIP_TSUMV
 249   1        drvOSD_SetWndLineOffset(OSD_MAIN_WND,OsdWindowWidth); //for OSD_MAIN_WND only
 250   1        #if ENABLE_OSD_ROTATION //reset CABase addr after line offset was set
 251   1          if (UserPrefOsdRotateMode==OSDRotateMenuItems_90)
 252   1        {
 253   2              drvOSD_SetWndCABaseAddr(OSD_MAIN_WND, GET_CABASE_0_90(OSD_MAIN_WND_CA_BASE, OsdWindowWidth));
 254   2        }
 255   1        else
 256   1        #if defined(_OSD_ROTATION_180_)
 257   1        if (UserPrefOsdRotateMode==OSDRotateMenuItems_180)
 258   1        {
 259   2              drvOSD_SetWndCABaseAddr(OSD_MAIN_WND, GET_CABASE_0_180(OSD_MAIN_WND_CA_BASE,OsdWindowWidth,OsdWind
             -owHeight));
 260   2        }
 261   1        else
 262   1        #endif
 263   1        #if defined(_OSD_ROTATION_270_)
 264   1        if (UserPrefOsdRotateMode==OSDRotateMenuItems_270)
 265   1        {
 266   2              drvOSD_SetWndCABaseAddr(OSD_MAIN_WND, GET_CABASE_0_270(OSD_MAIN_WND_CA_BASE,OsdWindowWidth,OsdWind
             -owHeight));
 267   2        }
 268   1          else
 269   1        #endif
 270   1              drvOSD_SetWndCABaseAddr(OSD_MAIN_WND, OSD_MAIN_WND_CA_BASE);
 271   1        #endif
 272   1      #else
                   // 110819 wait for coding
              
              
                  msWriteByte(OSD1_06, OsdWindowWidth-1);
                  msWriteByte(OSD1_07, OsdWindowHeight-1);
                  //if(bReset)
                  {
                      //msWriteByte(OSD2_A0, 0xDE); // clear osd content
                      //ForceDelay1ms(3);
                  }
                  msWriteByte(OSD2_A0, 0xBE);//0x9E);
              
              #endif
 286   1      
 287   1      }
 288          
 289          // setup
 290          #define MainMenuOSD_Height  20
 291          #define OSD_TRANSPARENT_SHIFT     7
 292          #if CHIP_ID>=CHIP_TSUMV
 293          #define OSD_WINDOW(Addr)    ((OSD_MAIN_WND<<5)+Addr)
 294          void Osd_SetPosition( BYTE xPos, BYTE yPos )
 295          {
 296   1      #if ENABLE_MENULOAD
                  WORD HposValue, VposValue;
              
C51 COMPILER V9.60.0.0   MSOSD                                                             12/25/2020 09:24:10 PAGE 6   

                  HposValue = (( DWORD )xPos * ( PanelWidth - ( WORD )OsdWindowWidth * 12 ) ) / 100;
              
                  yPos = 100 - yPos;
                  VposValue = (( DWORD )yPos * ( PanelHeight - ( WORD )OsdWindowHeight * 18 ) ) / 100;
                  if( yPos == 100 && OsdWindowHeight == MainMenuOSD_Height )
                      VposValue += OSD_TRANSPARENT_SHIFT;
              
                  msML_WaitReady();
                  msML_WriteByte(ML_MODE_NORMAL ,OSD_WINDOW(OSD2_04), HposValue);
                  msML_WriteByte(ML_MODE_NORMAL ,OSD_WINDOW(OSD2_05), HposValue>>8);
                  msML_WriteByte(ML_MODE_NORMAL ,OSD_WINDOW(OSD2_08), (HposValue+( WORD )OsdWindowWidth * 12));
                  msML_WriteByte(ML_MODE_NORMAL ,OSD_WINDOW(OSD2_09), (HposValue+( WORD )OsdWindowWidth * 12)>>8);
                  msML_WriteByte(ML_MODE_NORMAL ,OSD_WINDOW(OSD2_06), VposValue);
                  msML_WriteByte(ML_MODE_NORMAL ,OSD_WINDOW(OSD2_07), VposValue>>8);
                  msML_WriteByte(ML_MODE_NORMAL ,OSD_WINDOW(OSD2_0A), (VposValue+( WORD )OsdWindowHeight * 18));
                  msML_WriteByte(ML_MODE_NORMAL ,OSD_WINDOW(OSD2_0B), (VposValue+( WORD )OsdWindowHeight * 18)>>8);
                  msML_Trigger(ML_TRIG_OUT_VDE_END);// Vde-end-OP
              
              #else
 318   1          BYTE u8xPos, u8yPos;
 319   1          WORD posValue;
 320   1          WORD u16Hight;
 321   1      
 322   1      #if CHIP_ID>=CHIP_TSUMV
 323   1          Sint xdata  xOffset = 0, yOffset = 0;
 324   1          WORD preMainHStart, preMainVStart;
 325   1      #endif
 326   1      #if ENABLE_OSD_ROTATION
 327   1          BYTE bInvertPosition = FALSE;
 328   1      #endif
 329   1      
 330   1      #if ENABLE_SW_DOUBLE_BUFFER
 331   1          msSWDBWriteToRegister();
 332   1          msSWDBWaitForRdy();
 333   1      #endif
 334   1      #if CHIP_ID>=CHIP_TSUMV
 335   1          preMainHStart = drvOSD_GetWndInfo ( OSD_MAIN_WND, OSD_WND_INFO_H_START );
 336   1          preMainVStart = drvOSD_GetWndInfo ( OSD_MAIN_WND, OSD_WND_INFO_V_START );
 337   1      #endif
 338   1      #if ENABLE_OSD_ROTATION
 339   1          if ( UserPrefOsdRotateMode==OSDRotateMenuItems_90 )
 340   1          {
 341   2              bInvertPosition = TRUE;
 342   2              u8xPos = 100 - yPos;
 343   2              u8yPos = 100 - xPos;        
 344   2          }
 345   1          else
 346   1        #ifdef _OSD_ROTATION_180_
 347   1          if ( UserPrefOsdRotateMode==OSDRotateMenuItems_180 )
 348   1          {
 349   2              bInvertPosition = FALSE;
 350   2              u8xPos = 100 - xPos;
 351   2              u8yPos = yPos;        
 352   2          }
 353   1          else
 354   1        #endif
 355   1        #ifdef _OSD_ROTATION_270_
 356   1          if ( UserPrefOsdRotateMode==OSDRotateMenuItems_270 )
 357   1          {
 358   2              bInvertPosition = TRUE;
 359   2              u8xPos = yPos;
 360   2              u8yPos = xPos;        
C51 COMPILER V9.60.0.0   MSOSD                                                             12/25/2020 09:24:10 PAGE 7   

 361   2          }
 362   1          else
 363   1        #endif
 364   1      #endif
 365   1        {
 366   2      #if ENABLE_OSD_ROTATION    
 367   2              bInvertPosition = FALSE;
 368   2      #endif
 369   2              u8xPos = xPos;
 370   2              u8yPos = 100 - yPos;
 371   2          }
 372   1      #if (ENABLE_OSD_ROTATION)
 373   1          if ( bInvertPosition )
 374   1          {
 375   2              posValue = ( ( DWORD ) u8xPos * ( PANEL_WIDTH - ( WORD ) ((OsdWindowHeight) * 18) ) ) / 100;
 376   2          }
 377   1          else
 378   1      #endif
 379   1          {
 380   2              posValue = ( ( DWORD ) u8xPos * ( PANEL_WIDTH - ( WORD ) ((OsdWindowWidth) * 12) ) ) / 100;
 381   2          }
 382   1          xOffset = posValue - preMainHStart;
 383   1          DB_W2B ( ( OSD_WIN1 << 5 ) + OSD2_04, posValue );
 384   1      #if ENABLE_OSD_ROTATION
 385   1          if ( bInvertPosition )
 386   1          {
 387   2              DB_W2B ( ( OSD_WIN1 << 5 ) + OSD2_08, posValue + ( WORD ) ((OsdWindowHeight) * 18) );
 388   2          }
 389   1          else
 390   1      #endif
 391   1          {
 392   2              DB_W2B ( ( OSD_WIN1 << 5 ) + OSD2_08, posValue + ( WORD ) ((OsdWindowWidth) * 12) );
 393   2          }
 394   1      
 395   1      #if (ENABLE_OSD_ROTATION)
 396   1          u16Hight = PANEL_HEIGHT ;
 397   1          if ( bInvertPosition )
 398   1        {
 399   2              posValue = ( ( DWORD ) u8yPos * ( u16Hight - ( WORD ) (((OsdWindowWidth)) * 12) ) / 100 );
 400   2        }
 401   1          else
 402   1      #endif
 403   1          {
 404   2              posValue = ( ( DWORD ) u8yPos * ( u16Hight - ( WORD ) (((OsdWindowHeight)) * 18) ) ) / 100;
 405   2          }
 406   1      #if CHIP_ID>=CHIP_TSUMV
 407   1          yOffset = posValue - preMainVStart;
 408   1          DB_W2B ( ( OSD_WIN1 << 5 ) + OSD2_06, posValue );
 409   1      #if ENABLE_OSD_ROTATION
 410   1          if ( bInvertPosition )
 411   1          {
 412   2              DB_W2B ( ( OSD_WIN1 << 5 ) + OSD2_0A, posValue + ( WORD ) ((OsdWindowWidth) * 12) );
 413   2          }
 414   1          else
 415   1      #endif
 416   1          {
 417   2              DB_W2B ( ( OSD_WIN1 << 5 ) + OSD2_0A, posValue + ( WORD ) ((OsdWindowHeight )* 18) );
 418   2          }
 419   1      #endif
 420   1      
 421   1      
 422   1      
C51 COMPILER V9.60.0.0   MSOSD                                                             12/25/2020 09:24:10 PAGE 8   

 423   1      #if ENABLE_SW_DOUBLE_BUFFER
 424   1          #if CHIP_ID==CHIP_TSUMF // TSUMF no VDE end trig source, instead by OSD_VDE_End sw polling & trigger
                  msSWDBWriteToRegisterByOsdEnd();
                  #else
 427   1          msSWDBWriteToRegister();
 428   1          #endif
 429   1          msSWDBWaitForRdy();
 430   1        #endif
 431   1      #endif
 432   1      }
 433          #else
              #define ScalingDown_PIPESHIFT    10
              WORD drvOsdGetPipeDelay( void )
              {
                  WORD  xdata OPBackPorch;
                  BYTE  xdata PIPESHIFT;
                  PIPESHIFT =msReadByte( OSD1_4B );
                  OPBackPorch=msRead2Byte(SC0_12);
                  //if(g_SetupPathInfo.bScalingUpV)
              #if CHIP_ID == CHIP_TSUMY       //111005 Rick modified OSD Position formula - A041
                  OPBackPorch=(PIPESHIFT-OPBackPorch-23);//*2;
              #else
                      OPBackPorch=(PIPESHIFT-OPBackPorch-38)*2;
              #endif
                  //else
                      //OPBackPorch=(PIPESHIFT-OPBackPorch-38+ScalingDown_PIPESHIFT)*2;
                  return OPBackPorch;
              }
              void Osd_SetPosition( BYTE xPos, BYTE yPos )
              {
                  WORD  xdata posValue;
              
              #if DoubleXSize
                  posValue = (( DWORD )xPos * ( PanelWidth - ( WORD )OsdWindowWidth * 12 * 2 ) ) / 100 + ( ( PanelHStart
             -/PANEL_H_DIV ) - 48 );
              #else
                posValue = (( DWORD )xPos * ( PanelWidth - ( WORD )OsdWindowWidth * 12 ) ) / 100 - drvOsdGetPipeDelay();
             - //);
              #endif
              
                  msWriteByte( OSD1_02, posValue & 0xFF );
                  msWriteByte( OSD1_03, posValue >> 8 );
              
                  posValue = ( PanelWidth - ( WORD )OsdWindowWidth * 12 ) - 4;
                  msWriteByte( OSD2_0A, posValue & 0xFF );
                  msWriteByte( OSD2_0B, (msReadByte(OSD2_0B)&0x80) |(posValue >> 8) );
              
                  yPos = 100 - yPos;
              
              #if DoubleYSize
                  posValue = (( DWORD )yPos * ( PanelHeight - ( WORD )OsdWindowHeight * 18 * 2 ) ) / 100;
              #else
                  posValue = (( DWORD )yPos * ( PanelHeight - ( WORD )OsdWindowHeight * 18 ) ) / 100;
              #endif
              
                  // 100811 coding addition for main menu osd
                  if( yPos == 100 && OsdWindowHeight == MainMenuOSD_Height )
                      posValue += OSD_TRANSPARENT_SHIFT;
              
                  msWriteByte( OSD1_04, posValue & 0xFF );
                  msWriteByte( OSD1_05, posValue >> 8 );
              
C51 COMPILER V9.60.0.0   MSOSD                                                             12/25/2020 09:24:10 PAGE 9   

              }
              #endif
 485          void Osd_SetTextMonoColor( BYTE foreColor, BYTE backColor )
 486          {
 487   1          OsdFontColor = ( foreColor & 0xF ) << 4 | ( backColor & 0xF );
 488   1      }
 489          void Osd_SetTextColor( BYTE foreColor, BYTE backColor )
 490          {
 491   1          // OsdFontColor=(foreColor&0xF)<<4|(backColor&0xF);
 492   1          if( backColor == Color_2 )
 493   1              OsdFontColor = foreColor << 1;
 494   1          else if( backColor == Color_4 )
 495   1              OsdFontColor = foreColor << 2;
 496   1          else if( backColor == Color_8 )
 497   1              OsdFontColor = foreColor << 3;
 498   1          else if( backColor == Color_2T )
 499   1              OsdFontColor = foreColor << 1 | 0x01;
 500   1          else if( backColor == Color_4T )
 501   1              OsdFontColor = foreColor << 2 | 0x01;
 502   1          else// (backColor==Color_8T)
 503   1              OsdFontColor = foreColor << 3 | 0x01;
 504   1      }
 505          
 506          //Character Direct Write DisplayCode
 507          void Osd_DrawCharDirect(BYTE u8XPos, BYTE u8YPos, WORD u8Char)
 508          {
 509   1      #if CHIP_ID>=CHIP_TSUMV
 510   1          if(( u8Char & 0xFF00 ) == 0x100 )
 511   1          {
 512   2              OSD_TEXT_HI_ADDR_SET_BIT8();
 513   2          }
 514   1          else if(( u8Char & 0xFF00 ) == 0x200 )
 515   1          {
 516   2              OSD_TEXT_HI_ADDR_SET_BIT9();
 517   2          }
 518   1          else
 519   1          {
 520   2              OSD_TEXT_HI_ADDR_CLR_TO_0();
 521   2          }
 522   1          
 523   1          drvOSD_DrawRealChar(g_u8OsdWndNo, u8XPos, u8YPos, u8Char);
 524   1          
 525   1        OSD_TEXT_HI_ADDR_CLR_TO_0();
 526   1      #else
                  WORD u16TempValue;
                  BYTE u8DrawCode = (!(u8YPos & BIT7));
              
                  u8YPos &= 0x7F;
              
                  u16TempValue=(WORD)u8YPos*OsdWindowWidth+u8XPos; // get real address
                  msWrite2Byte(OSD2_A8, u16TempValue); // display font attribute
                  msWriteByte(OSD2_AA, OsdFontColor);
                  if (u8DrawCode)
                  {
                      msWrite2Byte(OSD2_A5, u16TempValue); // dispaly font code
              
                      if(( u8Char & 0xFF00 ) == 0x100 )
                      {
                          OSD_TEXT_HI_ADDR_SET_BIT8();
                      }
                      else if(( u8Char & 0xFF00 ) == 0x200 )
                      {
C51 COMPILER V9.60.0.0   MSOSD                                                             12/25/2020 09:24:10 PAGE 10  

                          OSD_TEXT_HI_ADDR_SET_BIT9();
                      }
                      else
                      {
                          OSD_TEXT_HI_ADDR_CLR_TO_0();
                      }
                      
                      msWriteByte(OSD2_A7, u8Char);
                      
                    OSD_TEXT_HI_ADDR_CLR_TO_0();
                 }
              #endif
 557   1      
 558   1      
 559   1      }
 560          void Osd_DrawContinuesChar(BYTE u8XPos, BYTE u8YPos, WORD u8Char, BYTE u8Num)
 561          {
 562   1      
 563   1      #if CHIP_ID>=CHIP_TSUMV
 564   1          if(( u8Char & 0xFF00 ) == 0x100 )
 565   1          {
 566   2              OSD_TEXT_HI_ADDR_SET_BIT8();
 567   2          }
 568   1          else if(( u8Char & 0xFF00 ) == 0x200 )
 569   1          {
 570   2              OSD_TEXT_HI_ADDR_SET_BIT9();
 571   2          }
 572   1          else
 573   1          {
 574   2              OSD_TEXT_HI_ADDR_CLR_TO_0();
 575   2          }
 576   1          
 577   1          drvOSD_DrawContinuousChar(g_u8OsdWndNo,u8XPos,u8YPos,u8Char,u8Num);
 578   1          
 579   1        OSD_TEXT_HI_ADDR_CLR_TO_0();
 580   1      #else
                  WORD u16TempValue;
                  BYTE i;
                  BYTE    u8DrawCode = (!(u8YPos & BIT7));
              
                  u8YPos &= 0x7F;
              
                  u16TempValue=(WORD)u8YPos*OsdWindowWidth+u8XPos; // get real address
                  msWrite2Byte(OSD2_A8, u16TempValue);
                  for(i=0;i<u8Num;i++)
                  {
                      msWriteByte(OSD2_AA, OsdFontColor);
                  }
                  if (u8DrawCode)
                  {
                      msWrite2Byte(OSD2_A5, u16TempValue);
                      
                      if(( u8Char & 0xFF00 ) == 0x100 )
                      {
                          OSD_TEXT_HI_ADDR_SET_BIT8();
                      }
                      else if(( u8Char & 0xFF00 ) == 0x200 )
                      {
                          OSD_TEXT_HI_ADDR_SET_BIT9();
                      }
                      else
                      {
C51 COMPILER V9.60.0.0   MSOSD                                                             12/25/2020 09:24:10 PAGE 11  

                          OSD_TEXT_HI_ADDR_CLR_TO_0();
                      }
                      
                      for(i=0;i<u8Num;i++)
                      {
                          msWriteByte(OSD2_A7, u8Char);
                      }
                      
                    OSD_TEXT_HI_ADDR_CLR_TO_0();
                  }
              #endif
 618   1      
 619   1      }
 620          
 621          void Osd_DrawPropStr(BYTE u8XPos, BYTE u8YPos, BYTE *pu8Str)
 622          {
 623   1      #if CHIP_ID>=CHIP_TSUMV
 624   1      
 625   1          WORD  xdata  u16TempValue;
 626   1          Bool  xdata  IsDrawCode = TRUE;
 627   1      
 628   1          if (pu8Str==NULL || (*(pu8Str + 1))==0) //Jison
 629   1              return;
 630   1          if (u8YPos & BIT7)
 631   1              IsDrawCode = FALSE;
 632   1      
 633   1          if( u8YPos == 2 || u8XPos == 0 )
 634   1          {
 635   2              u8XPos=( OsdWindowWidth - (*(pu8Str + 1)) ) / 2 + 1;
 636   2          }
 637   1      
 638   1          u8YPos &= 0x7F; //~(BIT7|BIT6);
 639   1      #define DISP_CHAR   u8XPos
 640   1      #define DISP_PTR    u8YPos
 641   1      
 642   1          u16TempValue=GET_TXT_CASTART(g_u8OsdWndNo,u8XPos,u8YPos); // get real address
 643   1          DISP_PTR = 0;
 644   1          WRITE_CAFSRAM_ADDR();
 645   1          msWrite2Byte(PORT_ATTR_ADDR, u16TempValue);
 646   1          WRITE_ATTRIBUTE();
 647   1          while (DISP_PTR++ < *(pu8Str + 1))
 648   1              msWriteByte(PORT_ATTR_DATA, OsdFontColor);
 649   1      
 650   1          if (IsDrawCode == TRUE)
 651   1          {
 652   2              DISP_PTR = 0;
 653   2           WRITE_CAFSRAM_ADDR();
 654   2              msWrite2Byte(PORT_CODE_ADDR, u16TempValue);
 655   2           WRITE_CODE();
 656   2              while (DISP_PTR < *(pu8Str + 1))
 657   2              {
 658   3                  msWriteByte(PORT_CODE_DATA, (*pu8Str) + DISP_PTR);
 659   3                  DISP_PTR++;
 660   3              }
 661   2          }
 662   1      
 663   1      #undef DISP_CHAR
 664   1      #undef DISP_PTR
 665   1      
 666   1      #else
                  WORD tempValue;
                  BYTE drawCode = TRUE, drawCode1 = FALSE, tempdispPtr;
C51 COMPILER V9.60.0.0   MSOSD                                                             12/25/2020 09:24:10 PAGE 12  

                  if( u8YPos & BIT7 )
                  {
                      drawCode = FALSE;
                  }
                  if( u8YPos & BIT6 )
                      //set center
                  {
                      drawCode1 = TRUE;
                  }
                  u8YPos &= 0x3F; //~(BIT7|BIT6);
              #define dispChar    u8XPos
              #define dispPtr     tempdispPtr
                  if( u8YPos == 2 || u8XPos == 0 )
                      // just for title
                  {
                      //20070403
                      tempValue = ( WORD )u8YPos * OsdWindowWidth + ( OsdWindowWidth - *( pu8Str + 1 ) ) / 2 + 1; //temp
             -Value = ( WORD ) yPos * OsdWindowWidth + OsdWindowWidth/2;
                      drawCode1 = 1;
                  }
                  else
                      tempValue = ( WORD )u8YPos * OsdWindowWidth + u8XPos;
                  // get real address
                  dispPtr = 0;
                  msWrite2Byte( OSD2_A8, tempValue );
                  while( dispPtr++ < *( pu8Str + 1 ) )
                  {
                      msWriteByte( OSD2_AA, OsdFontColor );
                  }
                  if( drawCode1 )
                  {
                      BYTE tlen;
                      if( u8YPos == 2 || u8XPos == 0 )
                      {
                          //tempValue =tempValue;     //tempValue =tempValue -dispPtr/2+1 ;       //20070403
                      }
                      else
                      {
                          tlen = ( OsdWindowWidth - u8XPos - dispPtr ) / 2; // get center position
                          tempValue += tlen;
                      }
                  }
                  if( drawCode == TRUE )
                  {
                      dispPtr = 0;
                      msWrite2Byte( OSD2_A5, tempValue );
                      while( dispPtr < *( pu8Str + 1 ) )
                      {
                          msWriteByte( OSD2_A7, ( *pu8Str ) + dispPtr );
                          dispPtr++;
                          //printMsg("Draw Porational");
                          #if DEBUG_OSD
                          ForceDelay1ms(20);
                          #endif
              
                      }
                  }
              #undef dispChar
              #undef dispPtr
              #endif
 728   1      }
 729          
C51 COMPILER V9.60.0.0   MSOSD                                                             12/25/2020 09:24:10 PAGE 13  

 730          #define Num2ASCII(Num) (Num+0x30)
 731          
 732          void DrawNum(BYTE xPos, BYTE yPos, char len, WORD value)
 733          { 
 734   1        char _minus=0;
 735   1      
 736   1        if (value<0)
 737   1        { 
 738   2          value=0-value;
 739   2          _minus=1;
 740   2        }
 741   1        if (value==0)
 742   1          Osd_DrawCharDirect(xPos+(len--), yPos, (BYTE)Num2ASCII(0));
 743   1        else
 744   1        { 
 745   2          while (value && len) // translate integer to string
 746   2          {
 747   3            Osd_DrawCharDirect(xPos+(len--), yPos, (BYTE)Num2ASCII(value%10));
 748   3            value/=10;
 749   3          }
 750   2        }
 751   1        if (_minus && len>=0)// add sign
 752   1          Osd_DrawCharDirect(xPos+(len--), yPos, (BYTE)'-');
 753   1        _minus=(_minus)?(0):(1);
 754   1        for (; _minus<=len; _minus++)
 755   1          Osd_DrawCharDirect(xPos+_minus, yPos, (BYTE)' ');
 756   1      }
 757          
 758          
 759          void Osd_DrawNum( BYTE xPos, BYTE yPos, int value )
 760          {
 761   1          DrawNum( xPos, yPos, 3, value );
 762   1      }
 763          
 764          void Osd_Draw4Num( BYTE xPos, BYTE yPos, int value )
 765          {
 766   1          DrawNum( xPos, yPos, 4, value );
 767   1      }
 768          #if BlacklitTimeOnShow 
 769          void Osd_Draw5Num(BYTE xPos, BYTE yPos, WORD value)
 770          { 
 771   1        DrawNum(xPos, yPos, 5, value);
 772   1      }  
 773          void Osd_Draw2Num(BYTE xPos, BYTE yPos, int value)
 774          {   
 775   1        DrawNum(xPos, yPos, 2, value);
 776   1      }
 777          #endif
 778          
 779          // Draw Hex for Debug
 780          BYTE Hex2ASCII(BYTE Num)
 781          {
 782   1          return ( Num < 10 ) ? ( Num + 0x30 ) : ( Num - 10 + 0x41 );
 783   1      }
 784          void DrawHex(BYTE xPos, BYTE yPos, BYTE value)
 785          {
 786   1          char len=1;
 787   1          while( value && len >= 0 )
 788   1          {
 789   2              Osd_DrawCharDirect( xPos + ( len-- ), yPos, ( BYTE )Hex2ASCII( value % 0x10 ) );
 790   2              value /= 0x10;
 791   2          }
C51 COMPILER V9.60.0.0   MSOSD                                                             12/25/2020 09:24:10 PAGE 14  

 792   1          if( len > 0 )
 793   1          {
 794   2              for( value = 0; value <= len; value++ )
 795   2              {
 796   3                  Osd_DrawCharDirect( xPos + value, yPos, ( BYTE )0x30 );
 797   3              }
 798   2          }
 799   1      }
 800          void Osd_DrawHex(BYTE xPos, BYTE yPos, BYTE value)
 801          {
 802   1          DrawHex(xPos, yPos, value);
 803   1      }
 804          
 805          void DrawWordHex(BYTE xPos, BYTE yPos, WORD value)
 806          {
 807   1          char len=3;
 808   1          while( value>=0 && len >= 0 )
 809   1          {
 810   2              Osd_DrawCharDirect( xPos + ( len-- ), yPos, ( BYTE )Hex2ASCII( value % 0x10 ) );
 811   2              value /= 0x10;
 812   2          }
 813   1          if( len > 0 )
 814   1          {
 815   2              for( value = 0; value <= len; value++ )
 816   2              {
 817   3                  Osd_DrawCharDirect( xPos + value, yPos, ( BYTE )0x30 );
 818   3              }
 819   2          }
 820   1      }
 821          void Osd_DrawWordHex(BYTE xPos, BYTE yPos, WORD value)
 822          {
 823   1          DrawWordHex(xPos, yPos, value);
 824   1      }
 825          
 826          //===================================================================================
 827          void Osd_Show( void )
 828          {
 829   1      #if CHIP_ID>=CHIP_TSUMV
 830   1          mStar_WaitForDataBlanking();
 831   1          drvOSD_SetWndOn(OSD_MAIN_WND, TRUE);
 832   1      #else
                  BYTE u8RegByte;
                  u8RegByte=(DoubleXSize<<4)|(DoubleYSize<<6)|MWIN_B;//|0x8
                  msWriteByte(OSD1_0C, u8RegByte);
              #endif
 837   1      
 838   1      }
 839          
 840          
 841          void Osd_Hide( void )
 842          {
 843   1      #if CHIP_ID>=CHIP_TSUMV
 844   1      
 845   1          drvOSD_SetWndOn(OSD_MAIN_WND, FALSE);
 846   1      #else
                  #if DEBUG_OSD
                  msWriteByte( IOSDC1, ( DoubleXSize << 4 ) | ( DoubleYSize << 6 ) | MWIN_B );
                  #else
                  msWriteByte( IOSDC1, 0x00 );
                  #endif
              #endif
 853   1      }
C51 COMPILER V9.60.0.0   MSOSD                                                             12/25/2020 09:24:10 PAGE 15  

 854          void Osd_SetTransparency(BYTE u8Value)
 855          {
 856   1          u8Value=0x3F-(u8Value*8);
 857   1          drvOSD_SetWndFixAlpha(OSD_MAIN_WND, OSD_ALPHA_OUT, u8Value);
 858   1          drvOSD_SetWndFixAlpha(OSD_BUTTON_WND, OSD_ALPHA_OUT, u8Value);
 859   1          drvOSD_SetWndFixAlpha(OSD_CURSOR_WND, OSD_ALPHA_OUT, u8Value);
 860   1      }
 861          // ============================
 862          void Osd_DynamicLoadFont( BYTE addr, BYTE *fontPtr, WORD num )
 863          {
 864   1      
 865   1          #if PropFontUseCommonArea
 866   1          #if 0  //disable by smc.lmw 20160628
                  if ( UserPrefLanguage == LANG_TChina )
                  {
                      SecondTblAddr = 0x80;
                      LanguageIndex = 1;
                  }
                  else if ( UserPrefLanguage == LANG_Korea )
                  {
                      SecondTblAddr = 0x80;
                      LanguageIndex = 2;
                  }
                  
                  else
                  #endif
 880   1          {
 881   2              SecondTblAddr = 0xFF;
 882   2              LanguageIndex = 0;
 883   2          }
 884   1          #else
                  pstPropFontSet1218=tPropFontSet;
                  #endif
 887   1          g_u8PropFontFlags=SPACE1PIXEL;
 888   1      
 889   1          LoadPropFonts1218(addr, fontPtr, num, NULL, 0, 0, 0);
 890   1      
 891   1      }
 892          
 893          BYTE Osd_DoubleBuffer(Bool u8Enable)
 894          {
 895   1        #if CHIP_ID>=CHIP_TSUMV
 896   1          u8Enable=0;
 897   1          return u8Enable;
 898   1        #else
                  BYTE u8Org=msReadByte(OSD1_01);
                  msWriteByte(OSD1_01,(u8Enable?0x05:0));
                  return (u8Org);
                #endif
 903   1      }
 904          
 905          void msOSDuncall(void)
 906          {
 907   1      #if !ENABLE_MENULOAD
 908   1             drvOSD_SetWndHPosition(0, 0, 0);
 909   1             drvOSD_SetWndVPosition(0, 0, 0);
 910   1      #endif
 911   1      }
 912          
 913          #if ENABLE_OSD_MASK0_VALUE
 914          void drvOSDSetMask0(BYTE item, BYTE v)
 915          {
C51 COMPILER V9.60.0.0   MSOSD                                                             12/25/2020 09:24:10 PAGE 16  

 916   1          _CTRL_OSD_CTRL_REGISTERS();
 917   1          SET_OSD_CTRL_REG_TRIG_MODE(_TRIG_MODE_P0_ADDR);
 918   1          SET_OSD_CTRL_REG_WR_PORT(item);
 919   1          SET_OSD_CTRL_REG_TRIG_MODE(_TRIG_MODE_P0_MASK);
 920   1          SET_OSD_CTRL_REG_WR_PORT(v);
 921   1      }
 922          
 923          #endif
 924          
 925          
 926          //VS CCFLAG  ADD
 927          void Osd_Set256TextColor(BYTE foreColor, BYTE backColor)
 928          {
 929   1         if(backColor==Color_2)
 930   1            OsdFontColor=foreColor;
 931   1         else if(backColor==Color_2G)
 932   1            OsdFontColor=(foreColor&0xF0)|0x01;
 933   1         else if(backColor==Color_4)
 934   1            OsdFontColor=foreColor<<2;
 935   1         else if(backColor==Color_8)
 936   1            OsdFontColor=foreColor<<3;
 937   1         else if(backColor==Color_8G)
 938   1            OsdFontColor=(foreColor<<3)|BIT1;
 939   1         else if(backColor==Color_2T)
 940   1            OsdFontColor=foreColor|0x00;
 941   1         else if(backColor==Color_4T)
 942   1            OsdFontColor=foreColor<<2|0x01;
 943   1         else// (backColor==Color_8T)
 944   1            OsdFontColor=foreColor<<3|0x01;
 945   1      }
 946          
 947          #if EN_HotKeyXINGZHUN
              
              void DynamicLoad_2CrossFont(BYTE menuPageIndex)
              {
              
              #if 1//EN_HotKeyXINGZHUN
              
                if(menuPageIndex==HotXINGZHUN)
                 {
                  Osd_LoadCompressMonoFont(MonoFontXZStart, tXZ_JSIconFont, sizeof(tXZ_JSIconFont));
                 }
                  else if(menuPageIndex==HotXINGZHUN1||menuPageIndex==HotXINGZHUN4)
                 {
                  Osd_LoadCompressMonoFont(MonoFontXZStart, tXZ1IconFont, sizeof(tXZ1IconFont));
                }
                else if(menuPageIndex==HotXINGZHUN2||menuPageIndex==HotXINGZHUN5)
                   {
                    Osd_LoadCompressMonoFont(MonoFontXZStart, tXZ2IconFont, sizeof(tXZ2IconFont));
                  }
                else if(menuPageIndex==HotXINGZHUN3||menuPageIndex==HotXINGZHUN6)
                   {
                    Osd_LoadCompressMonoFont(MonoFontXZStart, tXZ3IconFont, sizeof(tXZ3IconFont));
                  }
              
              
               #endif
               
              
              }
              #endif
 977          
C51 COMPILER V9.60.0.0   MSOSD                                                             12/25/2020 09:24:10 PAGE 17  

 978          
 979          void DynamicLoad_4ColorFont(BYTE menuPageIndex)
 980          {   
 981   1        OSD_FONT_HI_ADDR_SET_BIT8();
 982   1      
 983   1        //Osd_Write4ColorFontStartAddr( 0x100+FONT_4COLOR_ICON_START );
 984   1      
 985   1              if (menuPageIndex==MainMenu)
 986   1              {
 987   2              printData("xxxxxxxxxxx\n", FONT_4COLOR_ICON_START);
 988   2          
 989   2          OSD_WRITE_FONT_ADDRESS(FONT_4COLOR_ICON_START);
 990   2           LoadCompressColorFont(&Main_4ColorIcon, NULL, 18);
 991   2              }
 992   1              
 993   1               #if EN_HotKeyDCRMenuWithIcon
                       else if(menuPageIndex==HotKeyDCROnMenu)
                       {
                       OSD_WRITE_FONT_ADDRESS(FONT_4COLOR_ICON_START);
                       LoadCompressColorFont(&tDCRONIconFont, NULL, 12);
                       }
                       else if(menuPageIndex==HotKeyDCROffMenu)
                       {
                       OSD_WRITE_FONT_ADDRESS(FONT_4COLOR_ICON_START);
                        LoadCompressColorFont(&tDCROFFIconFont, NULL, 12);
                       }
                       #endif
1005   1      #if EN_HotKeyECOMenuWithIcon
                else if(menuPageIndex==HotKeyECOMoveMenu)
                {
                  OSD_WRITE_FONT_ADDRESS(FONT_4COLOR_ICON_START);
                              LoadCompressColorFont(&tECOMoveIconFont, NULL, 12);
                }
                else if(menuPageIndex==HotKeyECOWebMenu)
                {
                        OSD_WRITE_FONT_ADDRESS(FONT_4COLOR_ICON_START);
                              LoadCompressColorFont(&tECOWebIconFont, NULL, 12);
                }
                else if(menuPageIndex==HotKeyECOGameMenu)
                {
                        OSD_WRITE_FONT_ADDRESS(FONT_4COLOR_ICON_START);
                              LoadCompressColorFont( &tECOGameIconFont, NULL, 12);
                }
                else if(menuPageIndex==HotKeyECOStandardMenu)
                {
                        OSD_WRITE_FONT_ADDRESS(FONT_4COLOR_ICON_START);
                              LoadCompressColorFont( &tDCRStandardIconFont, NULL, 12);
                }
               #endif
1027   1      #if 0//EN_HotKeyXINGZHUN
               else if(menuPageIndex==HotXINGZHUN)
               {
                 OSD_WRITE_FONT_ADDRESS(FONT_XZ4COLOR_ICON_START);
                 LoadCompressColorFont(&tXZ_JSIconFont, NULL, 31);
               }
               else if(menuPageIndex==HotXINGZHUN1||menuPageIndex==HotXINGZHUN4)
                {
                  OSD_WRITE_FONT_ADDRESS(FONT_XZ4COLOR_ICON_START);
                  LoadCompressColorFont(&tXZ1IconFont, NULL, 36);
                }
               else if(menuPageIndex==HotXINGZHUN2||menuPageIndex==HotXINGZHUN5)
                {
C51 COMPILER V9.60.0.0   MSOSD                                                             12/25/2020 09:24:10 PAGE 18  

                  OSD_WRITE_FONT_ADDRESS(FONT_XZ4COLOR_ICON_START);
                  LoadCompressColorFont(&tXZ2IconFont, NULL, 36);
                }
               else if(menuPageIndex==HotXINGZHUN3||menuPageIndex==HotXINGZHUN6)
                 {
                   OSD_WRITE_FONT_ADDRESS(FONT_XZ4COLOR_ICON_START);
                   LoadCompressColorFont(&tXZ3IconFont, NULL, 36);
                 }
              
              
              
               #endif
1052   1            OSD_FONT_HI_ADDR_CLR_TO_0();
1053   1      }
1054          
1055          #define GuageLevel    4
1056          
1057          #define GuageFontStart  0x01
1058          #define GuageFont0_4  0x03
1059          #define GuageFont1_4  0x04
1060          #define GuageFont2_4       0x05
1061          #define GuageFont3_4  0x06
1062          #define GuageFont4_4       0x07
1063          #define GuageFontEnd    0x02
1064          
1065          void Osd_DrawGuage(BYTE xPos, BYTE yPos, BYTE length, BYTE value)
1066          {
1067   1      
1068   1        BYTE pLead;
1069   1        BYTE ucLoop;
1070   1      
1071   1        if (value>100)
1072   1          value=100;
1073   1      
1074   1          
1075   1        Osd_DrawCharDirect(xPos, yPos, GuageFontStart);
1076   1        Osd_DrawCharDirect(xPos+length-1, yPos, GuageFontEnd);
1077   1      
1078   1        length -= 2;
1079   1      
1080   1        // bar length should small than 42 ( ucLength < 43 )
1081   1        pLead = ( (WORD) value * length * GuageLevel ) / 100;   // resver 0.1 // fill bar ucLength 10 times
1082   1        if( value != 0 && pLead == 0 )
1083   1          pLead++;
1084   1      
1085   1        for(ucLoop=1; ucLoop<=(pLead/GuageLevel); ucLoop++)
1086   1        {
1087   2          Osd_DrawCharDirect(xPos+ucLoop, yPos, GuageFont4_4);
1088   2        }
1089   1      
1090   1        if(pLead < length*GuageLevel)
1091   1        {
1092   2          Osd_DrawCharDirect(xPos+ucLoop, yPos, GuageFont0_4+(pLead%GuageLevel));
1093   2        }
1094   1      
1095   1        for(ucLoop=(pLead/GuageLevel+2); ucLoop<=length; ucLoop++)
1096   1        {
1097   2            Osd_DrawCharDirect(xPos + ucLoop, yPos, GuageFont0_4);
1098   2          }
1099   1          
1100   1        
1101   1      }
C51 COMPILER V9.60.0.0   MSOSD                                                             12/25/2020 09:24:10 PAGE 19  

1102          void Osd_DrawRealStr(BYTE xPos, BYTE yPos, BYTE *str)
1103          {
1104   1      #if CHIP_ID>=CHIP_TSUMV
1105   1        WORD u16TempValue;
1106   1        BYTE u8DrawCode = (!(yPos & BIT7));
1107   1      
1108   1        yPos &= 0x7F;
1109   1      
1110   1        //u8Wnd<<=5;
1111   1        //u16TempValue=msRead2Byte((u8Wnd)+OSD2_10)+(WORD)u8YPos*msReadByte((u8Wnd)+OSD2_12)+u8XPos; // get real 
             -address
1112   1        u16TempValue=GET_TXT_CASTART(g_u8OsdWndNo,xPos,yPos); // get real address
1113   1        
1114   1      #define dispChar    xPos
1115   1      #define dispPtr     yPos
1116   1        dispPtr = 0;
1117   1              WRITE_CAFSRAM_ADDR();
1118   1        msWrite2Byte(PORT_ATTR_ADDR, u16TempValue); // display font attribute
1119   1              WRITE_ATTRIBUTE();
1120   1        while( *( str + dispPtr ) )      // display string font index
1121   1        {
1122   2          msWriteByte(PORT_ATTR_DATA, OsdFontColor);
1123   2          dispPtr++;
1124   2        }
1125   1        if( u8DrawCode )
1126   1        {
1127   2          dispPtr = 0;
1128   2                    WRITE_CAFSRAM_ADDR();
1129   2          msWrite2Byte(PORT_CODE_ADDR, u16TempValue); // dispaly font code
1130   2                    WRITE_CODE();
1131   2          while( dispChar = *( str + dispPtr ) )        // display string font index
1132   2          {
1133   3            msWriteByte(PORT_CODE_DATA, dispChar);
1134   3            dispPtr++;
1135   3          }
1136   2        }
1137   1      #undef dispChar
1138   1      #undef dispPtr
1139   1      #else
              #if 1 // 110819 wait for coding
                WORD tempValue;
                BYTE drawCode = TRUE;
                BYTE y;
                if( yPos & BIT7 )
                {
                  drawCode = FALSE;
                }
                yPos &= 0x3F; //~(BIT7|BIT6);
                y = yPos;
              #define dispChar    xPos
              #define dispPtr     yPos
                tempValue = ( WORD )yPos * OsdWindowWidth + xPos; // get real address
                dispPtr = 0;
                msWrite2Byte( OSD2_A8, tempValue );
                while( *( str + dispPtr ) )      // display string font index
                {
                  msWriteByte( OSD2_AA, OsdFontColor );
                  dispPtr++;
                }
                if( drawCode == TRUE )
                {
                  dispPtr = 0;
C51 COMPILER V9.60.0.0   MSOSD                                                             12/25/2020 09:24:10 PAGE 20  

                  msWrite2Byte( OSD2_A5, tempValue );
                  while( dispChar = *( str + dispPtr ) )        // display string font index
                  {
                    msWriteByte( OSD2_A7, dispChar );
                    dispPtr++;
                      #if DEBUG_OSD
                    ForceDelay1ms(20);
                      #endif      
                  }
                }
              #undef dispChar
              #undef dispPtr
              #endif
              #endif
1177   1      
1178   1      }
1179          
1180          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2652    ----
   CONSTANT SIZE    =    798    ----
   XDATA SIZE       =      6       7
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      64
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
