C51 COMPILER V9.60.0.0   DRVADC                                                            12/22/2020 19:50:39 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE DRVADC
OBJECT MODULE PLACED IN .\Obj\drvADC.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\KERNEL\SCALER\drvADC.c OPTIMIZE(9,SPEED) BROWSE INCDIR(..\KERNEL\SYST
                    -EM\INC;..\KERNEL\SCALER\INC;..\DRIVER\extDEVICE\INC;..\LIB\INC;..\PANEL\INC;..\UI\BOARD;..\UI\INC;..\UI\MODEL;..\DRIVER\
                    -INC;..\Customer) DEFINE(ModelName=TSUMXX9_DEMO) DEBUG OBJECTEXTEND PRINT(.\List\drvADC.lst) TABS(2) OBJECT(.\Obj\drvADC.
                    -obj)

line level    source

   1          ///////////////////////////////////////////////////////////////////////////////////////////////////
   2          ///
   3          /// file    drvADC.c
   4          /// @author MStar Semiconductor Inc.
   5          /// @brief  ADC Function
   6          ///////////////////////////////////////////////////////////////////////////////////////////////////
   7          #ifndef _DRVADC_C_
   8          #define _DRVADC_C_
   9          
  10          //-------------------------------------------------------------------------------------------------
  11          //  Include Files
  12          //-------------------------------------------------------------------------------------------------
  13          #include <math.h>
  14          #include <string.h>
  15          #include "board.h"
  16          #include "types.h"
  17          #include "ms_reg.h"
  18          #include "ms_rwreg.h"
  19          //#include "DebugMsg.h"
  20          #include "global.h"
  21          #include "drvADC.h"
  22          #include "Misc.h"
  23          #include "power.h"
  24          #if ENABLE_DEBUG
  25          #include "gpio_def.h"
  26          #endif
  27          
  28          #include "msEread.h"
  29          #include "AutoFunc.h"
  30          
  31          #if 1//ENABLE_VGA_INPUT
  32          
  33          //-------------------------------------------------------------------------------------------------
  34          //  Local Defines
  35          //-------------------------------------------------------------------------------------------------
  36          
  37          //#define ADC_DEBUG
  38          
  39          #ifdef ADC_DEBUG
                  #define ADC_DPUTSTR(str)    printMsg(str)
                  #define ADC_DPRINTF(str, x) printData(str, x)
              #else
  43              #define ADC_DPUTSTR(str)
  44              #define ADC_DPRINTF(str, x)
  45          #endif
  46          
  47          #define   AUTO_GAIN_RGB_TARGET_CODE         182           //0.5/0.7*255=182.1
  48          #define   AUTO_GAIN_TOLERANCE_CODE          0
  49          #define   AUTO_GAIN_RGB_MAXVAL              (AUTO_GAIN_RGB_TARGET_CODE+AUTO_GAIN_TOLERANCE_CODE )
  50          #define   AUTO_GAIN_RGB_MINVAL              (AUTO_GAIN_RGB_TARGET_CODE-AUTO_GAIN_TOLERANCE_CODE )
  51          #define   DADCMISMATCHLOOP                  5  // ADC mismatch calibration loop
  52          
C51 COMPILER V9.60.0.0   DRVADC                                                            12/22/2020 19:50:39 PAGE 2   

  53          #define drvADC_Write2BytesMask  msWrite2ByteMask
  54          #define drvADC_ReadByte         msReadByte
  55          
  56          void drvADC_Test_Funct(BYTE tb1, BYTE tb2);
  57          //-------------------------------------------------------------------------------------------------
  58          //  Local Structures
  59          //-------------------------------------------------------------------------------------------------
  60          
  61          typedef struct
  62          {
  63              BYTE *pTable;
  64              BYTE u8TabCols;
  65              BYTE u8TabRows;
  66              BYTE u8TabIdx;
  67          } TAB_Info;
  68          
  69          typedef struct
  70          {
  71              BYTE PLL_Ictrl; // ADC_ATOP_09_H [1:0]: PLL Ictrl
  72              BYTE PLL_Mult_Mod_216m; // ADC_ATOP_0A_L [5]: 216m_en, [4:3]: PLL mod, [2:0]: PLL mult
  73              BYTE LPF_Rch; // low pass filter setting in Rch
  74              BYTE LPF_Gch; // low pass filter setting in Gch
  75              BYTE LPF_Bch; // low pass filter setting in Bch
  76              WORD Blacklevel_Rch; // Rch black level
  77              WORD Blacklevel_Gch; // Gch black level
  78              WORD Blacklevel_Bch; // Bch black level
  79              WORD Offset_Rch; // Rch offset level
  80              WORD Offset_Gch; // Gch offset level
  81              WORD Offset_Bch; // Bch offset level
  82          #if ENABLE_XTAL_LESS
                  BYTE BWCoef; // ADC PLL Bandwidth Coefficient, ADC_DTOP_02_L[7:0]
                  BYTE DampCoef; // ADC PLL damping coefficient, ADC_DTOP_03_L[7:0]
              #endif // #if ENABLE_XTAL_LESS
  86          } msADCBackupSetting;
  87          
  88          typedef struct
  89          {
  90              BYTE DBuffer; // scaler double buffer setting
  91              BYTE ISEL; // Scaler input select
  92              WORD SPRHST; // Image horizontal sample start point
  93              WORD SPRHDC; // Image horizontal resolution
  94              WORD SPRVST; // Image vertical sample start point
  95              WORD SPRVDC; // Image vertical resolution
  96          } msScalerBackupSetting;
  97          
  98          typedef enum
  99          {
 100              E_Vcal_0_55V = 0,
 101              E_Vcal_1_05V = 1,
 102          } msADC_InternalVcal;
 103          
 104          typedef enum
 105          {
 106              E_PG_Htotal_256 = 0,
 107              E_PG_Htotal_512 = 1,
 108              E_PG_Htotal_1024 = 2,
 109              E_PG_Htotal_2048 = 3,
 110          } msADCScalerPG_HtotalSel;
 111          
 112          typedef struct
 113          {
 114              BYTE AVG_Rch;
C51 COMPILER V9.60.0.0   DRVADC                                                            12/22/2020 19:50:39 PAGE 3   

 115              BYTE AVG_Gch;
 116              BYTE AVG_Bch;
 117          } msADCAvgVal;
 118          
 119          typedef struct
 120          {
 121              WORD wOffsetVal_Rch0;
 122              WORD wOffsetVal_Rch1;
 123              WORD wPivot_Rch;
 124              WORD wOffsetVal_Gch0;
 125              WORD wOffsetVal_Gch1;
 126              WORD wPivot_Gch;
 127              WORD wOffsetVal_Bch0;
 128              WORD wOffsetVal_Bch1;
 129              WORD wPivot_Bch;
 130              WORD wGainVal_Rch0;
 131              WORD wGainVal_Rch1;
 132              WORD wGainVal_Gch0;
 133              WORD wGainVal_Gch1;
 134              WORD wGainVal_Bch0;
 135              WORD wGainVal_Bch1;
 136          } msADCMismatchCalVal;
 137          
 138          
 139          //-------------------------------------------------------------------------------------------------
 140          //  Global Variables
 141          //-------------------------------------------------------------------------------------------------
 142          
 143          msADCBackupSetting xdata gADCBackupSetting;
 144          msScalerBackupSetting xdata gScalerBackupSetting;
 145          msADCMismatchCalVal xdata gADCMismatchAvgVal;
 146          
 147          //-------------------------------------------------------------------------------------------------
 148          //  Local Variables
 149          //-------------------------------------------------------------------------------------------------
 150          
 151          
 152          
 153          //-------------------------------------------------------------------------------------------------
 154          //  Local Functions
 155          //-------------------------------------------------------------------------------------------------
 156          
 157          static void drvADC_LoadTable(TAB_Info* pTab_info);
 158          //static void drvADC_Write2BytesMask(WORD u16regadr, WORD u16val, WORD u16mask);
 159          //static BYTE drvADC_ReadByte(WORD u16regadr);
 160          //static BYTE drvADC_WaitAutoStatusReady(WORD regAddr, BYTE regFlag);
 161          static void drvADC_SetMux(ADC_MUX_TYPE ipmux_type);
 162          static BYTE drvADC_SearchFreqSetTableIndex(WORD u16OriginalPixClk);
 163          static void drvADC_BackupADCSetting(void);
 164          static void drvADC_RecoverADCSetting(void);
 165          static void drvADC_SetFreeRunClock(void);
 166          #if ((CHIP_ID == CHIP_TSUMD) || (CHIP_ID == CHIP_TSUMJ) || (CHIP_ID == CHIP_TSUM9)|| (CHIP_ID == CHIP_TSUM
             -F))
 167          static void drvADC_MismatchLinearityCal(void);
 168          #endif
 169          static void drvADC_MismatchOffsetCal(void);
 170          static void drvADC_MismatchGainCal(void);
 171          static Bool drvADC_AutoAdjustAdcGain(BYTE vsyncTime);
 172          static BYTE drvADC_CheckPGAGain(BYTE vsyncTime);
 173          static void drvADC_SetPGAGainCode(BYTE ucAdcPgaGain);  //Steven110329, Solve check PGA gain issue.
 174          
 175          #if DADCPLLPROTECTION
C51 COMPILER V9.60.0.0   DRVADC                                                            12/22/2020 19:50:39 PAGE 4   

 176          static void drvADC_IsEnableFreeRun(Bool bflag);
 177          static void drvADC_SetAutoProst(Bool bflag);
 178          #endif // #ifdef DADCPLLPROTECTION
 179          
 180          #ifdef _DGAIN_CAL_WITHOUT_INPUT_
              static void drvADC_EnableScalerPG(msADCScalerPG_HtotalSel ht_sel);
              static void _msADC_MaskExternalSync(Bool bflag);
              static void drvADC_SetInternalVcal(msADC_InternalVcal vcal);
              static Bool drvADC_AutoGainAdjustment(void);
              #endif // #ifdef (_DGAIN_CAL_WITHOUT_INPUT_)
 186          #ifdef _DGAIN_CAL_WITH_INPUT_
              static WORD drvADC_FindWhiteRegion(BYTE LineBuf, BYTE Step);
              static Bool drvADC_AutoGainAdjustment_WithInput(WORD wLineBufAddress, BYTE LineBuf, BYTE AvgCnt);
              #endif
 190          #if (defined(_DGAIN_CAL_WITHOUT_INPUT_) || defined(_DGAIN_CAL_WITH_INPUT_))
              static void drvADC_BackupScalerSetting(void);
              static void drvADC_RecoverScalerSetting(void);
              static Bool drvADC_IsReadLineBuffer(Bool bflag);
              static msADCAvgVal drvADC_GetRGBLineBufAverageData(WORD wLineBufAddress, BYTE LineBuf, BYTE AvgCnt);
              #endif // #if (defined(_DGAIN_CAL_WITHOUT_INPUT_) || defined(_DGAIN_CAL_WITH_INPUT_))
 196          
 197          
 198          #define OffsetValue     20 // ADC offset adjustment
 199          
 200          //-------------------------------------------------------------------------------------------------
 201          //  Global Functions
 202          //-------------------------------------------------------------------------------------------------
 203          extern Bool CheckSyncLoss(void);
 204          
 205          //**************************************************************************
 206          //  [Function Name]:
 207          //                  drvADC_init()
 208          //  [Description]
 209          //                  ADC init
 210          //  [Arguments]:
 211          //                  IsShareGrd: is used shared negative pin with R/G/B
 212          //  [Return]:
 213          //
 214          //**************************************************************************
 215          void drvADC_init(Bool IsShareGrd)
 216          {
 217   1          TAB_Info Tab_info;
 218   1          xdata BYTE no_use = 0;
 219   1      #if ((CHIP_ID == CHIP_TSUMC) || (CHIP_ID==CHIP_TSUMK) || (CHIP_ID == CHIP_TSUMD)|| (CHIP_ID==CHIP_TSUMJ) |
             -| (CHIP_ID == CHIP_TSUM9)|| (CHIP_ID == CHIP_TSUMF))
 220   1          BYTE u8ADCBandgapTrimVal = 0;
 221   1      #endif
 222   1      
 223   1          Tab_info.pTable = (void*)MST_ADCINIT_TBL;
 224   1          Tab_info.u8TabCols = REG_ADDR_SIZE+REG_MASK_SIZE+ADC_TABLE_INIT_NUMS*REG_DATA_SIZE;
 225   1          Tab_info.u8TabRows = sizeof(MST_ADCINIT_TBL)/Tab_info.u8TabCols;
 226   1          Tab_info.u8TabIdx = 0;
 227   1      
 228   1          //ADC_DPUTSTR("ADC Tbl:init\n");
 229   1          drvADC_LoadTable(&Tab_info);
 230   1      
 231   1          // Set share ground bit
 232   1          drvADC_Write2BytesMask( REG_ADC_ATOP_22_L, IsShareGrd ? BIT9 : 0, BIT9 );
 233   1      
 234   1      
 235   1      #if ((CHIP_ID == CHIP_TSUMC) || (CHIP_ID==CHIP_TSUMK) || (CHIP_ID == CHIP_TSUMD)|| (CHIP_ID==CHIP_TSUMJ) |
             -| (CHIP_ID == CHIP_TSUM9)|| (CHIP_ID == CHIP_TSUMF))
C51 COMPILER V9.60.0.0   DRVADC                                                            12/22/2020 19:50:39 PAGE 5   

 236   1      
 237   1      #ifndef FPGA
 238   1      
 239   1      #if ((CHIP_ID == CHIP_TSUMC) || (CHIP_ID==CHIP_TSUMK) || (CHIP_ID == CHIP_TSUMD) || (CHIP_ID == CHIP_TSUMJ
             -))
                  u8ADCBandgapTrimVal = msEread_GetADCBandgapTrimValFromEfuse();
              #elif (CHIP_ID == CHIP_TSUM9)||(CHIP_ID == CHIP_TSUMF)
 242   1          u8ADCBandgapTrimVal = msEread_GetDataFromEfuse(0x0001);
 243   1      #endif
 244   1      
 245   1          if(u8ADCBandgapTrimVal & BIT7)
 246   1          {
 247   2              drvADC_Write2BytesMask( REG_ADC_ATOP_34_L, ((u8ADCBandgapTrimVal & 0x1F)<<8)|BIT7, 0x1F80);
 248   2              ADC_DPRINTF("$$ ADC Bandgap Trim value = 0x%x\n", u8ADCBandgapTrimVal);
 249   2          }
 250   1        
 251   1      #endif
 252   1      
 253   1      #endif // #if ((CHIP_ID == CHIP_TSUMC) || (CHIP_ID==CHIP_TSUMK) || (CHIP_ID == CHIP_TSUMD)|| (CHIP_ID==CHI
             -P_TSUMJ) || (CHIP_ID == CHIP_TSUM9))
 254   1      
 255   1          drvADC_SetPGAGainCode(UserPrefAdcPgaGain);  //Steven110329, Solve check PGA gain issue.
 256   1      
 257   1          drvADC_SetHsyncRefLevel(ADC_HSYNC_LVL_DEF); // REFH=1.87V, REFL=0.88V // 120725 coding, moves here
 258   1          
 259   1          if(no_use)
 260   1          {
 261   2              drvADC_Test_Funct(0 ,0);
 262   2          }
 263   1      }
 264          
 265          //**************************************************************************
 266          //  [Function Name]:
 267          //                  drvADC_SetInputMux()
 268          //  [Description]
 269          //                  Setup analog input mux
 270          //  [Arguments]:
 271          //                  port_type: InputPortType
 272          //  [Return]:
 273          //
 274          //**************************************************************************
 275          void drvADC_SetInputMux(InputPortType port_type )
 276          {
 277   1          switch(port_type)
 278   1          {
 279   2              default:
 280   2              case Input_Analog1:
 281   2                  drvADC_SetMux(ADC_TABLE_MUX_RGB0_Sync);
 282   2      #if ((CHIP_ID != CHIP_TSUMC) && (CHIP_ID!=CHIP_TSUMK) && (CHIP_ID != CHIP_TSUMD)&& (CHIP_ID != CHIP_TSUMJ)
             - && (CHIP_ID != CHIP_TSUM9)&& (CHIP_ID != CHIP_TSUMF))
                          drvADC_SetMux(ADC_TABLE_MUX_RGB0_Data);
              #endif
 285   2                  break;
 286   2          }
 287   1      }
 288          
 289          //**************************************************************************
 290          //  [Function Name]:
 291          //                  drvADC_SetADCSource()
 292          //  [Description]
 293          //                  Setup ADC source is RGB or YPbPr or SOG
 294          //  [Arguments]:
C51 COMPILER V9.60.0.0   DRVADC                                                            12/22/2020 19:50:39 PAGE 6   

 295          //                  inputsrc_type: RGB / YPbPr / SOG
 296          //  [Return]:
 297          //
 298          //**************************************************************************
 299          void drvADC_SetADCSource(ADC_SOURCE_TYPE inputsrc_type)
 300          {
 301   1          TAB_Info Tab_info;
 302   1          Tab_info.pTable = (void*)MST_ADCSOURCE_TBL;
 303   1          Tab_info.u8TabCols = REG_ADDR_SIZE+REG_MASK_SIZE+ADC_TABLE_SOURCE_NUMS*REG_DATA_SIZE;
 304   1          Tab_info.u8TabRows = sizeof(MST_ADCSOURCE_TBL)/Tab_info.u8TabCols;
 305   1          Tab_info.u8TabIdx = inputsrc_type;
 306   1      
 307   1          //ADC_DPRINTF("ADC Tbl:set src %d \n", inputsrc_type);
 308   1          drvADC_LoadTable(&Tab_info);
 309   1      }
 310          
 311          //**************************************************************************
 312          //  [Function Name]:
 313          //                  drvADC_SetADCModeSetting()
 314          //  [Description]
 315          //                  Set ADC related settings by mode
 316          //  [Arguments]:
 317          //                  enADCInput: RGB / YPbPr
 318          //                  u16PixelClk: Input pixel clock(MHz)
 319          //  [Return]:
 320          //
 321          //**************************************************************************
 322          void drvADC_SetADCModeSetting(ADC_INPUTSOURCE_TYPE enADCInput, WORD u16PixelClk)
 323          {
 324   1          TAB_Info xdata Tab_info;
 325   1      
 326   1          if ( enADCInput & ADC_INPUTSOURCE_YPBPR ) // YPbPr
 327   1          {
 328   2      #if (CHIP_ID == CHIP_TSUM9||CHIP_ID == CHIP_TSUMF) && (ENABLE_XTAL_LESS)
                      Tab_info.pTable = (void*)MST_ADCSetMode_OSCYUV_TBL;
                      Tab_info.u8TabCols = REG_ADDR_SIZE+REG_MASK_SIZE+ADC_TABLE_SetMode_NUMS*REG_DATA_SIZE;
                      Tab_info.u8TabRows = sizeof(MST_ADCSetMode_OSCYUV_TBL)/Tab_info.u8TabCols;
              #else
 333   2              Tab_info.pTable = (void*)MST_ADCSetModeYUV_TBL;
 334   2              Tab_info.u8TabCols = REG_ADDR_SIZE+REG_MASK_SIZE+ADC_TABLE_SetMode_NUMS*REG_DATA_SIZE;
 335   2              Tab_info.u8TabRows = sizeof(MST_ADCSetModeYUV_TBL)/Tab_info.u8TabCols;
 336   2      #endif // #if (CHIP_ID == CHIP_TSUM9) && (ENABLE_XTAL_LESS)
 337   2          }
 338   1          else if( enADCInput & ADC_INPUTSOURCE_RGB )// RGB
 339   1          {
 340   2      #if (CHIP_ID == CHIP_TSUM9||CHIP_ID == CHIP_TSUMF) && (ENABLE_XTAL_LESS)
                      Tab_info.pTable = (void*)MST_ADCSetMode_OSCRGB_TBL;
                      Tab_info.u8TabCols = REG_ADDR_SIZE+REG_MASK_SIZE+ADC_TABLE_SetMode_NUMS*REG_DATA_SIZE;
                      Tab_info.u8TabRows = sizeof(MST_ADCSetMode_OSCRGB_TBL)/Tab_info.u8TabCols;
              #else
 345   2              Tab_info.pTable = (void*)MST_ADCSetModeRGB_TBL;
 346   2              Tab_info.u8TabCols = REG_ADDR_SIZE+REG_MASK_SIZE+ADC_TABLE_SetMode_NUMS*REG_DATA_SIZE;
 347   2              Tab_info.u8TabRows = sizeof(MST_ADCSetModeRGB_TBL)/Tab_info.u8TabCols;
 348   2      #endif // #if (CHIP_ID == CHIP_TSUM9||CHIP_ID == CHIP_TSUMF) && (ENABLE_XTAL_LESS)
 349   2          }
 350   1      
 351   1          Tab_info.u8TabIdx = drvADC_SearchFreqSetTableIndex(u16PixelClk);
 352   1      
 353   1          ADC_DPRINTF("ADC Tbl: TabIdx %d\n", Tab_info.u8TabIdx);
 354   1          drvADC_LoadTable(&Tab_info);
 355   1      #if (CHIP_ID == CHIP_TSUM9) && ENABLE_XTAL_LESS
                      gADCBackupSetting.BWCoef = drvADC_ReadByte(REG_ADC_DTOP_02_L);
C51 COMPILER V9.60.0.0   DRVADC                                                            12/22/2020 19:50:39 PAGE 7   

                      gADCBackupSetting.DampCoef = drvADC_ReadByte(REG_ADC_DTOP_03_L);
              #endif
 359   1      }
 360          
 361          //**************************************************************************
 362          //  [Function Name]:
 363          //                  drvADC_AdjustHTotal()
 364          //  [Description]
 365          //                  Adjust PLL divider
 366          //  [Arguments]:
 367          //                  htotal: Htotal -3
 368          //  [Return]:
 369          //
 370          //**************************************************************************
 371          #define StepDelay 1 //unit:ms
 372          #define Step 3    //unit:pixel
 373          void drvADC_AdjustHTotal(WORD u16HTotal)
 374          {
 375   1        BYTE ucStatus=SC0_READ_SYNC_STATUS();
 376   1          WORD u16Temp=msRead2Byte(REG_ADC_DTOP_01_L);
 377   1        BYTE u8Step=Step;
 378   1        
 379   1          if (ucStatus&(SOGD_B))
 380   1          {
 381   2          if ((abs(u16Temp-u16HTotal)/u8Step) == 0x00)
 382   2            u8Step=1;
 383   2      
 384   2            while(u16Temp != u16HTotal)
 385   2            {
 386   3      
 387   3            u16Temp=(u16Temp>u16HTotal)? (u16Temp=u16Temp-u8Step):(u16Temp=u16Temp+u8Step);
 388   3            #if ENABLE_MENULOAD
                        msML_WaitReady();
                        msML_WriteByte(ML_MODE_NORMAL ,REG_ADC_DTOP_01_L, (u16Temp-3));
                        msML_WriteByte(ML_MODE_NORMAL ,REG_ADC_DTOP_01_H, (u16Temp-3)>>8);
                        msML_Trigger(ML_TRIG_OUT_VDE_END);// Vde-end-OP
                    #else
 394   3                drvADC_Write2BytesMask(REG_ADC_DTOP_01_L, u16Temp-3, 0x1FFF);
 395   3            #endif
 396   3            
 397   3            ForceDelay1ms(StepDelay);
 398   3            if ((abs(u16Temp-u16HTotal))<u8Step && (u16Temp!=u16HTotal))
 399   3            {
 400   4                drvADC_Write2BytesMask(REG_ADC_DTOP_01_L, u16HTotal-3, 0x1FFF);
 401   4              break;
 402   4            }
 403   3          }
 404   2        }
 405   1        else
 406   1        {
 407   2          #if ENABLE_MENULOAD
                      msML_WaitReady();
                      msML_WriteByte(ML_MODE_NORMAL ,REG_ADC_DTOP_01_L, (u16HTotal-3));
                      msML_WriteByte(ML_MODE_NORMAL ,REG_ADC_DTOP_01_H, (u16HTotal-3)>>8);
                      msML_Trigger(ML_TRIG_OUT_VDE_END);// Vde-end-OP
                  #else
 413   2              drvADC_Write2BytesMask(REG_ADC_DTOP_01_L, u16HTotal-3, 0x1FFF);
 414   2          #endif
 415   2        }
 416   1      }
 417          
 418          
C51 COMPILER V9.60.0.0   DRVADC                                                            12/22/2020 19:50:39 PAGE 8   

 419          //**************************************************************************
 420          //  [Function Name]:
 421          //                  drvADC_SetPhaseCode()
 422          //  [Description]
 423          //                  Set ADC phase code
 424          //  [Arguments]:
 425          //                  code: code, 0~127
 426          //  [Return]:
 427          //
 428          //**************************************************************************
 429          void drvADC_SetPhaseCode(BYTE u8PhaseCode)
 430          {
 431   1      #if (CHIP_ID == CHIP_TSUMF)
                  #define BIT(_bit_)                  (1 << (_bit_))
                  #define BMASK(_bits_)               (BIT(((1)?_bits_)+1)-BIT(((0)?_bits_)))
                
                  BYTE u8ADCPllMod = (drvADC_ReadByte(REG_ADC_ATOP_0A_L) & BMASK(4:3)) >> 3; // ADC_ATOP_09_L[12:11]: re
             -g_adc_pll_mod
                  WORD u16Mask = BMASK((6+u8ADCPllMod):0) ;
                  WORD u16PhaseCode = u8PhaseCode * (1<<u8ADCPllMod);
              
                  // fix ADC phase not be set while AC/DC On/Off
                  drvADC_Write2BytesMask(REG_ADC_ATOP_15_L, (WORD)u16PhaseCode-(1<<u8ADCPllMod), u16Mask);
                  drvADC_Write2BytesMask(REG_ADC_ATOP_15_L, (WORD)u16PhaseCode, u16Mask);
              #else
 443   1          // fix ADC phase not be set while AC/DC On/Off
 444   1          drvADC_Write2BytesMask(REG_ADC_ATOP_0F_L, (WORD)u8PhaseCode-1, 0x03FF);
 445   1          drvADC_Write2BytesMask(REG_ADC_ATOP_0F_L, (WORD)u8PhaseCode, 0x03FF);
 446   1      #endif // #if (CHIP_ID == CHIP_TSUMF)
 447   1      }
 448          
 449          //**************************************************************************
 450          //  [Function Name]:
 451          //                  drvADC_SetRGBGainCode()
 452          //  [Description]
 453          //                  Set ADC R/G/B gain code
 454          //  [Arguments]:
 455          //                  rcode/gcode/bcode: R/G/B gain value, 0~2047
 456          //  [Return]:
 457          //
 458          //**************************************************************************
 459          void drvADC_SetRGBGainCode(WORD u16RCode, WORD u16GCode, WORD u16BCode)
 460          {
 461   1          drvADC_Write2BytesMask(REG_ADC_DTOP_45_L, u16RCode, 0x0FFF);
 462   1          drvADC_Write2BytesMask(REG_ADC_DTOP_48_L, u16GCode, 0x0FFF);
 463   1          drvADC_Write2BytesMask(REG_ADC_DTOP_51_L, u16BCode, 0x0FFF);
 464   1      }
 465          void drvADC_SetRedGainCode(WORD u16RCode)
 466          {
 467   1          drvADC_Write2BytesMask(REG_ADC_DTOP_45_L, u16RCode, 0x0FFF);
 468   1      }
 469          void drvADC_SetGreenGainCode(WORD u16GCode)
 470          {
 471   1          drvADC_Write2BytesMask(REG_ADC_DTOP_48_L, u16GCode, 0x0FFF);
 472   1      }
 473          void drvADC_SetBlueGainCode(WORD u16BCode)
 474          {
 475   1          drvADC_Write2BytesMask(REG_ADC_DTOP_51_L, u16BCode, 0x0FFF);
 476   1      }
 477          //**************************************************************************
 478          //  [Function Name]:
 479          //                  drvADC_SetRGBOffsetCode()
C51 COMPILER V9.60.0.0   DRVADC                                                            12/22/2020 19:50:39 PAGE 9   

 480          //  [Description]
 481          //                  Set ADC R/G/B offset code
 482          //  [Arguments]:
 483          //                  rcode/gcode/bcode: R/G/B offset value, กำ0~1023(S10)
 484          //  [Return]:
 485          //
 486          //**************************************************************************
 487          #if 1//CHIP_ID==CHIP_TSUML
 488          void drvADC_SetRGBOffsetCode(WORD u16RCode, WORD u16GCode, WORD u16BCode)
 489          {
 490   1          drvADC_Write2BytesMask(REG_ADC_DTOP_46_L, u16RCode, 0x07FF);
 491   1          drvADC_Write2BytesMask(REG_ADC_DTOP_49_L, u16GCode, 0x07FF);
 492   1          drvADC_Write2BytesMask(REG_ADC_DTOP_52_L, u16BCode, 0x07FF);
 493   1      }
 494          #endif
 495          
 496          #if 1
 497          void drvADC_SetRedOffsetCode(WORD u16RCode)
 498          {
 499   1          drvADC_Write2BytesMask(REG_ADC_DTOP_46_L, u16RCode, 0x07FF);
 500   1      }
 501          void drvADC_SetGreenOffsetCode(WORD u16GCode)
 502          {
 503   1          drvADC_Write2BytesMask(REG_ADC_DTOP_49_L, u16GCode, 0x07FF);
 504   1      }
 505          void drvADC_SetBlueOffsetCode(WORD u16BCode)
 506          {
 507   1          drvADC_Write2BytesMask(REG_ADC_DTOP_52_L, u16BCode, 0x07FF);
 508   1      }
 509          #endif
 510          //**************************************************************************
 511          //  [Function Name]:
 512          //                  drvADC_ADCOffsetGainMismatchCal()
 513          //  [Description]
 514          //                  Do ADC self mismatch calibration
 515          //  [Arguments]:
 516          //
 517          //  [Return]:
 518          //
 519          //**************************************************************************
 520          void drvADC_ADCOffsetGainMismatchCal(void)
 521          {
 522   1          BYTE loop;
 523   1          WORD wRch0diff, wRch1diff, wGch0diff, wGch1diff, wBch0diff, wBch1diff;
 524   1      
 525   1          memset(&gADCMismatchAvgVal, 0, sizeof(gADCMismatchAvgVal));
 526   1      
 527   1          drvADC_Write2BytesMask(REG_ADC_ATOP_51_L, 0x0003, 0x0003); // [1:0]: no ADCA interleve H/V dither
 528   1          drvADC_Write2BytesMask(REG_ADC_ATOP_22_L, 0x0800, 0x0C00); // [11:10]: CLAMP_RGB_OV[1:0] = 2'b10 disab
             -le clamp
 529   1      
 530   1      #if ((CHIP_ID == CHIP_TSUMD) || (CHIP_ID == CHIP_TSUMJ) || (CHIP_ID == CHIP_TSUM9)||(CHIP_ID == CHIP_TSUMF
             -))
 531   1      #if (CHIP_ID == CHIP_TSUM9)
 532   1          drvADC_SetPGAGainCode(0x00);  // for ADC linearity calibration, PGA gain must be set to 0
 533   1      #elif (CHIP_ID == CHIP_TSUMF)
                  drvADC_SetPGAGainCode(0x2A);  // for ADC linearity calibration, PGA gain must be set to 0
              #endif // #if (CHIP_ID == CHIP_TSUM9)
 536   1          // Do mismatch linearity calibration
 537   1          drvADC_MismatchLinearityCal();
 538   1          drvADC_SetPGAGainCode(UserPrefAdcPgaGain);  //for ADC linearity calibration
 539   1      #endif // #if ((CHIP_ID == CHIP_TSUMD) || (CHIP_ID == CHIP_TSUMJ) || (CHIP_ID == CHIP_TSUM9)|| (CHIP_ID ==
C51 COMPILER V9.60.0.0   DRVADC                                                            12/22/2020 19:50:39 PAGE 10  

             - CHIP_TSUMF))
 540   1      
 541   1          for(loop=0; loop< DADCMISMATCHLOOP ; loop++)
 542   1          {
 543   2              drvADC_Write2BytesMask(REG_ADC_ATOP_55_L, 0x0000, 0x003F); // [5:0]:disable mismatch offsset and g
             -ain update enable
 544   2      
 545   2              // 1. backup ADC related settings
 546   2              drvADC_BackupADCSetting();
 547   2              // 2. Set free run clock at 720p
 548   2              drvADC_SetFreeRunClock();
 549   2              // 3. Do mismatch offset calibration
 550   2              drvADC_MismatchOffsetCal();
 551   2              // 4. Do mismatch gain calibration
 552   2              drvADC_MismatchGainCal();
 553   2              // 5. recover ADC related settings & turn off free run clock
 554   2              drvADC_RecoverADCSetting();
 555   2      
 556   2              Delay1ms(10);
 557   2          }
 558   1        
 559   1          // Disable ADC dither to fix horizontal/Vertical line noise in some specific panels 
 560   1          //drvADC_Write2BytesMask(REG_ADC_ATOP_51_L, 0x0003, 0x0003); // [1:0]: ADCA interleve H/V dither in th
             -e normal display
 561   1          drvADC_Write2BytesMask(REG_ADC_ATOP_22_L, 0x0000, 0x0C00); // [11:10]: CLAMP_RGB_OV[1:0] = 2'b00 enabl
             -e clamp
 562   1      
 563   1          gADCMismatchAvgVal.wOffsetVal_Rch0 /= DADCMISMATCHLOOP;
 564   1          gADCMismatchAvgVal.wOffsetVal_Rch1 /= DADCMISMATCHLOOP;
 565   1          gADCMismatchAvgVal.wPivot_Rch /= DADCMISMATCHLOOP;
 566   1          gADCMismatchAvgVal.wOffsetVal_Gch0 /= DADCMISMATCHLOOP;
 567   1          gADCMismatchAvgVal.wOffsetVal_Gch1 /= DADCMISMATCHLOOP;
 568   1          gADCMismatchAvgVal.wPivot_Gch /= DADCMISMATCHLOOP;
 569   1          gADCMismatchAvgVal.wOffsetVal_Bch0 /= DADCMISMATCHLOOP;
 570   1          gADCMismatchAvgVal.wOffsetVal_Bch1 /= DADCMISMATCHLOOP;
 571   1          gADCMismatchAvgVal.wPivot_Bch /= DADCMISMATCHLOOP;
 572   1          wRch0diff = gADCMismatchAvgVal.wOffsetVal_Rch0 >= gADCMismatchAvgVal.wOffsetVal_Rch1 ? (gADCMismatchAv
             -gVal.wOffsetVal_Rch1 - gADCMismatchAvgVal.wOffsetVal_Rch0) : 0;
 573   1          wRch1diff = gADCMismatchAvgVal.wOffsetVal_Rch1 >= gADCMismatchAvgVal.wOffsetVal_Rch0 ? (gADCMismatchAv
             -gVal.wOffsetVal_Rch0 - gADCMismatchAvgVal.wOffsetVal_Rch1) : 0;
 574   1          wGch0diff = gADCMismatchAvgVal.wOffsetVal_Gch0 >= gADCMismatchAvgVal.wOffsetVal_Gch1 ? (gADCMismatchAv
             -gVal.wOffsetVal_Gch1 - gADCMismatchAvgVal.wOffsetVal_Gch0) : 0;
 575   1          wGch1diff = gADCMismatchAvgVal.wOffsetVal_Gch1 >= gADCMismatchAvgVal.wOffsetVal_Gch0 ? (gADCMismatchAv
             -gVal.wOffsetVal_Gch0 - gADCMismatchAvgVal.wOffsetVal_Gch1) : 0;
 576   1          wBch0diff = gADCMismatchAvgVal.wOffsetVal_Bch0 >= gADCMismatchAvgVal.wOffsetVal_Bch1 ? (gADCMismatchAv
             -gVal.wOffsetVal_Bch1 - gADCMismatchAvgVal.wOffsetVal_Bch0) : 0;
 577   1          wBch1diff = gADCMismatchAvgVal.wOffsetVal_Bch1 >= gADCMismatchAvgVal.wOffsetVal_Bch0 ? (gADCMismatchAv
             -gVal.wOffsetVal_Bch0 - gADCMismatchAvgVal.wOffsetVal_Bch1) : 0;
 578   1      
 579   1          gADCMismatchAvgVal.wGainVal_Rch0 /= DADCMISMATCHLOOP;
 580   1          gADCMismatchAvgVal.wGainVal_Rch1 /= DADCMISMATCHLOOP;
 581   1          gADCMismatchAvgVal.wGainVal_Gch0 /= DADCMISMATCHLOOP;
 582   1          gADCMismatchAvgVal.wGainVal_Gch1 /= DADCMISMATCHLOOP;
 583   1          gADCMismatchAvgVal.wGainVal_Bch0 /= DADCMISMATCHLOOP;
 584   1          gADCMismatchAvgVal.wGainVal_Bch1 /= DADCMISMATCHLOOP;
 585   1      
 586   1          // Restrict mismatch gain couldn't less than 0.94. otherwise it will make iclamp engine unstable
 587   1          // The maxi code is 1023, the middle point is 512 and iclamp code is 32
 588   1          // Input signal will be (1)-512 (2) x mismatch gain (3) +512, 
 589   1          // if input signal less than iclamp code, iclamp engine will be charge and discharge iteratively then 
             -makes engine crash
 590   1          // so 32/512 = 0.0625, mismatch gain must be large than (1-0.0625), that is 0.94 = 0x3C2
C51 COMPILER V9.60.0.0   DRVADC                                                            12/22/2020 19:50:39 PAGE 11  

 591   1          gADCMismatchAvgVal.wGainVal_Rch0 = (gADCMismatchAvgVal.wGainVal_Rch0 > 0x3C2) ? gADCMismatchAvgVal.wGa
             -inVal_Rch0 : 0x3C2;
 592   1          gADCMismatchAvgVal.wGainVal_Rch1 = (gADCMismatchAvgVal.wGainVal_Rch1 > 0x3C2) ? gADCMismatchAvgVal.wGa
             -inVal_Rch1 : 0x3C2;
 593   1          gADCMismatchAvgVal.wGainVal_Gch0 = (gADCMismatchAvgVal.wGainVal_Gch0 > 0x3C2) ? gADCMismatchAvgVal.wGa
             -inVal_Gch0 : 0x3C2;
 594   1          gADCMismatchAvgVal.wGainVal_Gch1 = (gADCMismatchAvgVal.wGainVal_Gch1 > 0x3C2) ? gADCMismatchAvgVal.wGa
             -inVal_Gch1 : 0x3C2;
 595   1          gADCMismatchAvgVal.wGainVal_Bch0 = (gADCMismatchAvgVal.wGainVal_Bch0 > 0x3C2) ? gADCMismatchAvgVal.wGa
             -inVal_Bch0 : 0x3C2;
 596   1          gADCMismatchAvgVal.wGainVal_Bch1 = (gADCMismatchAvgVal.wGainVal_Bch1 > 0x3C2) ? gADCMismatchAvgVal.wGa
             -inVal_Bch1 : 0x3C2;
 597   1          
 598   1          // Set mismatch offset componsate code
 599   1          drvADC_Write2BytesMask(REG_ADC_ATOP_56_L, wRch0diff, 0x07FF); // Set ADC channel 0 offset compensated 
             -code
 600   1          drvADC_Write2BytesMask(REG_ADC_ATOP_57_L, wRch1diff, 0x07FF); // Set ADC channel 1 offset compensated 
             -code
 601   1          drvADC_Write2BytesMask(REG_ADC_ATOP_75_L, gADCMismatchAvgVal.wPivot_Rch, 0x03FF); // Set ADCR pivot-po
             -int value, choose minimum one
 602   1          drvADC_Write2BytesMask(REG_ADC_ATOP_5A_L, wGch0diff, 0x07FF); // Set ADC channel 0 offset compensated 
             -code
 603   1          drvADC_Write2BytesMask(REG_ADC_ATOP_5B_L, wGch1diff, 0x07FF); // Set ADC channel 1 offset compensated 
             -code
 604   1          drvADC_Write2BytesMask(REG_ADC_ATOP_76_L, gADCMismatchAvgVal.wPivot_Gch, 0x03FF); // Set ADCG pivot-po
             -int value, choose minimum one
 605   1          drvADC_Write2BytesMask(REG_ADC_ATOP_5E_L, wBch0diff, 0x07FF); // Set ADC channel 0 offset compensated 
             -code
 606   1          drvADC_Write2BytesMask(REG_ADC_ATOP_5F_L, wBch1diff, 0x07FF); // Set ADC channel 1 offset compensated 
             -code
 607   1          drvADC_Write2BytesMask(REG_ADC_ATOP_77_L, gADCMismatchAvgVal.wPivot_Bch, 0x03FF); // Set ADCB pivot-po
             -int value, choose minimum one
 608   1          // Set mismatch gain componsate code
 609   1          drvADC_Write2BytesMask(REG_ADC_ATOP_58_L, gADCMismatchAvgVal.wGainVal_Rch0, 0x07FF); // Set ADC channe
             -l 0 gain compensated code
 610   1          drvADC_Write2BytesMask(REG_ADC_ATOP_59_L, gADCMismatchAvgVal.wGainVal_Rch1, 0x07FF); // Set ADC channe
             -l 1 gain compensated code
 611   1          drvADC_Write2BytesMask(REG_ADC_ATOP_5C_L, gADCMismatchAvgVal.wGainVal_Gch0, 0x07FF); // Set ADC channe
             -l 0 gain compensated code
 612   1          drvADC_Write2BytesMask(REG_ADC_ATOP_5D_L, gADCMismatchAvgVal.wGainVal_Gch1, 0x07FF); // Set ADC channe
             -l 1 gain compensated code
 613   1          drvADC_Write2BytesMask(REG_ADC_ATOP_60_L, gADCMismatchAvgVal.wGainVal_Bch0, 0x07FF); // Set ADC channe
             -l 0 gain compensated code
 614   1          drvADC_Write2BytesMask(REG_ADC_ATOP_61_L, gADCMismatchAvgVal.wGainVal_Bch1, 0x07FF); // Set ADC channe
             -l 1 gain compensated code
 615   1      
 616   1      #if 1
 617   1          ADC_DPUTSTR("\nAverage result:\n");
 618   1          ADC_DPRINTF("R Ch0 offset code= 0x%x", wRch0diff);
 619   1          ADC_DPRINTF("R Ch1 offset code= 0x%x", wRch1diff);
 620   1          ADC_DPRINTF("R Pivot-point= 0x%x", gADCMismatchAvgVal.wPivot_Rch);
 621   1          ADC_DPRINTF("G Ch0 offset code= 0x%x", wGch0diff);
 622   1          ADC_DPRINTF("G Ch1 offset code= 0x%x", wGch1diff);
 623   1          ADC_DPRINTF("G Pivot-point= 0x%x", gADCMismatchAvgVal.wPivot_Gch);
 624   1          ADC_DPRINTF("B Ch0 offset code= 0x%x", wBch0diff);
 625   1          ADC_DPRINTF("B Ch1 offset code= 0x%x", wBch1diff);
 626   1          ADC_DPRINTF("B Pivot-point= 0x%x \n", gADCMismatchAvgVal.wPivot_Bch);
 627   1      
 628   1          ADC_DPRINTF("R Ch0 gain code= 0x%x", gADCMismatchAvgVal.wGainVal_Rch0);
 629   1          ADC_DPRINTF("R Ch1 gain code= 0x%x", gADCMismatchAvgVal.wGainVal_Rch1);
 630   1          ADC_DPRINTF("G Ch0 gain code= 0x%x", gADCMismatchAvgVal.wGainVal_Gch0);
 631   1          ADC_DPRINTF("G Ch1 gain code= 0x%x", gADCMismatchAvgVal.wGainVal_Gch1);
C51 COMPILER V9.60.0.0   DRVADC                                                            12/22/2020 19:50:39 PAGE 12  

 632   1          ADC_DPRINTF("B Ch0 gain code= 0x%x", gADCMismatchAvgVal.wGainVal_Bch0);
 633   1          ADC_DPRINTF("B Ch1 gain code= 0x%x", gADCMismatchAvgVal.wGainVal_Bch1);
 634   1      #endif
 635   1      }
 636          
 637          #if 0 // wait for re-manege
              //**************************************************************************
              //  [Function Name]:
              //                  drvADC_AutoPhaseAdjustment()
              //  [Description]
              //                  Do ADC good phase adjustment
              //  [Arguments]:
              //                  vsyncTime: frame rate of the current input
              //  [Return]:
              //                  TRUE: done, FALSE: fail
              //**************************************************************************
              Bool drvADC_AutoPhaseAdjustment(BYTE u8VSyncTime)
              {
                  BYTE u8AdjPhase, i;
              
                  ADC_DPUTSTR("drvADC_AutoPhaseAdjustment\n");
              #if (DADCWORSTPHASE)
              {
                  BYTE worsePhase, worsePhase2;
                  DWORD mincksum, cksum;
              
                  mincksum=0xFFFFFFFFul;
                  for (u8AdjPhase=0; u8AdjPhase<0x80; u8AdjPhase+=7)
                  {
                      drvADC_SetPhaseCode(u8AdjPhase);
                      Delay1ms(u8VSyncTime);
                      drvADC_WaitAutoStatusReady(SC0_8B, BIT1);
                      cksum=msRead2Byte(SC0_8E);
                      cksum=(cksum<<16)|msRead2Byte(SC0_8C);
                      if (cksum<mincksum)
                      {
                          mincksum=cksum;
                          worsePhase=u8AdjPhase;
                      }
                      if (CheckSyncLoss())//||CheckPowerKeyStatus())
                          return FALSE;
                  }
                  //  printData("coast phase %d", bestPhase);
                  // 2nd Search
                  if (worsePhase<7)
                      worsePhase=(worsePhase+127)%0x80; // 128-7
                  else
                      worsePhase-=7;
                  mincksum=0xFFFFFFFFul;
                  for (u8AdjPhase=worsePhase; u8AdjPhase<worsePhase+10; u8AdjPhase++)
                  {
                      i=u8AdjPhase%0x80;
                      drvADC_SetPhaseCode(i);
                      Delay1ms(u8VSyncTime);
                      drvADC_WaitAutoStatusReady(SC0_8B, BIT1);
                      cksum=msRead2Byte(SC0_8E);
                      cksum=(cksum<<16)|msRead2Byte(SC0_8C);
                      if (cksum<mincksum)
                      {
                          mincksum=cksum;
                          worsePhase2=i;
                      }
C51 COMPILER V9.60.0.0   DRVADC                                                            12/22/2020 19:50:39 PAGE 13  

                      if (CheckSyncLoss())//||CheckPowerKeyStatus())
                          return FALSE;
                  }
                  u8AdjPhase=(worsePhase2+63)%0x80;
                  #define FINAL_PHASE u8AdjPhase
              }
              #else
              {
                  BYTE bestPhase, bestPhase2;
                  DWORD maxcksum, cksum;
              
                  maxcksum=0;
                  for (u8AdjPhase=0; u8AdjPhase<0x80; u8AdjPhase+=7)
                  {
                      drvADC_SetPhaseCode(u8AdjPhase);
                      ForceDelay1ms(u8VSyncTime);
                      drvADC_WaitAutoStatusReady(SC0_8B, BIT1);
                      cksum=msRead2Byte(SC0_8E);
                      cksum=(cksum<<16)|msRead2Byte(SC0_8C);
                      if (cksum>maxcksum)
                      {
                          maxcksum=cksum;
                          bestPhase=u8AdjPhase;
                      }
                      if (CheckSyncLoss())//||CheckPowerKeyStatus())
                          return FALSE;
                  }
                  //  printData("coast phase %d", bestPhase);
                  // 2nd Search
                  if (bestPhase<7)
                      bestPhase=(bestPhase+121)%0x80; // 128-7
                  else
                      bestPhase-=7;
                  maxcksum=0;
                  for (u8AdjPhase=bestPhase; u8AdjPhase<bestPhase+10; u8AdjPhase++)
                  {
                      i=u8AdjPhase%0x80;
                      drvADC_SetPhaseCode(i);
                      ForceDelay1ms(u8VSyncTime);
                      drvADC_WaitAutoStatusReady(SC0_8B, BIT1);
                      cksum=msRead2Byte(SC0_8E);
                      cksum=(cksum<<16)|msRead2Byte(SC0_8C);
                      if (cksum>maxcksum)
                      {
                          maxcksum=cksum;
                          bestPhase2=i;
                      }
                      if (CheckSyncLoss())//||CheckPowerKeyStatus())
                          return FALSE;
                  }
                  u8AdjPhase=bestPhase2;
                  #define FINAL_PHASE u8AdjPhase
              }
              #endif // DADCWORSTPHASE
              
                  drvADC_SetPhaseCode(FINAL_PHASE);
                  ADC_DPRINTF("final phase %d", FINAL_PHASE);
                  //UPPHASE_SET_BY_REAL_VALUE(FINAL_PHASE);
                  #undef FINAL_PHASE
                  return TRUE;
              }
              #endif
C51 COMPILER V9.60.0.0   DRVADC                                                            12/22/2020 19:50:39 PAGE 14  

 756          //**************************************************************************
 757          //  [Function Name]:
 758          //                  drvADC_AutoAdcColor()
 759          //  [Description]
 760          //                  Do the ADC auto color adjustment
 761          //  [Arguments]:
 762          //                  vsyncTime: frame rate of the current input
 763          //  [Return]:
 764          //                  TRUE: done, FALSE: fail
 765          //**************************************************************************
 766          Bool drvADC_AutoAdcColor(BYTE u8VSyncTime)
 767          {
 768   1          BYTE xdata result;
 769   1          BYTE xdata u8AdcPgaGain;
 770   1      
 771   1          if (!(CURRENT_INPUT_IS_VGA()))//(SrcInputType!=Input_Analog1)
 772   1              return FALSE;
 773   1      
 774   1          ADC_DPUTSTR("drvADC_AutoAdcColor\n");
 775   1          //drvADC_SetPGAGainCode(0);
 776   1          //if(USER_PREF_INPUT_COLOR_FORMAT==INPUT_COLOR_YPBPR) //YPbPr or YUV_H+V
 777   1          //    drvADC_SetRGBOffsetCode(0x200, 0x40, 0x200);
 778   1          //else
 779   1              drvADC_SetRGBOffsetCode(0, 0, 0);
 780   1          drvADC_SetRGBGainCode(0x421, 0x421, 0x421);
 781   1      
 782   1          msWriteByte(SC0_78, 0x01); // enable auto Gain
 783   1          u8AdcPgaGain=drvADC_CheckPGAGain(u8VSyncTime);
 784   1      
 785   1          result = drvADC_AutoAdjustAdcGain(u8VSyncTime);
 786   1      
 787   1          if(result)
 788   1          {
 789   2              ADC_DPUTSTR("$$ Auto color pass! \n");
 790   2              UserPrefAdcPgaGain = u8AdcPgaGain;
 791   2              UserPrefAdcRedOffset = 0x800-OffsetValue;
 792   2              UserPrefAdcGreenOffset = 0x800-OffsetValue;
 793   2              UserPrefAdcBlueOffset = 0x800-OffsetValue;
 794   2              drvADC_SetRGBOffsetCode(UserPrefAdcRedOffset, UserPrefAdcGreenOffset, UserPrefAdcBlueOffset);     
             -   
 795   2          }
 796   1          else
 797   1          {
 798   2              drvADC_SetPGAGainCode( UserPrefAdcPgaGain );
 799   2              drvADC_SetRGBGainCode(UserPrefAdcRedGain, UserPrefAdcGreenGain, UserPrefAdcBlueGain);
 800   2              drvADC_SetRGBOffsetCode(UserPrefAdcRedOffset, UserPrefAdcGreenOffset, UserPrefAdcBlueOffset);
 801   2          }
 802   1      
 803   1      /*    
 804   1          if (!result)
 805   1          {
 806   1              ADC_DPUTSTR( "Auto color failed !!");
 807   1              drvADC_SetPGAGainCode(UserPrefAdcPgaGain);
 808   1              drvADC_SetRGBGainCode(UserPrefAdcRedGain, UserPrefAdcGreenGain, UserPrefAdcBlueGain);
 809   1          }
 810   1          else
 811   1          {
 812   1              UserPrefAdcPgaGain=u8AdcPgaGain;
 813   1          }
 814   1      */    
 815   1          
 816   1          msWriteByte(SC0_78, 0); // disable auto Gain
C51 COMPILER V9.60.0.0   DRVADC                                                            12/22/2020 19:50:39 PAGE 15  

 817   1      
 818   1          #if 1
 819   1          ADC_DPRINTF("adc gain red 0x%x", UserPrefAdcRedGain);
 820   1          ADC_DPRINTF("adc gain green 0x%x", UserPrefAdcGreenGain);
 821   1          ADC_DPRINTF("adc gain blue 0x%x", UserPrefAdcBlueGain);
 822   1          ADC_DPRINTF("adc gain PGA 0x%x", UserPrefAdcPgaGain);
 823   1          #endif
 824   1      
 825   1          return result;
 826   1      }
 827          
 828          //**************************************************************************
 829          //  [Function Name]:
 830          //                  drvADC_SetupHsyncPolarity()
 831          //  [Description]
 832          //                  Setup Hsync polarity
 833          //  [Arguments]:
 834          //                  bActiveHigh: TRUE -> active high, FALSE: active low
 835          //  [Return]:
 836          //
 837          //**************************************************************************
 838          void drvADC_SetupHsyncPolarity(Bool IsActiveHigh)
 839          {
 840   1          drvADC_Write2BytesMask(REG_ADC_DTOP_07_L,(IsActiveHigh?BIT7:0),(BIT7));
 841   1      }
 842          //**************************************************************************
 843          //  [Function Name]:
 844          //                  drvADC_AdjustCalDuring()
 845          //  [Description]
 846          //                  Adjust ADC calibration during for specific reduced blanking timings
 847          //  [Arguments]:
 848          //                  u8CalDur: pixel
 849          //  [Return]:
 850          //
 851          //**************************************************************************
 852          void drvADC_AdjustCalDuring(BYTE u8CalDur)
 853          {
 854   1          drvADC_Write2BytesMask(REG_ADC_DTOP_18_L, u8CalDur, 0x00FF);
 855   1      }
 856          
 857          //**************************************************************************
 858          //  [Function Name]:
 859          //                  drvADC_SetupADCLPF()
 860          //  [Description]
 861          //                  Setup ADC LPF
 862          //  [Arguments]:
 863          //                  val: 3dB bandwidth
 864          //                  - VGA(RGB(YUV)_H+V): Pixel Clock/1.2 < 3dB BW
 865          //                  - SOG(Sync on G or Y): Pixel Clock/2 < 3dB BW
 866          //  [Return]:
 867          //
 868          //**************************************************************************
 869          #if 0
              void drvADC_SetupADCLPF(ADCLPFBW_LIST val)
              {
                  // Bch: ATOP_23[3:0]: +, ATOP_23[7:4]: -
                  // Gch: ATOP_23[15:12]: +, ATOP_23[11:8]: -
                  // Rch: ATOP_24[3:0]: +, ATOP_24[7:4]: -
                  drvADC_Write2BytesMask(REG_ADC_ATOP_23_L, val<<12|val<<8|val<<4|val, 0xFFFF);
                  drvADC_Write2BytesMask(REG_ADC_ATOP_24_L, val<<4|val, 0x00FF);
              }
              #endif
C51 COMPILER V9.60.0.0   DRVADC                                                            12/22/2020 19:50:39 PAGE 16  

 879          #if DADCPLLPROTECTION
 880          //**************************************************************************
 881          //  [Function Name]:
 882          //                  drvADC_SetModewithPLLProtection()
 883          //  [Description]
 884          //                  Mode changed with applying ADC PLL protection mechnism
 885          //  [Arguments]:
 886          //                  enADCInput: RGB / YPbPr
 887          //                  u16PixelClk: Input pixel clock(MHz)
 888          //                  htotal: Htotal -3
 889          //  [Return]:
 890          //                  TRUE: done, FALSE: fail
 891          //**************************************************************************
 892          Bool drvADC_SetModewithPLLProtection(ADC_INPUTSOURCE_TYPE enADCInput, WORD u16PixelClk, WORD u16HTotal)
 893          {
 894   1          Bool result;
 895   1          BYTE regval1, regval2;
 896   1      
 897   1          //ADC_DPUTSTR("drvADC_SetModewithPLLProtection\n");
 898   1          drvADC_IsEnableFreeRun(TRUE);
 899   1          drvADC_SetAutoProst(TRUE);
 900   1          drvADC_SetADCModeSetting(enADCInput, u16PixelClk);
 901   1          drvADC_SetAutoProst(FALSE);
 902   1          Delay1ms(1);
 903   1          drvADC_AdjustHTotal(u16HTotal);
 904   1          drvADC_IsEnableFreeRun(FALSE);
 905   1          Delay1ms(10); // PLL lock status would depend on input frequency, low frequency would take longer time
             - to lock
 906   1          regval1 = drvADC_ReadByte(REG_ADC_ATOP_0D_H);
 907   1          regval2 = drvADC_ReadByte(REG_ADC_DTOP_05_L);
 908   1          if(!(regval1 & 0x02) && (regval2 & 0x80))
 909   1          {
 910   2              result = TRUE;
 911   2          }
 912   1          else // 1st trial failed, wait 10msec to try 2nd round
 913   1          {
 914   2              //ADC_DPUTSTR("drvADC_SetModewithPLLProtection 1st failed\n");
 915   2              //ADC_DPRINTF("@@HV_flag = 0x%x", regval1);
 916   2              //ADC_DPRINTF("@@PLL_flag = 0x%x", regval2);
 917   2              Delay1ms(10);
 918   2              drvADC_IsEnableFreeRun(TRUE);
 919   2              drvADC_SetAutoProst(TRUE);
 920   2              drvADC_SetADCModeSetting(enADCInput, u16PixelClk);
 921   2              drvADC_SetAutoProst(FALSE);
 922   2              Delay1ms(1);
 923   2              drvADC_AdjustHTotal(u16HTotal);
 924   2              drvADC_IsEnableFreeRun(FALSE);
 925   2              Delay1ms(10); // PLL lock status would depend on input frequency, low frequency would take longer 
             -time to lock
 926   2              regval1 = drvADC_ReadByte(REG_ADC_ATOP_0D_H);
 927   2              regval2 = drvADC_ReadByte(REG_ADC_DTOP_05_L);
 928   2              if(!(regval1 & 0x02) && (regval2 & 0x80))
 929   2              {
 930   3                  result = TRUE;
 931   3              }
 932   2              else
 933   2                  result = FALSE;
 934   2          }
 935   1      #if ENABLE_ADC_RESET 
 936   1          // ADC software reset for ฐชทลฅีซฬissue
 937   1          drvADC_Write2BytesMask(REG_ADC_ATOP_07_L, BIT0, BIT0);
 938   1          drvADC_Write2BytesMask(REG_ADC_ATOP_07_L, 0, BIT0);
C51 COMPILER V9.60.0.0   DRVADC                                                            12/22/2020 19:50:39 PAGE 17  

 939   1          Delay1ms(2);
 940   1      #if CHIP_ID == CHIP_TSUMF
                // Reset PLLA after set mode
                  drvADC_Write2BytesMask(REG_ADC_ATOP_07_L, BIT1, BIT1);
                  drvADC_Write2BytesMask(REG_ADC_ATOP_07_L, 0, BIT1);
                  Delay1ms(2);
              #endif  
 946   1      #endif
 947   1          // trigger ADC phase dac alignment to avoid phase shift after DC off/on
 948   1          drvADC_Write2BytesMask(REG_ADC_ATOP_11_L, BIT8, BIT8);
 949   1          drvADC_Write2BytesMask(REG_ADC_ATOP_11_L, 0, BIT8);
 950   1          ADC_DPRINTF("drvADC_SetModewithPLLProtection result = %d\n", result);
 951   1          return result;
 952   1      }
 953          #endif //#ifdef DADCPLLPROTECTION
 954          
 955          #ifdef _DGAIN_CAL_WITHOUT_INPUT_
              //**************************************************************************
              //  [Function Name]:
              //                  drvADC_ADCAutoGainCalwithoutInput()
              //  [Description]
              //                  Do ADC gain calibration without input
              //  [Arguments]:
              //
              //  [Return]:
              //
              //**************************************************************************
              void drvADC_ADCAutoGainCalwithoutInput(void)
              {
              #if DADCNEWGAINCALMETHOD == 1
              
                  UserPrefAdcRedGain  = 0x421;
                  UserPrefAdcGreenGain = 0x421;
                  UserPrefAdcBlueGain = 0x421;
                  drvADC_SetRGBGainCode(UserPrefAdcRedGain, UserPrefAdcGreenGain, UserPrefAdcBlueGain);
              
              #elif DADCNEWGAINCALMETHOD == 2
              
                  #if (CHIP_ID == CHIP_TSUMF)
              
                  // Digital target gain: 1024/(1024-32)*PGA gain/0.7
                  // ADC PGA gain:
                  //  00: 1.0 / 01: 1.2 / 10: 0.8 / 11: 0.96
                  switch(UserPrefAdcPgaGain)
                  {
                      case 0x00: // 1.474654
                          UserPrefAdcRedGain = 1510;
                          UserPrefAdcGreenGain = 1510;
                          UserPrefAdcBlueGain = 1510;
                          break;
                      case 0x15: // 1.769584
                          UserPrefAdcRedGain = 1812;
                          UserPrefAdcGreenGain = 1812;
                          UserPrefAdcBlueGain = 1812;
                          break;
                      case 0x2A: // 1.179723
                          UserPrefAdcRedGain = 1208;
                          UserPrefAdcGreenGain = 1208;
                          UserPrefAdcBlueGain = 1208;
                          break;
                      case 0x3F: // 1.415667
                          UserPrefAdcRedGain = 1449;
C51 COMPILER V9.60.0.0   DRVADC                                                            12/22/2020 19:50:39 PAGE 18  

                          UserPrefAdcGreenGain = 1449;
                          UserPrefAdcBlueGain = 1449;
                          break;
                      default:
                          break;
                  }
              
                  #else
                  // Digital target gain: 1024/(1024-32)*PGA gain/0.7
                  // ADC PGA gain:
                  //  00: 0.861538 / 01: 0.969231 / 10: 1.076923 / 11: 1.184615
                  switch(UserPrefAdcPgaGain)
                  {
                      case 0x00:
                          UserPrefAdcRedGain = 0x514;
                          UserPrefAdcGreenGain = 0x514;
                          UserPrefAdcBlueGain = 0x514;
                          break;
                      case 0x15:
                          UserPrefAdcRedGain = 0x5B7;
                          UserPrefAdcGreenGain = 0x5B7;
                          UserPrefAdcBlueGain = 0x5B7;
                          break;
                      case 0x2A:
                          UserPrefAdcRedGain = 0x65A;
                          UserPrefAdcGreenGain = 0x65A;
                          UserPrefAdcBlueGain = 0x65A;
                          break;
                      case 0x3F:
                          UserPrefAdcRedGain = 0x6FC;
                          UserPrefAdcGreenGain = 0x6FC;
                          UserPrefAdcBlueGain = 0x6FC;
                          break;
                      default:
                          break;
                  }
              
              
                  #endif // #if (CHIP_ID == CHIP_TSUMF)
                  drvADC_SetRGBGainCode(UserPrefAdcRedGain, UserPrefAdcGreenGain, UserPrefAdcBlueGain);
              
              #else
              
                  // 1. backup ADC and Scaler related settings
                  drvADC_BackupADCSetting();
                  drvADC_BackupScalerSetting();
              
                  // 2. Set free run clock at 720p
                  _msADC_MaskExternalSync(TRUE);
                  drvADC_SetFreeRunClock();
              
                  // 3. Enable scaler pattern generator to generate Hsync and Vsync for line buffer
                  drvADC_EnableScalerPG(E_PG_Htotal_256);
              
                  // 4. Set ADC input LPF to lowest bandwidth
                  drvADC_Write2BytesMask(REG_ADC_ATOP_23_L, 0xFFFF, 0xFFFF);
                  drvADC_Write2BytesMask(REG_ADC_ATOP_24_L, 0x00FF, 0x00FF);
              
                  // 5. Calibrate ADC R/G/B gain setting value
                  // Set R/G/B gain initial setting value at 0x0400
                  // 6. Gain calibration target value for RGB color space mode is 182 (8bit data) 255 * 0.5 / 0.7 = 182
                  // 7. Get the ADC digital output with Turn-On LDO and Set VCAL to 1.05v
C51 COMPILER V9.60.0.0   DRVADC                                                            12/22/2020 19:50:39 PAGE 19  

                  // 8. Get the ADC digital output with VCAL to 0.55v
                  // 9. Calculate the difference between 1.05V and 0.55V of these 3 channels.
                  //    Compare the difference value with target value (182 at RGB color space) to adjust R/G/B channel 
             -gain register
                  drvADC_AutoGainAdjustment();
              
                  // 10. recover ADC and scaler related settings & turn off free run clock & turn off internal Vcal
                  _msADC_MaskExternalSync(FALSE);
                  drvADC_RecoverADCSetting();
                  drvADC_RecoverScalerSetting();
              
              #endif // #if DADCNEWGAINCALMETHOD
              }
              #endif
1076          
1077          #ifdef _DGAIN_CAL_WITH_INPUT_
              //**************************************************************************
              //  [Function Name]:
              //                  drvADC_ADCAutoGainCalwithInput()
              //  [Description]
              //                  Do ADC gain calibration with input
              //  [Arguments]:
              //
              //  [Return]:
              //
              //**************************************************************************
              void drvADC_ADCAutoGainCalwithInput(void)
              {
                  WORD wStartAddress;
              
                  // 1. backup ADC and Scaler related settings
                  drvADC_BackupADCSetting();
                  drvADC_BackupScalerSetting();
              
                  // 2. Set free run clock at 720p
                  //drvADC_SetFreeRunClock();
              
                  // 3. Enable scaler pattern generator to generate Hsync and Vsync for line buffer
                  //drvADC_EnableScalerPG(E_PG_Htotal_256);
              
                  // 4. Set ADC input LPF to lowest bandwidth
                  drvADC_Write2BytesMask(REG_ADC_ATOP_23_L, 0xFFFF, 0xFFFF);
                  drvADC_Write2BytesMask(REG_ADC_ATOP_24_L, 0x00FF, 0x00FF);
                  drvADC_SetRGBOffsetCode(0, 0, 0);
                  drvADC_SetRGBGainCode(0x421, 0x421, 0x421);
              
                  // Find the white pattern region in line buffer
                  wStartAddress = drvADC_FindWhiteRegion(0, 16);
                  // 5. Calibrate ADC R/G/B gain setting value
                  // Set R/G/B gain initial setting value at 0x0400
                  // 6. Gain calibration target value for RGB color space mode is 182 (8bit data) 255 * 0.5 / 0.7 = 182
                  // 7. Get the ADC digital output with Turn-On LDO and Set VCAL to 1.05v
                  // 8. Get the ADC digital output with VCAL to 0.55v
                  // 9. Calculate the difference between 1.05V and 0.55V of these 3 channels.
                  //    Compare the difference value with target value (182 at RGB color space) to adjust R/G/B channel 
             -gain register
                  drvADC_AutoGainAdjustment_WithInput(wStartAddress, 0, 32);
              
                  // 10. recover ADC and scaler related settings & turn off free run clock & turn off internal Vcal
                  drvADC_RecoverADCSetting();
                  drvADC_RecoverScalerSetting();
              }
C51 COMPILER V9.60.0.0   DRVADC                                                            12/22/2020 19:50:39 PAGE 20  

              
              #endif
1125          
1126          //-------------------------------------------------------------------------------------------------
1127          //  Local Functions
1128          //-------------------------------------------------------------------------------------------------
1129          
1130          #if 0
              //**************************************************************************
              //  [Function Name]:
              //                  drvADC_Write2BytesMask()
              //  [Description]:
              //                  Load ADC driver table setting
              //  [Precondition]:
              //
              //  [Arguments]:
              //                 u16regadr : 16 bits register address
              //                 u16val : 16 bits register value
              //                 u16mask : 16 bits register mask
              //  [Return]:
              //
              //**************************************************************************
              static void drvADC_Write2BytesMask(WORD u16regadr, WORD u16val, WORD u16mask)
              {
              #if 1//CHIP_ID == CHIP_TSUMU
                  msWrite2ByteMask( u16regadr, u16val, u16mask );
              #else
              
                  BYTE ucBank, ucCurBank, ucCurReg;
              
                  ucBank = mStar_ReadByte(REGBK); // backup bank
              
                  ucCurBank = (BYTE)(u16regadr >> 8);
                  ucCurReg = (BYTE)(u16regadr & 0xFF);
              
                  if(ucCurBank != ucBank)
                      mStar_WriteByte(REGBK, ucCurBank);
              
                  if(u16mask & 0x00FF)
                      mStar_WriteByteMask(ucCurReg, (BYTE)(u16val&0xFF), (BYTE)(u16mask&0xFF));
                  if(u16mask & 0xFF00)
                      mStar_WriteByteMask(ucCurReg+1, (BYTE)(u16val>>8), (BYTE)(u16mask>>8));
              
                  mStar_WriteByte(REGBK, ucBank);        // Switch to Original bank
              #endif
              }
              #endif
1170          #if 0
              //**************************************************************************
              //  [Function Name]:
              //                  drvADC_ReadByte()
              //  [Description]:
              //                  Read ADC register value
              //  [Precondition]:
              //
              //  [Arguments]:
              //                 u16regadr : 16 bits register address
              //  [Return]:
              //                 register value(1 byte)
              //**************************************************************************
              static BYTE drvADC_ReadByte(WORD u16regadr)
              {
C51 COMPILER V9.60.0.0   DRVADC                                                            12/22/2020 19:50:39 PAGE 21  

              #if 1//CHIP_ID == CHIP_TSUMU
                  return msReadByte( u16regadr );
              #else
              
                  BYTE ucBank, ucCurBank, ucCurReg, retval;
              
                  ucBank = mStar_ReadByte(REGBK); // backup bank
              
                  ucCurBank = (BYTE)(u16regadr >> 8);
                  ucCurReg = (BYTE)(u16regadr & 0xFF);
              
                  if(ucCurBank != ucBank)
                      mStar_WriteByte(REGBK, ucCurBank);
                  retval = mStar_ReadByte(ucCurReg);
              
                  mStar_WriteByte(REGBK, ucBank);        // Switch to Original bank
              
                  return retval;
              #endif
              }
              #endif
1206          //**************************************************************************
1207          //  [Function Name]:
1208          //                  drvADC_WaitAutoStatusReady()
1209          //  [Description]:
1210          //                  Wait ready bit is ready
1211          //  [Precondition]:
1212          //
1213          //  [Arguments]:
1214          //                 regAddr: 16 bit register address
1215          //                 regFlag: Ready bit
1216          //  [Return]:
1217          //
1218          //**************************************************************************
1219          BYTE drvADC_WaitAutoStatusReady(WORD regAddr, BYTE regFlag)
1220          {
1221   1      #if 0
                  WORD waits=5000; // MCU 1x: 1500, 2x:3000, 3x: 4500
                  while (waits-- && !(mStar_ReadByte(regAddr)&regFlag));
              #else
1225   1          BYTE u8Value;
1226   1          SetTimOutConter(50);
1227   1          //bTimeOutCounterFlag=0;
1228   1          //u16TimeOutCounter=50;// 50 msec, at least two frames
1229   1          //bTimeOutCounterFlag=1;
1230   1          while( u16TimeOutCounter && !( (u8Value=msReadByte( regAddr ))&regFlag ) );
1231   1      #endif
1232   1          //ADC_DPRINTF("drvADC_WaitAutoStatusReady= %d\n", u8Delay);
1233   1          return u8Value;
1234   1      }
1235          
1236          //**************************************************************************
1237          //  [Function Name]:
1238          //                  Hal_ADC_LoadTable()
1239          //  [Description]:
1240          //                  Load ADC driver table setting
1241          //  [Precondition]:
1242          //
1243          //  [Arguments]:
1244          //                 pTab_info
1245          //  [Return]:
1246          //
C51 COMPILER V9.60.0.0   DRVADC                                                            12/22/2020 19:50:39 PAGE 22  

1247          //**************************************************************************
1248          static void drvADC_LoadTable(TAB_Info* pTab_info)
1249          {
1250   1          WORD i, u16Addr;
1251   1          BYTE u8Mask, u8Value, u8DoNotSet;
1252   1      
1253   1          if (pTab_info->pTable == NULL || pTab_info->u8TabRows == 0 || pTab_info->u8TabRows == 1)
1254   1              return;
1255   1      
1256   1          if (REG_ADDR_SIZE+REG_MASK_SIZE+pTab_info->u8TabIdx*REG_DATA_SIZE >= pTab_info->u8TabCols)
1257   1          {
1258   2              ADC_DPUTSTR("Tab_info error\n");
1259   2              return;
1260   2          }
1261   1      
1262   1          for (i=0; i<pTab_info->u8TabRows-1; i++)
1263   1          {
1264   2               u16Addr =  (WORD)( (pTab_info->pTable[0]<<8) + pTab_info->pTable[1] );
1265   2      
1266   2               if(u16Addr == REG_ADC_DTOP_FE_L)
1267   2               {
1268   3                  // delay only, skip to write next register
1269   3                  u8Value = pTab_info->pTable[REG_ADDR_SIZE+REG_MASK_SIZE+pTab_info->u8TabIdx*REG_DATA_SIZE + 1]
             -;
1270   3                  //ADC_DPRINTF("ADC tbl delay (%d) ms \n",u8Value);
1271   3                  ForceDelay1ms(u8Value);
1272   3                  goto NEXT;
1273   3               }
1274   2      
1275   2               u8Mask  = pTab_info->pTable[2];
1276   2               u8DoNotSet = pTab_info->pTable[REG_ADDR_SIZE+REG_MASK_SIZE+pTab_info->u8TabIdx*REG_DATA_SIZE];
1277   2               u8Value = pTab_info->pTable[REG_ADDR_SIZE+REG_MASK_SIZE+pTab_info->u8TabIdx*REG_DATA_SIZE + 1];
1278   2      
1279   2               //printf("[addr=%06lx, msk=%02x, enb=%02x val=%02x]\n", u32Addr, u8Mask,u8DoNotSet, u8Value);
1280   2      
1281   2               if ( !u8DoNotSet )
1282   2               {
1283   3                  //ADC_DPUTSTR("@@ register value Mask = ");
1284   3                  //ADC_DPRINTF("0x%x", u16Addr);
1285   3                  //ADC_DPRINTF("0x%x", u8Value);
1286   3                  //ADC_DPRINTF("0x%x", u8Mask);
1287   3                  msWriteByteMask( u16Addr, u8Value, u8Mask );
1288   3               }
1289   2      NEXT:
1290   2               pTab_info->pTable+=pTab_info->u8TabCols; // next
1291   2          }
1292   1      }
1293          
1294          //**************************************************************************
1295          //  [Function Name]:
1296          //                  drvADC_SetMux()
1297          //  [Description]
1298          //                  ADC set sync and data mux
1299          //  [Arguments]:
1300          //                  ipmux_type: sync / data
1301          //  [Return]:
1302          //
1303          //**************************************************************************
1304          static void drvADC_SetMux(ADC_MUX_TYPE ipmux_type)
1305          {
1306   1          TAB_Info Tab_info;
1307   1          Tab_info.pTable = (void*)MST_ADCMUX_TBL;
C51 COMPILER V9.60.0.0   DRVADC                                                            12/22/2020 19:50:39 PAGE 23  

1308   1          Tab_info.u8TabCols = REG_ADDR_SIZE+REG_MASK_SIZE+ADC_TABLE_MUX_NUMS*REG_DATA_SIZE;
1309   1          Tab_info.u8TabRows = sizeof(MST_ADCMUX_TBL)/Tab_info.u8TabCols;
1310   1          Tab_info.u8TabIdx = ipmux_type;
1311   1      
1312   1          ADC_DPRINTF("ADC Tbl:set mux %d \n",ipmux_type);
1313   1          drvADC_LoadTable(&Tab_info);
1314   1      
1315   1      }
1316          
1317          //**************************************************************************
1318          //  [Function Name]:
1319          //                  drvADC_SearchFreqSetTableIndex()
1320          //  [Description]:
1321          //                  Search the Frequncy table index
1322          //  [Precondition]:
1323          //
1324          //  [Arguments]:
1325          //                 u16OriginalPixClk: xxxMHz
1326          //  [Return]:
1327          //
1328          //**************************************************************************
1329          static BYTE drvADC_SearchFreqSetTableIndex(WORD u16OriginalPixClk)
1330          {
1331   1          BYTE  u8ClkIndex;
1332   1      
1333   1          for(u8ClkIndex=0; u8ClkIndex<sizeof(MST_ADC_FreqRange_TBL)/sizeof(ADC_FREQ_RANGE); u8ClkIndex++)
1334   1          {
1335   2              if((u16OriginalPixClk < MST_ADC_FreqRange_TBL[u8ClkIndex].FreqHLimit) &&
1336   2                  (u16OriginalPixClk >= MST_ADC_FreqRange_TBL[u8ClkIndex].FreqLLimit))
1337   2                  break;
1338   2          }
1339   1      
1340   1          return u8ClkIndex;
1341   1      }
1342          
1343          
1344          //**************************************************************************
1345          //  [Function Name]:
1346          //                  drvADC_BackupADCSetting()
1347          //  [Description]:
1348          //                  Backup ADC settings
1349          //  [Precondition]:
1350          //
1351          //  [Arguments]:
1352          //
1353          //  [Return]:
1354          //
1355          //**************************************************************************
1356          static void drvADC_BackupADCSetting(void)
1357          {
1358   1          memset(&gADCBackupSetting, 0, sizeof(gADCBackupSetting));
1359   1      #if ENABLE_XTAL_LESS
                  gADCBackupSetting.BWCoef = drvADC_ReadByte(REG_ADC_DTOP_02_L);
                  gADCBackupSetting.DampCoef = drvADC_ReadByte(REG_ADC_DTOP_03_L);
              #endif
1363   1          gADCBackupSetting.PLL_Ictrl = drvADC_ReadByte(REG_ADC_ATOP_09_H) & 0x03;
1364   1          gADCBackupSetting.PLL_Mult_Mod_216m = drvADC_ReadByte(REG_ADC_ATOP_0A_L) & 0x3F;
1365   1          gADCBackupSetting.LPF_Rch = drvADC_ReadByte(REG_ADC_ATOP_24_L) & 0x0F;
1366   1          gADCBackupSetting.LPF_Gch = drvADC_ReadByte(REG_ADC_ATOP_23_H) & 0x0F;
1367   1          gADCBackupSetting.LPF_Bch = drvADC_ReadByte(REG_ADC_ATOP_23_L) & 0x0F;
1368   1          gADCBackupSetting.Blacklevel_Rch = (drvADC_ReadByte(REG_ADC_DTOP_44_H) << 8 | drvADC_ReadByte(REG_ADC_
             -DTOP_44_L)) & 0x03FF;
C51 COMPILER V9.60.0.0   DRVADC                                                            12/22/2020 19:50:39 PAGE 24  

1369   1          gADCBackupSetting.Blacklevel_Gch = (drvADC_ReadByte(REG_ADC_DTOP_47_H) << 8 | drvADC_ReadByte(REG_ADC_
             -DTOP_47_L)) & 0x03FF;
1370   1          gADCBackupSetting.Blacklevel_Bch = (drvADC_ReadByte(REG_ADC_DTOP_50_H) << 8 | drvADC_ReadByte(REG_ADC_
             -DTOP_50_L)) & 0x03FF;
1371   1          gADCBackupSetting.Offset_Rch = (drvADC_ReadByte(REG_ADC_DTOP_46_H) << 8 | drvADC_ReadByte(REG_ADC_DTOP
             -_46_L)) & 0x07FF;
1372   1          gADCBackupSetting.Offset_Gch = (drvADC_ReadByte(REG_ADC_DTOP_49_H) << 8 | drvADC_ReadByte(REG_ADC_DTOP
             -_49_L)) & 0x07FF;
1373   1          gADCBackupSetting.Offset_Bch = (drvADC_ReadByte(REG_ADC_DTOP_52_H) << 8 | drvADC_ReadByte(REG_ADC_DTOP
             -_52_L)) & 0x07FF;
1374   1      }
1375          
1376          //**************************************************************************
1377          //  [Function Name]:
1378          //                  drvADC_RecoverADCSetting()
1379          //  [Description]:
1380          //                  Recover ADC settings
1381          //  [Precondition]:
1382          //
1383          //  [Arguments]:
1384          //
1385          //  [Return]:
1386          //
1387          //**************************************************************************
1388          static void drvADC_RecoverADCSetting(void)
1389          {
1390   1          drvADC_Write2BytesMask(REG_ADC_ATOP_54_L, 0x0000, 0xFFFF);
1391   1          drvADC_Write2BytesMask(REG_ADC_DTOP_06_L, 0x0000, 0x0080); // PLL Frequency Force Disable
1392   1      #if ENABLE_XTAL_LESS
                  drvADC_Write2BytesMask(REG_ADC_DTOP_02_L, 0x0900|gADCBackupSetting.BWCoef, 0xFFFF);
                  drvADC_Write2BytesMask(REG_ADC_DTOP_03_L, gADCBackupSetting.DampCoef, 0xFFFF);
              #else
1396   1          drvADC_Write2BytesMask(REG_ADC_DTOP_02_L, 0x0982, 0xFFFF);
1397   1          drvADC_Write2BytesMask(REG_ADC_DTOP_03_L, 0x0005, 0xFFFF);
1398   1      #endif // #if ENABLE_XTAL_LESS
1399   1          drvADC_Write2BytesMask(REG_ADC_ATOP_0A_L, gADCBackupSetting.PLL_Mult_Mod_216m, 0x003F);
1400   1          drvADC_Write2BytesMask(REG_ADC_ATOP_09_L, gADCBackupSetting.PLL_Ictrl << 8, 0x0300);
1401   1          drvADC_Write2BytesMask(REG_ADC_ATOP_23_L, (gADCBackupSetting.LPF_Gch << 8)|gADCBackupSetting.LPF_Bch ,
             - 0x0F0F);
1402   1          drvADC_Write2BytesMask(REG_ADC_ATOP_24_L, gADCBackupSetting.LPF_Rch, 0x000F);
1403   1          drvADC_Write2BytesMask(REG_ADC_DTOP_44_L, gADCBackupSetting.Blacklevel_Rch, 0x03FF);
1404   1          drvADC_Write2BytesMask(REG_ADC_DTOP_47_L, gADCBackupSetting.Blacklevel_Gch, 0x03FF);
1405   1          drvADC_Write2BytesMask(REG_ADC_DTOP_50_L, gADCBackupSetting.Blacklevel_Bch, 0x03FF);
1406   1          drvADC_Write2BytesMask(REG_ADC_DTOP_46_L, gADCBackupSetting.Offset_Rch, 0x07FF);
1407   1          drvADC_Write2BytesMask(REG_ADC_DTOP_49_L, gADCBackupSetting.Offset_Gch, 0x07FF);
1408   1          drvADC_Write2BytesMask(REG_ADC_DTOP_52_L, gADCBackupSetting.Offset_Bch, 0x07FF);
1409   1      }
1410          
1411          //**************************************************************************
1412          //  [Function Name]:
1413          //                  drvADC_SetFreeRunClock()
1414          //  [Description]:
1415          //                  Set ADC free-run clock to 40MHz
1416          //  [Precondition]:
1417          //
1418          //  [Arguments]:
1419          //
1420          //  [Return]:
1421          //
1422          //**************************************************************************
1423          static void drvADC_SetFreeRunClock(void)
1424          {
C51 COMPILER V9.60.0.0   DRVADC                                                            12/22/2020 19:50:39 PAGE 25  

1425   1          //drvADC_Write2BytesMask(REG_ADC_ATOP_01_L, 0x4001, 0xFFFF); // ADC enable
1426   1          //drvADC_Write2BytesMask(REG_ADC_ATOP_04_L, 0, 0xFFFF); // Turn on analog power down
1427   1          //drvADC_Write2BytesMask(REG_ADC_ATOP_06_L, 0, 0xFFFF); // Turn on gated
1428   1      #if 0
                  drvADC_Write2BytesMask(REG_ADC_ATOP_0A_L, 0x0008, 0x003F); // PLL_MULT = 0, DIV2_EN = 1'b1
                  drvADC_Write2BytesMask(REG_ADC_ATOP_09_L, 0x0300, 0x0300); // ADCPLL_ICTRL = 2'b11
                  drvADC_Write2BytesMask(REG_ADC_DTOP_02_L, 0xB82E, 0xFFFF);
                  drvADC_Write2BytesMask(REG_ADC_DTOP_03_L, 0x0052, 0xFFFF);
                  drvADC_Write2BytesMask(REG_ADC_DTOP_06_L, 0x0080, 0x0080); // PLL Frequency Force Enable
              #else // revise the correct free-run 40MHz setting
1435   1          drvADC_Write2BytesMask( REG_ADC_ATOP_0A_L, 0x0010, 0x003F ); // [5]:DIV2_EN = 1'b0, [4:3]:APLL_MOD=2'b
             -10, [2:0]: APLL_MULT = 0
1436   1      #if ((CHIP_ID == CHIP_TSUMC) || (CHIP_ID==CHIP_TSUMK) || (CHIP_ID == CHIP_TSUMD) || (CHIP_ID == CHIP_TSUMJ
             -) || (CHIP_ID == CHIP_TSUM9)|| (CHIP_ID == CHIP_TSUMF))
1437   1          drvADC_Write2BytesMask( REG_ADC_ATOP_09_L, 0x0200, 0x0700 ); // ADCPLL_ICTRL = 2'b010
1438   1      #else
                  drvADC_Write2BytesMask( REG_ADC_ATOP_09_L, 0x0200, 0x0300 ); // ADCPLL_ICTRL = 2'b10
              #endif // #if (CHIP_ID == CHIP_TSUMC)
1441   1          drvADC_Write2BytesMask( REG_ADC_DTOP_02_L, 0x6656, 0xFFFF );
1442   1          drvADC_Write2BytesMask( REG_ADC_DTOP_03_L, 0x0066, 0xFFFF );
1443   1          drvADC_Write2BytesMask( REG_ADC_DTOP_06_L, 0x0080, 0x0080 ); // PLL Frequency Force Enable
1444   1      #endif
1445   1      }
1446          
1447          
1448          #if ((CHIP_ID == CHIP_TSUMD) || (CHIP_ID == CHIP_TSUMJ) || (CHIP_ID == CHIP_TSUM9)|| (CHIP_ID == CHIP_TSUM
             -F))
1449          //**************************************************************************
1450          //  [Function Name]:
1451          //                  drvADC_MismatchOffsetCal()
1452          //  [Description]:
1453          //                  ADC mismatch offset calibration
1454          //  [Precondition]:
1455          //
1456          //  [Arguments]:
1457          //
1458          //  [Return]:
1459          //
1460          //**************************************************************************
1461          static void drvADC_MismatchLinearityCal(void)
1462          {
1463   1          SetTimOutConter(10);
1464   1          //u16TimeOutCounter = 10; // 10 msec
1465   1          //bTimeOutCounterFlag=1;
1466   1          // Set Vcal 
1467   1          //drvADC_Write2BytesMask(REG_ADC_ATOP_54_L, 0xF800, 0xF800); // [15]:ADC VCAL force enable, [14:11]: s
             -et Vcal
1468   1          drvADC_Write2BytesMask(REG_ADC_ATOP_54_L, 0xF600, 0xFF00); // [15]:ADC VCAL force enable, [14:11]: set
             - Vcal, [10:8]: 3'b 110, reg_rgb_self_gcal_pulse_sw
1469   1      
1470   1          do
1471   1          {
1472   2              // Enable linearity calibration
1473   2              drvADC_Write2BytesMask(REG_ADC_DTOP_66_L, 0, 0x0070); // [6:4]: Enable linearity calibration for R
             -/G/B
1474   2              drvADC_Write2BytesMask(REG_ADC_DTOP_66_L, 0x0070, 0x0070); // [6:4]: Enable linearity calibration 
             -for R/G/B
1475   2              // Trigger
1476   2              drvADC_Write2BytesMask(REG_ADC_DTOP_68_L, 0x0000, 0x0700); // [10:8]: Rising trigger for R/G/B (Au
             -to/Manual mode)
1477   2              drvADC_Write2BytesMask(REG_ADC_DTOP_68_L, 0x0700, 0x0700); // [10:8]: Rising trigger for R/G/B (Au
             -to/Manual mode)
C51 COMPILER V9.60.0.0   DRVADC                                                            12/22/2020 19:50:39 PAGE 26  

1478   2              drvADC_Write2BytesMask(REG_ADC_DTOP_68_L, 0x0000, 0x0700); // [10:8]: Rising trigger for R/G/B (Au
             -to/Manual mode)
1479   2              // wait done
1480   2              ForceDelay1ms(1);
1481   2          } while( u16TimeOutCounter && ((drvADC_ReadByte(REG_ADC_DTOP_69_H) & 0x70) != 0x70) ); // [14:12]: lin
             -earity calibration done
1482   1          // Set Vcal 
1483   1          //drvADC_Write2BytesMask(REG_ADC_ATOP_54_L, 0, 0xF800); // [15]:ADC VCAL force enable, [14:11]: set Vc
             -al
1484   1          drvADC_Write2BytesMask(REG_ADC_ATOP_54_L, 0, 0xFF00); // [15]:ADC VCAL force enable, [14:11]: set Vcal
             -, [10:8]: 3'b 110, reg_rgb_self_gcal_pulse_sw
1485   1      
1486   1      #if 1
1487   1          if((drvADC_ReadByte(REG_ADC_DTOP_69_H) & 0x70) == 0x70)
1488   1          {
1489   2              ADC_DPRINTF("@@ L_T= %d\n", u16TimeOutCounter);
1490   2              ADC_DPRINTF("@@ ADC R_ACCU_CH0 = 0x%x\n", msRead2Byte(REG_ADC_DTOP_6A_L));
1491   2              ADC_DPRINTF("@@ ADC R_ACCU_CH1 = 0x%x\n", msRead2Byte(REG_ADC_DTOP_6B_L));
1492   2              ADC_DPRINTF("@@ ADC G_ACCU_CH0 = 0x%x\n", msRead2Byte(REG_ADC_DTOP_6C_L));
1493   2              ADC_DPRINTF("@@ ADC G_ACCU_CH1 = 0x%x\n", msRead2Byte(REG_ADC_DTOP_6D_L));
1494   2              ADC_DPRINTF("@@ ADC B_ACCU_CH0 = 0x%x\n", msRead2Byte(REG_ADC_DTOP_6E_L));
1495   2              ADC_DPRINTF("@@ ADC B_ACCU_CH1 = 0x%x\n", msRead2Byte(REG_ADC_DTOP_6F_L));
1496   2          }
1497   1      #endif
1498   1      }
1499          #endif // #if ((CHIP_ID == CHIP_TSUMD) || (CHIP_ID == CHIP_TSUMJ) || (CHIP_ID == CHIP_TSUM9)|| (CHIP_ID ==
             - CHIP_TSUMF))
1500          
1501          //**************************************************************************
1502          //  [Function Name]:
1503          //                  drvADC_MismatchOffsetCal()
1504          //  [Description]:
1505          //                  ADC mismatch offset calibration
1506          //  [Precondition]:
1507          //
1508          //  [Arguments]:
1509          //
1510          //  [Return]:
1511          //
1512          //**************************************************************************
1513          static void drvADC_MismatchOffsetCal(void)
1514          {
1515   1          WORD wTimeOutCnt = 300;
1516   1          WORD wRch0val, wRch1val, wGch0val, wGch1val, wBch0val, wBch1val;
1517   1          WORD wRch0diff, wRch1diff, wGch0diff, wGch1diff, wBch0diff, wBch1diff;
1518   1          WORD wRchPivot, wGchPivot, wBchPivot;
1519   1      
1520   1          // 1. Turn on ADC offset calibration pluse
1521   1          drvADC_Write2BytesMask(REG_ADC_ATOP_54_L, 0x0030, 0x0030);
1522   1      
1523   1          // 2. Enable ADC data low Vcal accumulator
1524   1          drvADC_Write2BytesMask(REG_ADC_ATOP_55_L, 0x0080, 0x0080);
1525   1      
1526   1          ForceDelay1ms(1); // delay 1 msec
1527   1      
1528   1          // 3. Trigger ADC data low Vcal accumulator start
1529   1          drvADC_Write2BytesMask(REG_ADC_ATOP_55_L, 0x0100, 0x0100);
1530   1      
1531   1          // 4. Wait ADC data accumulation done, ADC_ATO_74_L[2:0] = 3'b 111
1532   1          while ((wTimeOutCnt>0) && (!(drvADC_ReadByte(REG_ADC_ATOP_74_L) & 0x07)))
1533   1          {
1534   2              wTimeOutCnt--;
C51 COMPILER V9.60.0.0   DRVADC                                                            12/22/2020 19:50:39 PAGE 27  

1535   2          }
1536   1          if(wTimeOutCnt == 0)
1537   1              ADC_DPUTSTR("ADC data accumulation time out\n");
1538   1      
1539   1          // 5. Read ADC channel 0 & 1 average value
1540   1          wRch0val = ((drvADC_ReadByte(REG_ADC_ATOP_62_H)&0x03) << 8) | drvADC_ReadByte(REG_ADC_ATOP_62_L);
1541   1          wRch1val = ((drvADC_ReadByte(REG_ADC_ATOP_65_H)&0x03) << 8) | drvADC_ReadByte(REG_ADC_ATOP_65_L);
1542   1          wGch0val = ((drvADC_ReadByte(REG_ADC_ATOP_68_H)&0x03) << 8) | drvADC_ReadByte(REG_ADC_ATOP_68_L);
1543   1          wGch1val = ((drvADC_ReadByte(REG_ADC_ATOP_6B_H)&0x03) << 8) | drvADC_ReadByte(REG_ADC_ATOP_6B_L);
1544   1          wBch0val = ((drvADC_ReadByte(REG_ADC_ATOP_6E_H)&0x03) << 8) | drvADC_ReadByte(REG_ADC_ATOP_6E_L);
1545   1          wBch1val = ((drvADC_ReadByte(REG_ADC_ATOP_71_H)&0x03) << 8) | drvADC_ReadByte(REG_ADC_ATOP_71_L);
1546   1      
1547   1      #if 0
                  // Aaron test
                  wRch0val = 2000;
                  wRch1val = 1889;
                  wGch0val = 1776;
                  wGch1val = 1888;
                  wBch0val = 2;
                  wBch1val = 400;
              #endif
1556   1      
1557   1          // 6. Set ADC compensated codes and Pivot-point value
1558   1          // R-ch
1559   1          if(wRch0val > wRch1val)
1560   1          {
1561   2              wRch0diff = (WORD)(wRch1val-wRch0val); // negative number, 2's complement
1562   2              wRch1diff = 0x0000;
1563   2              wRchPivot = wRch1val; // minimum one
1564   2          }
1565   1          else if (wRch0val < wRch1val)
1566   1          {
1567   2              wRch0diff = 0x0000;
1568   2              wRch1diff = (WORD)(wRch0val-wRch1val); // negative number, 2's complement
1569   2              wRchPivot = wRch0val; // minimum one
1570   2          }
1571   1          else // wRch0val = wRch1val
1572   1          {
1573   2              wRch0diff = 0x0000;
1574   2              wRch1diff = 0x0000;
1575   2              wRchPivot = wRch0val;
1576   2          }
1577   1          // G-ch
1578   1          if(wGch0val > wGch1val)
1579   1          {
1580   2              wGch0diff = (WORD)(wGch1val-wGch0val); // negative number, 2's complement
1581   2              wGch1diff = 0x0000;
1582   2              wGchPivot = wGch1val; // minimum one
1583   2          }
1584   1          else if (wGch0val < wGch1val)
1585   1          {
1586   2              wGch0diff = 0x0000;
1587   2              wGch1diff = (WORD)(wGch0val-wGch1val); // negative number, 2's complement
1588   2              wGchPivot = wGch0val; // minimum one
1589   2          }
1590   1          else // wGch0val = wGch1val
1591   1          {
1592   2              wGch0diff = 0x0000;
1593   2              wGch1diff = 0x0000;
1594   2              wGchPivot = wGch0val;
1595   2          }
1596   1          // B-ch
C51 COMPILER V9.60.0.0   DRVADC                                                            12/22/2020 19:50:39 PAGE 28  

1597   1          if(wBch0val > wBch1val)
1598   1          {
1599   2              wBch0diff = (WORD)(wBch1val-wBch0val); // negative number, 2's complement
1600   2              wBch1diff = 0x0000;
1601   2              wBchPivot = wBch1val; // minimum one
1602   2          }
1603   1          else if (wBch0val < wBch1val)
1604   1          {
1605   2              wBch0diff = 0x0000;
1606   2              wBch1diff = (WORD)(wBch0val-wBch1val); // negative number, 2's complement
1607   2              wBchPivot = wBch0val; // minimum one
1608   2          }
1609   1          else // wBch0val = wBch1val
1610   1          {
1611   2              wBch0diff = 0x0000;
1612   2              wBch1diff = 0x0000;
1613   2              wBchPivot = wBch0val;
1614   2          }
1615   1      
1616   1          gADCMismatchAvgVal.wOffsetVal_Rch0  += wRch0val;
1617   1          gADCMismatchAvgVal.wOffsetVal_Rch1  += wRch1val;
1618   1          gADCMismatchAvgVal.wPivot_Rch       += wRchPivot;
1619   1          gADCMismatchAvgVal.wOffsetVal_Gch0  += wGch0val;
1620   1          gADCMismatchAvgVal.wOffsetVal_Gch1  += wGch1val;
1621   1          gADCMismatchAvgVal.wPivot_Gch       += wGchPivot;
1622   1          gADCMismatchAvgVal.wOffsetVal_Bch0  += wBch0val;
1623   1          gADCMismatchAvgVal.wOffsetVal_Bch1  += wBch1val;
1624   1          gADCMismatchAvgVal.wPivot_Bch       += wBchPivot;
1625   1      #if 0
                  drvADC_Write2BytesMask(REG_ADC_ATOP_56_L, wRch0diff, 0x07FF); // Set ADC channel 0 offset compensated 
             -code
                  drvADC_Write2BytesMask(REG_ADC_ATOP_57_L, wRch1diff, 0x07FF); // Set ADC channel 1 offset compensated 
             -code
                  drvADC_Write2BytesMask(REG_ADC_ATOP_75_L, wRchPivot, 0x03FF); // Set ADCR pivot-point value, choose mi
             -nimum one
                  drvADC_Write2BytesMask(REG_ADC_ATOP_5A_L, wGch0diff, 0x07FF); // Set ADC channel 0 offset compensated 
             -code
                  drvADC_Write2BytesMask(REG_ADC_ATOP_5B_L, wGch1diff, 0x07FF); // Set ADC channel 1 offset compensated 
             -code
                  drvADC_Write2BytesMask(REG_ADC_ATOP_76_L, wGchPivot, 0x03FF); // Set ADCG pivot-point value, choose mi
             -nimum one
                  drvADC_Write2BytesMask(REG_ADC_ATOP_5E_L, wBch0diff, 0x07FF); // Set ADC channel 0 offset compensated 
             -code
                  drvADC_Write2BytesMask(REG_ADC_ATOP_5F_L, wBch1diff, 0x07FF); // Set ADC channel 1 offset compensated 
             -code
                  drvADC_Write2BytesMask(REG_ADC_ATOP_77_L, wBchPivot, 0x03FF); // Set ADCB pivot-point value, choose mi
             -nimum one
              #endif
1636   1      #if 0
                  ADC_DPRINTF("\nR Ch0 code= 0x%x", wRch0diff);
                  ADC_DPRINTF("R Ch1 code= 0x%x", wRch1diff);
                  ADC_DPRINTF("R Pivot-point= 0x%x", wRchPivot);
                  ADC_DPRINTF("G Ch0 code= 0x%x", wGch0diff);
                  ADC_DPRINTF("G Ch1 code= 0x%x", wGch1diff);
                  ADC_DPRINTF("G Pivot-point= 0x%x", wGchPivot);
                  ADC_DPRINTF("B Ch0 code= 0x%x", wBch0diff);
                  ADC_DPRINTF("B Ch1 code= 0x%x", wBch1diff);
                  ADC_DPRINTF("B Pivot-point= 0x%x \n", wBchPivot);
              #endif
1647   1          // 7. Turn on enable offset mismatch compensated codes
1648   1          drvADC_Write2BytesMask(REG_ADC_ATOP_55_L, 0x0015, 0x0095); // [7]: acc low disable, [4]: B mismatch of
             -fset enable, [2]: G mismatch offset enable, [0]: R mismatch offset enable,
C51 COMPILER V9.60.0.0   DRVADC                                                            12/22/2020 19:50:39 PAGE 29  

1649   1      
1650   1          // 8. Turn off ADC offset calibration pulse
1651   1          drvADC_Write2BytesMask(REG_ADC_ATOP_54_L, 0x0000, 0x0030);
1652   1      }
1653          
1654          //**************************************************************************
1655          //  [Function Name]:
1656          //                  drvADC_MismatchGainCal()
1657          //  [Description]:
1658          //                  ADC mismatch gain calibration
1659          //  [Precondition]:
1660          //
1661          //  [Arguments]:
1662          //
1663          //  [Return]:
1664          //
1665          //**************************************************************************
1666          static void drvADC_MismatchGainCal(void)
1667          {
1668   1          WORD wTimeOutCnt = 300;
1669   1          WORD wRch0val, wRch1val, wGch0val, wGch1val, wBch0val, wBch1val;
1670   1          WORD wRch0Div, wRch1Div, wGch0Div, wGch1Div, wBch0Div, wBch1Div;
1671   1      #if DADCNEWGAINCALMETHOD
                  WORD wTargetCode;
              #endif
1674   1      
1675   1          // 1. Turn on LDO & select VCAL 1.05V, Turn on ADC gain calibration pulse
1676   1      #if DADCCALBYBANDGAP
                  drvADC_Write2BytesMask(REG_ADC_ATOP_34_L, 0, BIT0); // turn off LDO
                  drvADC_Write2BytesMask(REG_ADC_ATOP_34_L, 0, BIT2); // Bandgap
                  drvADC_Write2BytesMask(REG_ADC_ATOP_54_L, 0, 0x000F); // disable LDO overwrite
                  drvADC_Write2BytesMask(REG_ADC_ATOP_54_L, 0xF800, 0xF800); // [15]:ADC VCAL force enable, [14:11]: set
             - Vcal = 1.05V, 
              #else
1682   1          drvADC_Write2BytesMask(REG_ADC_ATOP_34_L, BIT0, BIT0); // turn on LDO
1683   1          drvADC_Write2BytesMask(REG_ADC_ATOP_34_L, BIT2, BIT2); // LDO
1684   1          drvADC_Write2BytesMask(REG_ADC_ATOP_54_L, 0x0003, 0x0003); // set Vcal = 1.05V
1685   1          drvADC_Write2BytesMask(REG_ADC_ATOP_54_L, 0x000C, 0x000C); // set Vcal from LDO
1686   1          drvADC_Write2BytesMask(REG_ADC_ATOP_54_L, 0, 0xF800); // disable bandgap overwrite
1687   1      #endif // DADCCALBYBANDGAP
1688   1          // Turn on self Gcal pulse
1689   1          drvADC_Write2BytesMask(REG_ADC_ATOP_54_L, 0x0600, 0x0700); // [10:8]: 3'b 110, reg_rgb_self_gcal_pulse
             -_sw
1690   1      
1691   1          // 2. Enable ADC data high Vcal accumulator
1692   1          drvADC_Write2BytesMask(REG_ADC_ATOP_55_L, 0x0040, 0x0040);
1693   1      
1694   1          ForceDelay1ms(1); // delay 1 msec
1695   1      
1696   1          // 3. Trigger ADC data high Vcal accumulator start
1697   1          drvADC_Write2BytesMask(REG_ADC_ATOP_55_L, 0x0100, 0x0100);
1698   1      
1699   1          // 4. Wait ADC data accumulation done, ADC_ATO_74_L[2:0] = 3'b 111
1700   1          while ((wTimeOutCnt>0) && (!(drvADC_ReadByte(REG_ADC_ATOP_74_L) & 0x07)))
1701   1          {
1702   2              wTimeOutCnt--;
1703   2          }
1704   1          if(wTimeOutCnt == 0)
1705   1              ADC_DPUTSTR("ADC data high accumulation time out\n");
1706   1      
1707   1          // 5. Select Vcal 0.55V
1708   1      #if DADCCALBYBANDGAP
C51 COMPILER V9.60.0.0   DRVADC                                                            12/22/2020 19:50:39 PAGE 30  

                  drvADC_Write2BytesMask(REG_ADC_ATOP_54_L, 0xD800, 0xF800); // [15]:ADC VCAL force enable, [14:11]: set
             - Vcal = 0.55V, 
              #else
1711   1          drvADC_Write2BytesMask(REG_ADC_ATOP_54_L, 0x0002, 0x0003); // reg_rgb_cal_ldo_sel_sw
1712   1      #endif // DADCCALBYBANDGAP
1713   1      
1714   1          // 6. Disable ADC data high Vcal accumulator & Enable ADC data low Vcal accumulator
1715   1          drvADC_Write2BytesMask(REG_ADC_ATOP_55_L, 0x0000, 0x0040);
1716   1          drvADC_Write2BytesMask(REG_ADC_ATOP_55_L, 0x0080, 0x0080);
1717   1      
1718   1          ForceDelay1ms(1); // delay 1 msec
1719   1      
1720   1          // 7. Trigger ADC data low Vcal accumulator start
1721   1          drvADC_Write2BytesMask(REG_ADC_ATOP_55_L, 0x0100, 0x0100);
1722   1      
1723   1          // 8. Wait ADC data accumulation done, ADC_ATO_74_L[2:0] = 3'b 111
1724   1          wTimeOutCnt = 300;
1725   1          while ((wTimeOutCnt>0) && (!(drvADC_ReadByte(REG_ADC_ATOP_74_L) & 0x07)))
1726   1          {
1727   2              wTimeOutCnt--;
1728   2          }
1729   1          if(wTimeOutCnt == 0)
1730   1              ADC_DPUTSTR("ADC data low accumulation time out\n");
1731   1      
1732   1          // 9. Read ADC channel 0 & 1 difference value(Vcal_high - Vcal_low)
1733   1          wRch0val = ((drvADC_ReadByte(REG_ADC_ATOP_64_H)&0x03) << 8) | drvADC_ReadByte(REG_ADC_ATOP_64_L);
1734   1          wRch1val = ((drvADC_ReadByte(REG_ADC_ATOP_67_H)&0x03) << 8) | drvADC_ReadByte(REG_ADC_ATOP_67_L);
1735   1          wGch0val = ((drvADC_ReadByte(REG_ADC_ATOP_6A_H)&0x03) << 8) | drvADC_ReadByte(REG_ADC_ATOP_6A_L);
1736   1          wGch1val = ((drvADC_ReadByte(REG_ADC_ATOP_6D_H)&0x03) << 8) | drvADC_ReadByte(REG_ADC_ATOP_6D_L);
1737   1          wBch0val = ((drvADC_ReadByte(REG_ADC_ATOP_70_H)&0x03) << 8) | drvADC_ReadByte(REG_ADC_ATOP_70_L);
1738   1          wBch1val = ((drvADC_ReadByte(REG_ADC_ATOP_73_H)&0x03) << 8) | drvADC_ReadByte(REG_ADC_ATOP_73_L);
1739   1      
1740   1      #if 0
                  // Aaron test
                  wRch0val = 3;
                  wRch1val = 5;
                  wGch0val = 2010;
                  wGch1val = 1888;
                  wBch0val = 1000;
                  wBch1val = 1000;
              #endif
1749   1      
1750   1          // 10. Set ADC compensated codes (1.10)
1751   1      #if DADCNEWGAINCALMETHOD == 1
              
                  // target code : 1024 * 0.5 / 0.7 = 731
                  //wTargetCode = 731;
                  // target code : (1024-32) * 0.5 / 0.7 = 708
                  wTargetCode = 708;
              
                  //ADC_DPRINTF("Target Code = %d\n", wTargetCode);
                  // R-ch
                  wRch0Div = ((wTargetCode / wRch0val) << 10) | (WORD)(((DWORD)(wTargetCode%wRch0val)<<10)/wRch0val);
                  wRch1Div = ((wTargetCode / wRch1val) << 10) | (WORD)(((DWORD)(wTargetCode%wRch1val)<<10)/wRch1val);
                  // G-ch
                  wGch0Div = ((wTargetCode / wGch0val) << 10) | (WORD)(((DWORD)(wTargetCode%wGch0val)<<10)/wGch0val);
                  wGch1Div = ((wTargetCode / wGch1val) << 10) | (WORD)(((DWORD)(wTargetCode%wGch1val)<<10)/wGch1val);
                  // B-ch
                  wBch0Div = ((wTargetCode / wBch0val) << 10) | (WORD)(((DWORD)(wTargetCode%wBch0val)<<10)/wBch0val);
                  wBch1Div = ((wTargetCode / wBch1val) << 10) | (WORD)(((DWORD)(wTargetCode%wBch1val)<<10)/wBch1val);
              
              #elif DADCNEWGAINCALMETHOD == 2
C51 COMPILER V9.60.0.0   DRVADC                                                            12/22/2020 19:50:39 PAGE 31  

              
                  #if (CHIP_ID == CHIP_TSUMF)
              
                  // ADC PGA gain:
                  //  00: 1.0 / 01: 1.2 / 10: 0.8 / 11: 0.96
                  //  target code : (1024-32)*0.5/PGA gain
                  switch(UserPrefAdcPgaGain)
                  {
                      case 0x00:
                          wTargetCode = 496;
                          break;
                      case 0x15:
                          wTargetCode = 413;
                          break;
                      case 0x2A:
                          wTargetCode = 620;
                          break;
                      case 0x3F:
                          wTargetCode = 516;
                          break;
                      default:
                          break;
                  }
              
                  #else
                
                  // ADC PGA gain:
                  //  00: 0.861538 / 01: 0.969231 / 10: 1.076923 / 11: 1.184615
                  //  target code : (1024-32)*0.5/PGA gain
                  switch(UserPrefAdcPgaGain)
                  {
                      case 0x00:
                          wTargetCode = 576;
                          break;
                      case 0x15:
                          wTargetCode = 512;
                          break;
                      case 0x2A:
                          wTargetCode = 461;
                          break;
                      case 0x3F:
                          wTargetCode = 419;
                          break;
                      default:
                          break;
                  }
                
                  #endif // #if (CHIP_ID == CHIP_TSUMF) 
                  
                  //ADC_DPRINTF("Target Code = %d\n", wTargetCode);
                  // R-ch
                  wRch0Div = ((wTargetCode / wRch0val) << 10) | (WORD)(((DWORD)(wTargetCode%wRch0val)<<10)/wRch0val);
                  wRch1Div = ((wTargetCode / wRch1val) << 10) | (WORD)(((DWORD)(wTargetCode%wRch1val)<<10)/wRch1val);
                  // G-ch
                  wGch0Div = ((wTargetCode / wGch0val) << 10) | (WORD)(((DWORD)(wTargetCode%wGch0val)<<10)/wGch0val);
                  wGch1Div = ((wTargetCode / wGch1val) << 10) | (WORD)(((DWORD)(wTargetCode%wGch1val)<<10)/wGch1val);
                  // B-ch
                  wBch0Div = ((wTargetCode / wBch0val) << 10) | (WORD)(((DWORD)(wTargetCode%wBch0val)<<10)/wBch0val);
                  wBch1Div = ((wTargetCode / wBch1val) << 10) | (WORD)(((DWORD)(wTargetCode%wBch1val)<<10)/wBch1val);
              
              #else
1831   1      
C51 COMPILER V9.60.0.0   DRVADC                                                            12/22/2020 19:50:39 PAGE 32  

1832   1          // R-ch
1833   1          if(wRch0val > wRch1val)
1834   1          {
1835   2              if((wRch0val / wRch1val) > 1)
1836   2              {
1837   3                  wRch1Div = 0x0400; // ratio is 1, 1<<10
1838   3                  //ADC_DPRINTF("drvADC_MismatchGainCal: ADC Rch1 overflow = %f\n", (float)wRch0val/wRch1val);
1839   3              }
1840   2              else
1841   2              {
1842   3                  wRch1Div = ((wRch0val / wRch1val) << 10) | (WORD)(((DWORD)(wRch0val%wRch1val)<<10)/wRch1val);
1843   3              }
1844   2              wRch0Div = 0x0400; // ratio is 1, 1<<10
1845   2          }
1846   1          else if (wRch0val < wRch1val)
1847   1          {
1848   2              if((wRch1val / wRch0val) > 1)
1849   2              {
1850   3                  wRch0Div = 0x0400; // ratio is 1, 1<<10
1851   3                  //ADC_DPRINTF("drvADC_MismatchGainCal: ADC Rch0 overflow = %f\n", (float)wRch1val/wRch0val);
1852   3              }
1853   2              else
1854   2              {
1855   3                  wRch0Div = ((wRch1val / wRch0val) << 10) | (WORD)(((DWORD)(wRch1val%wRch0val)<<10)/wRch0val);
1856   3              }
1857   2              wRch1Div = 0x0400;
1858   2          }
1859   1          else // wRch0val = wRch1val
1860   1          {
1861   2              wRch0Div = 0x0400;
1862   2              wRch1Div = 0x0400;
1863   2              //ADC_DPUTSTR("ADC R Ch 0 and ch1's gain Componsated code are equal\n");
1864   2          }
1865   1          // G-ch
1866   1          if(wGch0val > wGch1val)
1867   1          {
1868   2              if((wGch0val / wGch1val) > 1)
1869   2              {
1870   3                  wGch1Div = 0x0400; // ratio is 1, 1<<10
1871   3                  //ADC_DPRINTF("drvADC_MismatchGainCal: ADC Gch1 overflow = %f\n", (float)wGch0val/wGch1val);
1872   3              }
1873   2              else
1874   2              {
1875   3                  wGch1Div = ((wGch0val / wGch1val) << 10) | (WORD)(((DWORD)(wGch0val%wGch1val)<<10)/wGch1val);
1876   3              }
1877   2              wGch0Div = 0x0400;
1878   2          }
1879   1          else if (wGch0val < wGch1val)
1880   1          {
1881   2              if((wGch1val / wGch0val) > 1)
1882   2              {
1883   3                  wGch0Div = 0x0400; // ratio is 1, 1<<10
1884   3                  //ADC_DPRINTF("drvADC_MismatchGainCal: ADC Gch0 overflow = %f\n", (float)wGch1val/wGch0val);
1885   3              }
1886   2              else
1887   2              {
1888   3                  wGch0Div = ((wGch1val / wGch0val) << 10) | (WORD)(((DWORD)(wGch1val%wGch0val)<<10)/wGch0val);
1889   3              }
1890   2              wGch1Div = 0x0400;
1891   2          }
1892   1          else // wGch0val = wGch1val
1893   1          {
C51 COMPILER V9.60.0.0   DRVADC                                                            12/22/2020 19:50:39 PAGE 33  

1894   2              wGch0Div = 0x0400;
1895   2              wGch1Div = 0x0400;
1896   2          }
1897   1          // B-ch
1898   1          if(wBch0val > wBch1val)
1899   1          {
1900   2              if((wBch0val / wBch1val) > 1)
1901   2              {
1902   3                  wBch1Div = 0x0400; // ratio is 1, 1<<10
1903   3                  //ADC_DPRINTF("drvADC_MismatchGainCal: ADC Bch1 overflow = %f\n", (float)wBch0val/wBch1val);
1904   3              }
1905   2              else
1906   2              {
1907   3                  wBch1Div = ((wBch0val / wBch1val) << 10) | (WORD)(((DWORD)(wBch0val%wBch1val)<<10)/wBch1val);
1908   3              }
1909   2              wBch0Div = 0x0400;
1910   2          }
1911   1          else if (wBch0val < wBch1val)
1912   1          {
1913   2              if((wBch1val / wBch0val) > 1)
1914   2              {
1915   3                  wBch0Div = 0x0400; // ratio is 1, 1<<10
1916   3                  //ADC_DPRINTF("drvADC_MismatchGainCal: ADC Bch0 overflow = %f\n", (float)wBch1val/wBch0val);
1917   3              }
1918   2              else
1919   2              {
1920   3                  wBch0Div = ((wBch1val / wBch0val) << 10) | (WORD)(((DWORD)(wBch1val%wBch0val)<<10)/wBch0val);
1921   3              }
1922   2              wBch1Div = 0x0400;
1923   2          }
1924   1          else // wBch0val = wBch1val
1925   1          {
1926   2              wBch0Div = 0x0400;
1927   2              wBch1Div = 0x0400;
1928   2          }
1929   1          
1930   1      #endif // #if DADCNEWGAINCALMETHOD
1931   1      
1932   1          gADCMismatchAvgVal.wGainVal_Rch0 += (wRch0Div & 0x07FF);
1933   1          gADCMismatchAvgVal.wGainVal_Rch1 += (wRch1Div & 0x07FF);
1934   1          gADCMismatchAvgVal.wGainVal_Gch0 += (wGch0Div & 0x07FF);
1935   1          gADCMismatchAvgVal.wGainVal_Gch1 += (wGch1Div & 0x07FF);
1936   1          gADCMismatchAvgVal.wGainVal_Bch0 += (wBch0Div & 0x07FF);
1937   1          gADCMismatchAvgVal.wGainVal_Bch1 += (wBch1Div & 0x07FF);
1938   1      #if 0
                  drvADC_Write2BytesMask(REG_ADC_ATOP_58_L, wRch0Div, 0x07FF); // Set ADC channel 0 gain compensated cod
             -e
                  drvADC_Write2BytesMask(REG_ADC_ATOP_59_L, wRch1Div, 0x07FF); // Set ADC channel 1 gain compensated cod
             -e
                  drvADC_Write2BytesMask(REG_ADC_ATOP_5C_L, wGch0Div, 0x07FF); // Set ADC channel 0 gain compensated cod
             -e
                  drvADC_Write2BytesMask(REG_ADC_ATOP_5D_L, wGch1Div, 0x07FF); // Set ADC channel 1 gain compensated cod
             -e
                  drvADC_Write2BytesMask(REG_ADC_ATOP_60_L, wBch0Div, 0x07FF); // Set ADC channel 0 gain compensated cod
             -e
                  drvADC_Write2BytesMask(REG_ADC_ATOP_61_L, wBch1Div, 0x07FF); // Set ADC channel 1 gain compensated cod
             -e
              #endif
1946   1      #if 0
                  ADC_DPRINTF("R Ch0 gain val= 0x%x", wRch0val);
                  //ADC_DPRINTF("R Ch1 gain val= 0x%x", wRch1val);
                  ADC_DPRINTF("G Ch0 gain val= 0x%x", wGch0val);
C51 COMPILER V9.60.0.0   DRVADC                                                            12/22/2020 19:50:39 PAGE 34  

                  //ADC_DPRINTF("G Ch1 gain val= 0x%x", wGch1val);
                  ADC_DPRINTF("B Ch0 gain val= 0x%x", wBch0val);
                  //ADC_DPRINTF("B Ch1 gain val= 0x%x", wBch1val);
                  ADC_DPRINTF("R Ch0 gain code= 0x%x", wRch0Div);
                  ADC_DPRINTF("R Ch1 gain code= 0x%x", wRch1Div);
                  ADC_DPRINTF("G Ch0 gain code= 0x%x", wGch0Div);
                  ADC_DPRINTF("G Ch1 gain code= 0x%x", wGch1Div);
                  ADC_DPRINTF("B Ch0 gain code= 0x%x", wBch0Div);
                  ADC_DPRINTF("B Ch1 gain code= 0x%x", wBch1Div);
              #endif
1960   1          // 11. Turn on enable gain mismatch compensated codes
1961   1          drvADC_Write2BytesMask(REG_ADC_ATOP_55_L, 0x002A, 0x00AA); // [7]: acc low disable, [5]: B mismatch ga
             -in enable, [3]: G mismatch gain enable, [1]: R mismatch gain enable,
1962   1      
1963   1          // 12. Turn off ADC offset calibration pulse
1964   1          drvADC_Write2BytesMask(REG_ADC_ATOP_54_L, 0x0000, 0xFF0F); // [15]:ADC VCAL force enable, [14:11]: set
             - Vcal, [10:8]: Turn off self Gcal pulse, [3:2]: reg_rgb_cal_trim_ldo_sel_sw, [1:0]: reg_rgb_cal_ldo_sel_sw
1965   1      }
1966          
1967          
1968          #define DGain_OverFlow_R_ch         BIT7
1969          #define DGain_NoneOverFlow_R_ch     BIT6
1970          #define DGain_OverFlow_G_ch         BIT5
1971          #define DGain_NoneOverFlow_G_ch     BIT4
1972          #define DGain_OverFlow_B_ch         BIT3
1973          #define DGain_NoneOverFlow_B_ch     BIT2
1974          #ifndef ADCRB_SWAP
1975          #define ADCRB_SWAP 0
1976          #endif
1977          #ifndef ADJ_GAIN_RATIO
1978          #define ADJ_GAIN_RATIO      1
1979          #endif
1980          //**************************************************************************
1981          //  [Function Name]:
1982          //                  drvADC_AutoAdjustAdcGain()
1983          //  [Description]:
1984          //                  Check input sync is lost or not
1985          //  [Precondition]:
1986          //                  Do auto gain adjustment with input source
1987          //  [Arguments]:
1988          //                  vsyncTime: frame rate of the current input
1989          //  [Return]:
1990          //                  TRUE: done, FALSE: fail
1991          //**************************************************************************
1992          static Bool drvADC_AutoAdjustAdcGain(BYTE u8VSyncTime)
1993          {
1994   1          WORD rGain, gGain, bGain;
1995   1          WORD maxRGain, maxGGain, maxBGain;
1996   1          WORD minRGain, minGGain, minBGain;
1997   1          BYTE retry=12;
1998   1          BYTE adcStatus;
1999   1          BYTE atgFlags=0;
2000   1      
2001   1          maxRGain=maxGGain=maxBGain=0xFFF;
2002   1          minRGain=minGGain=minBGain=0;
2003   1      
2004   1          while (retry--)
2005   1          {
2006   2              rGain=((WORD)maxRGain+minRGain)/2;
2007   2              gGain=((WORD)maxGGain+minGGain)/2;
2008   2              bGain=((WORD)maxBGain+minBGain)/2;
2009   2              drvADC_SetRGBGainCode(rGain, gGain, bGain);
C51 COMPILER V9.60.0.0   DRVADC                                                            12/22/2020 19:50:39 PAGE 35  

2010   2              Delay1ms(u8VSyncTime);
2011   2              // Wait scaler auto gain is done, SC0_78[1] = 1
2012   2              adcStatus=drvADC_WaitAutoStatusReady(SC0_78, BIT1);
2013   2              //adcStatus=msReadByte(SC0_78);
2014   2      
2015   2              if( adcStatus & BIT7 )
2016   2              {
2017   3                  rGain--;
2018   3                  atgFlags|=DGain_OverFlow_R_ch;
2019   3              }
2020   2              else
2021   2              {
2022   3                  rGain++;
2023   3                  atgFlags|=DGain_NoneOverFlow_R_ch;
2024   3              }
2025   2      
2026   2              if( adcStatus & BIT6 )
2027   2              {
2028   3                  gGain--;
2029   3                  atgFlags|=DGain_OverFlow_G_ch;
2030   3              }
2031   2              else
2032   2              {
2033   3                  gGain++;
2034   3                  atgFlags|=DGain_NoneOverFlow_G_ch;
2035   3              }
2036   2      
2037   2              if( adcStatus & BIT5 )
2038   2              {
2039   3                  bGain--;
2040   3                  atgFlags|=DGain_OverFlow_B_ch;
2041   3              }
2042   2              else
2043   2              {
2044   3                  bGain++;
2045   3                  atgFlags|=DGain_NoneOverFlow_B_ch;
2046   3              }
2047   2      
2048   2              drvADC_SetRGBGainCode(rGain, gGain, bGain);
2049   2              Delay1ms(u8VSyncTime);
2050   2              // Wait scaler auto gain is done, SC0_78[1] = 1
2051   2              adcStatus=drvADC_WaitAutoStatusReady(SC0_78, BIT1);
2052   2              //adcStatus=msReadByte(SC0_78);
2053   2      
2054   2              if( adcStatus & BIT7 )
2055   2              {
2056   3                  maxRGain=rGain+1;
2057   3                  atgFlags|=DGain_OverFlow_R_ch;
2058   3              }
2059   2              else
2060   2              {
2061   3                  minRGain=rGain-1;
2062   3                  atgFlags|=DGain_NoneOverFlow_R_ch;
2063   3              }
2064   2      
2065   2              if( adcStatus & BIT6 )
2066   2              {
2067   3                  maxGGain=gGain+1;
2068   3                  atgFlags|=DGain_OverFlow_G_ch;
2069   3              }
2070   2              else
2071   2              {
C51 COMPILER V9.60.0.0   DRVADC                                                            12/22/2020 19:50:39 PAGE 36  

2072   3                  minGGain=gGain-1;
2073   3                  atgFlags|=DGain_NoneOverFlow_G_ch;
2074   3              }
2075   2      
2076   2              if( adcStatus & BIT5 )
2077   2              {
2078   3                  maxBGain=bGain+1;
2079   3                  atgFlags|=DGain_OverFlow_B_ch;
2080   3              }
2081   2              else
2082   2              {
2083   3                  minBGain=bGain-1;
2084   3                  atgFlags|=DGain_NoneOverFlow_B_ch;
2085   3              }
2086   2      
2087   2              if (CheckSyncLoss())
2088   2                  return FALSE;
2089   2          }
2090   1      
2091   1          if ((atgFlags&0xFC)!=0xFC)
2092   1              return FALSE;
2093   1      
2094   1          if (rGain>4000 || gGain>4000 || bGain>4000) //Jison 101029
2095   1              return FALSE;
2096   1      
2097   1      #if 0  //Steven101220
                  UserPrefAdcRedGain = ((DWORD)rGain-1)*(100+ADJ_GAIN_RATIO)/100;
                  UserPrefAdcGreenGain = ((DWORD)gGain-1)*(100+ADJ_GAIN_RATIO)/100;
                  UserPrefAdcBlueGain = ((DWORD)bGain-1)*(100+ADJ_GAIN_RATIO)/100;
              #else
2102   1          UserPrefAdcRedGain  = rGain-1;
2103   1          UserPrefAdcGreenGain = gGain-1;
2104   1          UserPrefAdcBlueGain = bGain-1;
2105   1      #endif
2106   1          drvADC_SetRGBGainCode(UserPrefAdcRedGain, UserPrefAdcGreenGain, UserPrefAdcBlueGain);
2107   1      
2108   1          return TRUE;
2109   1      }
2110          
2111          static void drvADC_SetPGAGainCode(BYTE ucAdcPgaGain)  //Steven110329, Solve check PGA gain issue.
2112          {
2113   1          drvADC_Write2BytesMask(REG_ADC_DTOP_55_L, ucAdcPgaGain, 0x03F);
2114   1      }
2115          
2116          //**************************************************************************
2117          //  [Function Name]:
2118          //                  drvADC_CheckPGAGain()
2119          //  [Description]:
2120          //                  Check input signal is over PGA gain or not
2121          //  [Precondition]:
2122          //                  00: 1.0V, 01: 1.2V, 10: 0.8V, 11: 0.96V  => TSUMF
2123          //                  00: 0.8V, 01: 0.9V, 10: 1.0V, 11: 1.1V
2124          //                  The default PGA gain in Rose is 0.8V. To avoid the input signal is over 0.8V, this fun
             -ction is used to
2125          //                  detect and adjust PGA gain. The maximum PGA gain would be limited in 1.0V
2126          //  [Arguments]:
2127          //                  vsyncTime: frame rate of the current input
2128          //  [Return]:
2129          //                  TRUE: done, FALSE: fail
2130          //**************************************************************************
2131          static BYTE drvADC_CheckPGAGain(BYTE vsyncTime)
2132          {
C51 COMPILER V9.60.0.0   DRVADC                                                            12/22/2020 19:50:39 PAGE 37  

2133   1          BYTE u8CurPGA, adcStatus;
2134   1      
2135   1      #if (CHIP_ID == CHIP_TSUMF)
                  u8CurPGA = 0x2A;
              #else
2138   1          u8CurPGA = 0x00;
2139   1      #endif //#if (CHIP_ID == CHIP_TSUMF)
2140   1      
2141   1          drvADC_Write2BytesMask(REG_ADC_DTOP_55_L, u8CurPGA, 0x003F);
2142   1          msWriteByteMask(SC0_78, BIT3, BIT3); // output is overflow or underflow result
2143   1          Delay1ms(vsyncTime);
2144   1          // Wait scaler auto gain is done, BK0_78[1] = 1
2145   1          adcStatus=drvADC_WaitAutoStatusReady( SC0_78, BIT1 );
2146   1          ADC_DPRINTF("adcStatus = 0x%x\n", adcStatus);
2147   1          ADC_DPRINTF("--adcStatus = 0x%x\n", msReadByte(REG_ADC_DTOP_55_L) & 0x3F);
2148   1      
2149   1          while( adcStatus & ( BIT5 | BIT6 | BIT7 ) )
2150   1          {
2151   2      #if (CHIP_ID == CHIP_TSUMF)
                      if(u8CurPGA == 0x00) // limited the maxi VPP = 1.0V
                          break;
                      else
                      {
                          u8CurPGA = ((u8CurPGA == 0x3F) ? 0x00 : (u8CurPGA+0x15));
                          drvADC_Write2BytesMask( REG_ADC_DTOP_55_L, u8CurPGA, 0x003F );
                          Delay1ms(vsyncTime);
                          // Wait scaler auto gain is done, SC0_78[1] = 1
                          adcStatus=drvADC_WaitAutoStatusReady( SC0_78, BIT1 );
                          //adcStatus=msReadByte(SC0_78);
                      }
              #else
2164   2              if(u8CurPGA == 0x2A) // limited the maxi VPP = 1.0V
2165   2                  break;
2166   2              else
2167   2              {
2168   3                  u8CurPGA += 0x15;
2169   3                  drvADC_Write2BytesMask( REG_ADC_DTOP_55_L, u8CurPGA, 0x003F );
2170   3                  Delay1ms(vsyncTime);
2171   3                  // Wait scaler auto gain is done, SC0_78[1] = 1
2172   3                  adcStatus=drvADC_WaitAutoStatusReady( SC0_78, BIT1 );
2173   3                  //adcStatus=msReadByte(SC0_78);
2174   3              }
2175   2      #endif // #if (CHIP_ID == CHIP_TSUMF)
2176   2              ADC_DPRINTF("adcStatus = 0x%x\n", adcStatus);
2177   2          }
2178   1          ADC_DPRINTF("PGA Gain = 0x%x\n", u8CurPGA);
2179   1          msWriteByteMask(SC0_78, 0, BIT3);
2180   1          return u8CurPGA;
2181   1      }
2182          
2183          #if DADCPLLPROTECTION
2184          //**************************************************************************
2185          //  [Function Name]:
2186          //                  drvADC_IsEnableFreeRun()
2187          //  [Description]:
2188          //                  Enable/Disable ADC free run mode
2189          //  [Precondition]:
2190          //                  Use to protect ADC PLL while mode changing
2191          //  [Arguments]:
2192          //                  bflag: TRUE => enable, FALSE => disable
2193          //  [Return]:
2194          //
C51 COMPILER V9.60.0.0   DRVADC                                                            12/22/2020 19:50:39 PAGE 38  

2195          //**************************************************************************
2196          static void drvADC_IsEnableFreeRun(Bool bflag)
2197          {
2198   1          TAB_Info Tab_info;
2199   1      
2200   1          Tab_info.u8TabCols = REG_ADDR_SIZE+REG_MASK_SIZE+ADC_TABLE_INIT_NUMS*REG_DATA_SIZE;
2201   1          Tab_info.u8TabIdx = 0;
2202   1          if(bflag) // enable
2203   1          {
2204   2              Tab_info.pTable = (void*)MST_ADCFreeRunEn_TBL;
2205   2              Tab_info.u8TabRows = sizeof(MST_ADCFreeRunEn_TBL)/Tab_info.u8TabCols;
2206   2          }
2207   1          else // disable
2208   1          {
2209   2              Tab_info.pTable = (void*)MST_ADCFreeRunDis_TBL;
2210   2              Tab_info.u8TabRows = sizeof(MST_ADCFreeRunDis_TBL)/Tab_info.u8TabCols;
2211   2          }
2212   1          drvADC_LoadTable(&Tab_info);
2213   1      
2214   1      #if ENABLE_XTAL_LESS
                  if(!bflag)
                  {
                      drvADC_Write2BytesMask(REG_ADC_DTOP_02_L, gADCBackupSetting.BWCoef, 0x00FF);
                      drvADC_Write2BytesMask(REG_ADC_DTOP_03_L, gADCBackupSetting.DampCoef, 0x00FF);
                  }
              #endif
2221   1      
2222   1          //ADC_DPRINTF("ADC Tbl:drvADC_IsEnableFreeRun %d\n", bflag);
2223   1      }
2224          
2225          //**************************************************************************
2226          //  [Function Name]:
2227          //                  drvADC_SetAutoProst()
2228          //  [Description]:
2229          //                  Set/Release small loop auto porst
2230          //  [Precondition]:
2231          //                  Use to protect ADC PLL while mode changing
2232          //  [Arguments]:
2233          //                  bflag: TRUE => enable, FALSE => disable
2234          //  [Return]:
2235          //
2236          //**************************************************************************
2237          static void drvADC_SetAutoProst(Bool bflag)
2238          {
2239   1          TAB_Info Tab_info;
2240   1      
2241   1          Tab_info.u8TabCols = REG_ADDR_SIZE+REG_MASK_SIZE+ADC_TABLE_INIT_NUMS*REG_DATA_SIZE;
2242   1          Tab_info.u8TabIdx = 0;
2243   1          if(bflag) // enable
2244   1          {
2245   2              Tab_info.pTable = (void*)MST_ADCPorstEn_TBL;
2246   2              Tab_info.u8TabRows = sizeof(MST_ADCPorstEn_TBL)/Tab_info.u8TabCols;
2247   2          }
2248   1          else // disable
2249   1          {
2250   2              Tab_info.pTable = (void*)MST_ADCPorstDis_TBL;
2251   2              Tab_info.u8TabRows = sizeof(MST_ADCPorstDis_TBL)/Tab_info.u8TabCols;
2252   2          }
2253   1      
2254   1          drvADC_LoadTable(&Tab_info);
2255   1      
2256   1          //ADC_DPRINTF("ADC Tbl:drvADC_SetAutoProst %d\n", bflag);
C51 COMPILER V9.60.0.0   DRVADC                                                            12/22/2020 19:50:39 PAGE 39  

2257   1      }
2258          #endif // #ifdef DADCPLLPROTECTION
2259          
2260          
2261          #ifdef _DGAIN_CAL_WITHOUT_INPUT_ //????
              //**************************************************************************
              //  [Function Name]:
              //                  drvADC_EnableScalerPG()
              //  [Description]:
              //                  Enable Scaler pattern generatot to generate Htotal = 256/512/1024/2048 and Vtotal=64(f
             -ixed)
              //  [Precondition]:
              //
              //  [Arguments]:
              //
              //                  ht_sel: 0:256, 1:512, 2:1024, 3:2048
              //  [Return]:
              //
              //**************************************************************************
              static void drvADC_EnableScalerPG(msADCScalerPG_HtotalSel ht_sel)
              {
                  WORD whact;
              
                  //msWriteByteMask(SC0_02, 0x00, 0x80); // disable free-run
                  msWriteByteMask(SC0_01, 0, 0x01); // disable double buffer
                  msWriteByteMask(SC0_02, 0x00|BIT2, 0x07); // [2]:use Hsync only, [1:0]:ISEL = analog1
                  msWrite2Byte(SC0_07, 0x0010); // SPRHST = 0x10
                  whact = 256*(ht_sel+1) - 16;
                  msWrite2ByteMask(SC0_0B, whact,SC_MASK_H); // SPRHDC = htsel - 0x10
                  // Vtotal is 64 lines, Vstart = 0x10, Vactive = 0x30
                  msWrite2Byte(SC0_05, 0x0010); // SPRVST = 0x10
                  msWrite2ByteMask(SC0_09, 0x0030,SC_MASK_V); // SPRVDC = 0x30
              #if (CHIP_ID == CHIP_TSUMU)
                  msWriteByteMask(SC0_63, (ht_sel<<6)|0x30, 0xF0); //[7:6]: Htotal, [5]: Enable PG's Hsync/Vsync/Hde/Vde
             - to IP, [4]: Pattern gen engine enable
              #elif (CHIP_ID == CHIP_TSUMV || CHIP_ID == CHIP_TSUM2 || CHIP_ID==CHIP_TSUMB || CHIP_ID==CHIP_TSUMY) //
                  msWriteByteMask(REG_2E42, ht_sel<<1|0x19, 0x1F); // Rosen: [4]: No input ADC calibration enable, [3]: 
             -Enable PG's Hsync/Vsync/Hde/Vde to IP, [2:1]: Htotal, [0]: Pattern gen engine enable
              #elif ((CHIP_ID == CHIP_TSUMC) || (CHIP_ID==CHIP_TSUMK) || (CHIP_ID == CHIP_TSUMD) || (CHIP_ID == CHIP_TSU
             -MJ) || (CHIP_ID == CHIP_TSUM9)|| (CHIP_ID == CHIP_TSUMF))
                  msWrite2ByteMask(REG_2E24, whact, 0x1FFF); // reg_hde
                  msWriteByteMask(REG_2E26, 0x05, 0xFF); // reg_hfp_w
                  msWriteByteMask(REG_2E28, 0x06, 0xFF); // reg_hsync_w
                  msWrite2ByteMask(REG_2E2A, 256*(ht_sel+1), 0x1FFF); // reg_htotal
                  msWrite2ByteMask(REG_2E2C, 0x30, 0x1FFF); // reg_vde
                  msWriteByteMask(REG_2E2E, 0x05, 0x7F); // reg_vfp_w
                  msWriteByteMask(REG_2E30, 0x06, 0x3F); // reg_vsync_w
                  msWrite2ByteMask(REG_2E32, 0x40, 0x1FFF); // reg_vtotal
                  msWrite2ByteMask(REG_2E20, BIT0, BIT0); // Timing gen enable
                  msWriteByteMask(REG_2E42, 0x18, 0x18); // Rosen: [4]: No input ADC calibration enable, [3]: Enable PG'
             -s Hsync/Vsync/Hde/Vde to IP
              #endif
              }
              
              #if 1
              //**************************************************************************
              //  [Function Name]:
              //                  _msADC_MaskExternalSync()
              //  [Description]:
              //                  Mask external sync when connecting with source
              //  [Precondition]:
              //
C51 COMPILER V9.60.0.0   DRVADC                                                            12/22/2020 19:50:39 PAGE 40  

              //  [Arguments]:
              //                 bflag: TRUE: Mask, FALSE: non-Mask
              //
              //  [Return]:
              //
              //**************************************************************************
              static void _msADC_MaskExternalSync(Bool bflag)
              {
                  if(bflag)
                      drvADC_Write2BytesMask(REG_ADC_ATOP_04_L, BIT14, BIT14); // power down Hsync_Cmp
                  else
                      drvADC_Write2BytesMask(REG_ADC_ATOP_04_L, 0, BIT14); // power on Hsync_Cmp
              }
              #endif
              
              //**************************************************************************
              //  [Function Name]:
              //                  drvADC_SetInternalVcal()
              //  [Description]:
              //                  Enable internal Vcal(0.55V or 1.05V) for gain calibration
              //  [Precondition]:
              //
              //  [Arguments]:
              //                 vcal: 0.55V / 1.05V
              //
              //  [Return]:
              //
              //**************************************************************************
              static void drvADC_SetInternalVcal(msADC_InternalVcal vcal)
              {
                  switch(vcal)
                  {
                      case E_Vcal_0_55V:
                      #if DADCCALBYBANDGAP
                          drvADC_Write2BytesMask(REG_ADC_ATOP_34_L, 0, BIT0); // turn off LDO
                          drvADC_Write2BytesMask(REG_ADC_ATOP_34_L, 0, BIT2); // Bandgap
                          drvADC_Write2BytesMask(REG_ADC_ATOP_54_L, 0, 0x000F); // disable LDO overwrite
                          drvADC_Write2BytesMask(REG_ADC_ATOP_54_L, 0xD800, 0xF800); // [15]:ADC VCAL force enable, [14:
             -11]: set Vcal = 0.55V, 
                      #else
                          drvADC_Write2BytesMask(REG_ADC_ATOP_34_L, BIT0, BIT0); // turn on LDO
                          drvADC_Write2BytesMask(REG_ADC_ATOP_34_L, BIT2, BIT2); // LDO
                          drvADC_Write2BytesMask(REG_ADC_ATOP_54_L, 0x0002, 0x0003); // set Vcal = 0.55V
                          drvADC_Write2BytesMask(REG_ADC_ATOP_54_L, 0x000C, 0x000C); // set Vcal from LDO
                          drvADC_Write2BytesMask(REG_ADC_ATOP_54_L, 0, 0xF800); // disable bandgap overwrite
                      #endif // DADCCALBYBANDGAP
                          drvADC_Write2BytesMask(REG_ADC_ATOP_54_L, 0x0600, 0x0700); // turn on Gcal pulse
                          break;
              
                      case E_Vcal_1_05V:
                      #if DADCCALBYBANDGAP
                          drvADC_Write2BytesMask(REG_ADC_ATOP_34_L, 0, BIT0); // turn off LDO
                          drvADC_Write2BytesMask(REG_ADC_ATOP_34_L, 0, BIT2); // Bandgap
                          drvADC_Write2BytesMask(REG_ADC_ATOP_54_L, 0x0000, 0x000F); // disable LDO overwrite
                          drvADC_Write2BytesMask(REG_ADC_ATOP_54_L, 0xF800, 0xF800); // [15]:ADC VCAL force enable, [14:
             -11]: set Vcal = 1.05V, 
                      #else
                          drvADC_Write2BytesMask(REG_ADC_ATOP_34_L, BIT0, BIT0); // turn on LDO
                          drvADC_Write2BytesMask(REG_ADC_ATOP_34_L, BIT2, BIT2); // LDO
                          drvADC_Write2BytesMask(REG_ADC_ATOP_54_L, 0x0003, 0x0003); // set Vcal = 1.05V
                          drvADC_Write2BytesMask(REG_ADC_ATOP_54_L, 0x000C, 0x000C); // set Vcal from LDO
                          drvADC_Write2BytesMask(REG_ADC_ATOP_54_L, 0, 0xF800); // disable bandgap overwrite
C51 COMPILER V9.60.0.0   DRVADC                                                            12/22/2020 19:50:39 PAGE 41  

                      #endif // DADCCALBYBANDGAP
                          drvADC_Write2BytesMask(REG_ADC_ATOP_54_L, 0x0600, 0x0700); // turn on Gcal pulse
                          break;
                      default:
                          break;
                  }
              }
              #endif // #ifdef _DGAIN_CAL_WITHOUT_INPUT_
2382          
2383          
2384          #if (defined(_DGAIN_CAL_WITH_INPUT_) || defined(_DGAIN_CAL_WITHOUT_INPUT_))
              //**************************************************************************
              //  [Function Name]:
              //                  drvADC_BackupScalerSetting()
              //  [Description]:
              //                  Backup scaler settings
              //  [Precondition]:
              //
              //  [Arguments]:
              //
              //  [Return]:
              //
              //**************************************************************************
              static void drvADC_BackupScalerSetting(void)
              {
                  memset(&gScalerBackupSetting, 0, sizeof(gScalerBackupSetting));
                  gScalerBackupSetting.DBuffer = msReadByte(SC0_01);
                  gScalerBackupSetting.ISEL = msReadByte( SC0_02 );
                  gScalerBackupSetting.SPRHST = msRead2Byte( SC0_07 ) & 0x07FF; //???? 0xFFF
                  gScalerBackupSetting.SPRHDC = msRead2Byte( SC0_0B ) & SC_MASK_H;
                  gScalerBackupSetting.SPRVST = msRead2Byte( SC0_05 ) & 0x07FF; //???? 0xFFF
                  gScalerBackupSetting.SPRVDC = msRead2Byte( SC0_09 ) & SC_MASK_V;
              }
              
              //**************************************************************************
              //  [Function Name]:
              //                  drvADC_RecoverScalerSetting()
              //  [Description]:
              //                  Recover scaler settings
              //  [Precondition]:
              //
              //  [Arguments]:
              //
              //  [Return]:
              //
              //**************************************************************************
              static void drvADC_RecoverScalerSetting(void)
              {
                  msWriteByteMask(SC0_01, gScalerBackupSetting.DBuffer, 0xFF);
                  msWriteByteMask( SC0_02, gScalerBackupSetting.ISEL, 0xFF );
                  msWrite2ByteMask( SC0_07, gScalerBackupSetting.SPRHST, 0x07FF ); //????
                  msWrite2ByteMask( SC0_0B, gScalerBackupSetting.SPRHDC, SC_MASK_H );
                  msWrite2ByteMask( SC0_05, gScalerBackupSetting.SPRVST, 0x07FF );  //????
                  msWrite2ByteMask( SC0_09, gScalerBackupSetting.SPRVDC, SC_MASK_V );
                  //msWriteByteMask(REG_2FC0, 0x00, 0x1F); //[4]: OSD to IP disable, [3]: disable PG's Hsync/Vsync/Hde/V
             -de to IP, [2]: Pattern gen engine disable, [1:0]: Htotal is 256
              #if ( (CHIP_ID==CHIP_TSUMB || CHIP_ID==CHIP_TSUMY) || (CHIP_ID == CHIP_TSUMU) ) //
                  msWriteByteMask( SC0_63, 0, 0xF0 ); //[7:6]: Htotal, [5]: Enable PG's Hsync/Vsync/Hde/Vde to IP, [4]: 
             -Pattern gen engine enable
              #elif (CHIP_ID == CHIP_TSUMV || CHIP_ID == CHIP_TSUM2) //
                  msWriteByteMask(REG_2E42, 0, 0x1F); // Rosen: [4]: No input ADC calibration enable, [3]: Enable PG's H
             -sync/Vsync/Hde/Vde to IP, [2:1]: Htotal, [0]: Pattern gen engine enable
C51 COMPILER V9.60.0.0   DRVADC                                                            12/22/2020 19:50:39 PAGE 42  

              #elif ((CHIP_ID == CHIP_TSUMC) || (CHIP_ID==CHIP_TSUMK) || (CHIP_ID == CHIP_TSUMD) || (CHIP_ID == CHIP_TSU
             -MJ) || (CHIP_ID == CHIP_TSUM9)|| (CHIP_ID == CHIP_TSUMF))
                  msWrite2ByteMask(REG_2E20, 0, BIT0); // Timing gen enable
                  msWriteByteMask(REG_2E42, 0, 0x18); // Rosen: [4]: No input ADC calibration enable, [3]: Enable PG's H
             -sync/Vsync/Hde/Vde to IP
              #endif
              }
              
              //**************************************************************************
              //  [Function Name]:
              //                  drvADC_IsReadLineBuffer()
              //  [Description]:
              //                  It's used to read scaler line buffer
              //  [Precondition]:
              //
              //  [Arguments]:
              //                 bflag: TRUE: reading, FALSE: recover to the normal state
              //  [Return]:
              //
              //**************************************************************************
              static Bool drvADC_IsReadLineBuffer(Bool bflag)
              {
                  Bool result=TRUE;
                  BYTE retry=5;
              
                  if(bflag)
                  {
                      msWriteByteMask( SC5_32, BIT6, BIT6 ); // latch data in line buffer
                      while(retry--)
                      {
                          ForceDelay1ms( 20 );
                          if( msReadByte( SC5_32 ) & BIT7 ) // Check ready bit for reading line buffer
                          {
                              //ADC_DPUTSTR("Line buffer ready for read\n");
                              break;
                          }
                      }
                      if(!retry)
                      {
                          result = FALSE;
                          ADC_DPUTSTR("Reading Line buffer fail !!\n");
                      }
                  }
                  else
                  {
                      msWriteByteMask( SC5_32, 0, BIT6 ); // disable latch data in line buffer
                      //ADC_DPUTSTR("Turn off reading Line buffer \n");
                  }
                  return result;
              }
              
              //                  Adjust gain to approach target value 182(8 bits) => 255 * 0.5/0.7 = 182
              //**************************************************************************
              //  [Function Name]:
              //                  drvADC_GetRGBLineBufAverageData()
              //  [Description]:
              //                  Get the average line buffer data for R/G/B gain calibration
              //                  SC5_32[4:0]31[7:0] = 0 ~ 2560(total is 2560), each has two pixels and format is follow
             -ing
              //                  SC5_35[7:0]: R0, SC5_36[7:0]: G0, SC5_37[7:0]: B0
              //                  SC5_38[7:0]: R1, SC5_39[7:0]: G1, SC5_3A[7:0]: B1
              //  [Precondition]:
C51 COMPILER V9.60.0.0   DRVADC                                                            12/22/2020 19:50:39 PAGE 43  

              //
              //  [Arguments]:
              //                 wLineBufAddress: line buffer address, it should be less than PG Htotal
              //                 LineBuf: choose one line to read, 0 ~ 3
              //                 AvgCnt: average pixel count
              //  [Return]:
              //                 msADCAvgVal: R/G/B average data
              //**************************************************************************
              static msADCAvgVal drvADC_GetRGBLineBufAverageData(WORD wLineBufAddress, BYTE LineBuf, BYTE AvgCnt)
              {
                  BYTE i;
                  WORD wAvgRdata=0, wAvgGdata=0, wAvgBdata=0;
                  msADCAvgVal pAutoAdc;
              
                  memset(&pAutoAdc, 0 , sizeof(pAutoAdc));
              
              #if (CHIP_ID==CHIP_TSUMB || CHIP_ID==CHIP_TSUMY) //
              
                  msWriteByteMask( SC5_33, ( LineBuf & 0x03 ) << 3, 0x18 ); // select to use which line buffer, 0 ~ 3
                  for (i=0; i<AvgCnt; i++)
                  {
                      if (i%2 == 0)
                      {
                          msWrite2ByteMask(SC5_31, wLineBufAddress+(i/2), 0x0FFF); // config line buffer address
                          // B
                          msWriteByteMask(SC5_33, 0, 0x07); // select B0 to read
                          wAvgBdata += msReadByte(SC5_35); //read line buffer data
                          // G
                          msWriteByteMask(SC5_33, 1, 0x07); // select G0 to read
                          wAvgGdata += msReadByte(SC5_35); //read line buffer data
                          // R
                          msWriteByteMask(SC5_33, 2, 0x07); // select R0 to read
                          wAvgRdata += msReadByte(SC5_35); //read line buffer data
                      }
                      else
                      {
                          // B
                          msWriteByteMask(SC5_33, 3, 0x07); // select B1 to read
                          wAvgBdata += msReadByte(SC5_35); //read line buffer data
                          // G
                          msWriteByteMask(SC5_33, 4, 0x07); // select G1 to read
                          wAvgGdata += msReadByte(SC5_35); //read line buffer data
                          // R
                          msWriteByteMask(SC5_33, 5, 0x07); // select R1 to read
                          wAvgRdata += msReadByte(SC5_35); //read line buffer data
                      }
                  }
              
              #elif (CHIP_ID == CHIP_TSUMU) //
              
                  msWriteByteMask( SC5_33, ( LineBuf & 0x03 ) << 3, 0x18 ); // select to use which line buffer, 0 ~ 3
                  if(AvgCnt == 1)
                  {
                      msWrite2ByteMask( SC5_31, wLineBufAddress, 0x1FFF ); // config line buffer address
                      wAvgRdata = msReadByte( SC5_35 ); //read R0 line buffer data
                      wAvgGdata = msReadByte( SC5_36 ); //read G0 line buffer data
                      wAvgBdata = msReadByte( SC5_37 ); //read B0 line buffer data    
                  }
                  else
                  {
                      for( i = 0; i < AvgCnt/2; i++ )
                      {
C51 COMPILER V9.60.0.0   DRVADC                                                            12/22/2020 19:50:39 PAGE 44  

                          msWrite2ByteMask( SC5_31, wLineBufAddress + ( i / 2 ), 0x1FFF ); // config line buffer address
                          wAvgRdata = wAvgRdata + msReadByte( SC5_35 ) + msReadByte( SC5_38 ); //read R0+R1 line buffer 
             -data
                          wAvgGdata = wAvgGdata + msReadByte( SC5_36 ) + msReadByte( SC5_39 ); //read G0+G1 line buffer 
             -data
                          wAvgBdata = wAvgBdata + msReadByte( SC5_37 ) + msReadByte( SC5_3A ); //read B0+B1 line buffer 
             -data
                      }
                  }
              
              #elif (CHIP_ID == CHIP_TSUMV || CHIP_ID == CHIP_TSUM2 || CHIP_ID == CHIP_TSUMC || CHIP_ID==CHIP_TSUMK || C
             -HIP_ID == CHIP_TSUMD || CHIP_ID == CHIP_TSUMJ || (CHIP_ID == CHIP_TSUM9)|| (CHIP_ID == CHIP_TSUMF)) //
              
                  for( i = 0; i < AvgCnt; i++ )
                  {
                      msWrite2ByteMask( SC5_31, LineBuf*1500+wLineBufAddress + ( i / 3 ), 0x7FF ); // config line buffer
             - address
                      msWriteByteMask( SC5_33, i%3, 0x03 ); // [1:0] : LB packed pixel selection, 00: 1st pixel, 01: 2nd
             - pixel, 10: 3rd pixel
                      wAvgRdata += msReadByte( SC5_35 ); //read R0 line buffer data
                      wAvgGdata += msReadByte( SC5_36 ); //read G0 line buffer data
                      wAvgBdata += msReadByte( SC5_37 ); //read B0 line buffer data
                  }
              
              #endif
              
                  pAutoAdc.AVG_Bch = wAvgBdata/AvgCnt;
                  pAutoAdc.AVG_Gch = wAvgGdata/AvgCnt;
                  pAutoAdc.AVG_Rch = wAvgRdata/AvgCnt;
              
                  return pAutoAdc;
              }
              
              #endif // #if (defined(_DGAIN_CAL_WITH_INPUT_) || defined(_DGAIN_CAL_WITHOUT_INPUT_))
2582          
2583          #ifdef _DGAIN_CAL_WITHOUT_INPUT_
              //**************************************************************************
              //  [Function Name]:
              //                  drvADC_AutoGainAdjustment()
              //  [Description]:
              //                  Adjust gain to approach target value 182(8 bits) => 255 * 0.5/0.7 = 182
              //  [Precondition]:
              //
              //  [Arguments]:
              //
              //  [Return]:
              //                  status
              //**************************************************************************
              static Bool drvADC_AutoGainAdjustment(void)
              {
                  xdata BYTE retry=11;
                  xdata BYTE CheckFlag=0x00;
                  xdata BYTE Diff;
                  xdata msADCAvgVal pAutoAdc_1_05V;
                  xdata msADCAvgVal pAutoAdc_0_55V;
                  xdata WORD InitADCGainVal = 0x0400;
                  xdata WORD rGain = InitADCGainVal;
                  xdata WORD gGain = InitADCGainVal;
                  xdata WORD bGain = InitADCGainVal;
                  xdata WORD GainOffset_R = InitADCGainVal >> 1;
                  xdata WORD GainOffset_G = InitADCGainVal >> 1;
                  xdata WORD GainOffset_B = InitADCGainVal >> 1;
C51 COMPILER V9.60.0.0   DRVADC                                                            12/22/2020 19:50:39 PAGE 45  

                  xdata BYTE Direction_R = 0;
                  xdata BYTE Direction_G = 0;
                  xdata BYTE Direction_B = 0;
              
              
                  // 5. Calibrate ADC R/G/B gain setting value
                  // Set R/G/B gain initial setting value at 0x0400
                  drvADC_Write2BytesMask(REG_ADC_DTOP_45_L, InitADCGainVal, 0x0FFF);
                  drvADC_Write2BytesMask(REG_ADC_DTOP_48_L, InitADCGainVal, 0x0FFF);
                  drvADC_Write2BytesMask(REG_ADC_DTOP_51_L, InitADCGainVal, 0x0FFF);
                  // Set ADC R/G/B Black and offset level to 0.8V(511)
                  drvADC_Write2BytesMask(REG_ADC_DTOP_44_L, 0x01FF, 0x03FF);
                  drvADC_Write2BytesMask(REG_ADC_DTOP_47_L, 0x01FF, 0x03FF);
                  drvADC_Write2BytesMask(REG_ADC_DTOP_50_L, 0x01FF, 0x03FF);
                  drvADC_Write2BytesMask(REG_ADC_DTOP_46_L, 0x01FF, 0x07FF);
                  drvADC_Write2BytesMask(REG_ADC_DTOP_49_L, 0x01FF, 0x07FF);
                  drvADC_Write2BytesMask(REG_ADC_DTOP_52_L, 0x01FF, 0x07FF);
              
                  // 6. Gain calibration target value for RGB color space mode is 182 (8bit data) 255 * 0.5 / 0.7 = 182
                  // 7. Get the ADC digital output with Turn-On LDO and Set VCAL to 1.05v
                  // 8. Get the ADC digital output with VCAL to 0.55v
                  // 9. Calculate the difference between 1.05V and 0.55V of these 3 channels.
                  //    Compare the difference value with target value (182 at RGB color space) to adjust R/G/B channel 
             -gain register
                  //_msADC_MaskExternalSync(TRUE);
              
                  while (retry--)
                  {
                      // Vcal = 1.05V
                      drvADC_SetInternalVcal(E_Vcal_1_05V);
                      ForceDelay1ms(16);
                      drvADC_IsReadLineBuffer(TRUE);
                      pAutoAdc_1_05V = drvADC_GetRGBLineBufAverageData(0x40, 0, 32); // (2*line buffer address + average
             - data) < SPRHDC: (2*64+32) < 240
                      drvADC_IsReadLineBuffer(FALSE);
                      // Vcal = 0.55V
                      drvADC_SetInternalVcal(E_Vcal_0_55V);
                      ForceDelay1ms(16);
                      drvADC_IsReadLineBuffer(TRUE);
                      pAutoAdc_0_55V = drvADC_GetRGBLineBufAverageData(0x40, 0, 32); // (2*line buffer address + average
             - data) < SPRHDC: (2*64+32) < 240
                      drvADC_IsReadLineBuffer(FALSE);
              
                      if ( (CheckFlag & BIT0) == 0 ) // Check Rch gain is approached target value or not
                      {
                          Diff = pAutoAdc_1_05V.AVG_Rch - pAutoAdc_0_55V.AVG_Rch;
                          //ADC_DPRINTF("R gain Diff value=%d\n", Diff);
                          if( (Diff >= AUTO_GAIN_RGB_MINVAL) && (Diff <= AUTO_GAIN_RGB_MAXVAL) )
                          {
                              CheckFlag|=BIT0; // Rch is calibrated completely
                              //ADC_DPUTSTR("Rch auto gain complete!!\n");
                          }
                          else
                          {
                              if (Diff < AUTO_GAIN_RGB_MINVAL )
                              {
                                  rGain += GainOffset_R;
                                  if ( retry == 2)
                                  {
                                      Direction_R = 1; //DownToUp
                                  }
                              }
C51 COMPILER V9.60.0.0   DRVADC                                                            12/22/2020 19:50:39 PAGE 46  

                              else   //(u16Diff>AUTO_GAIN_MAX )
                              {
                                  rGain-=GainOffset_R;
                                  if ( retry == 2)
                                  {
                                      Direction_R = 2; //DownToUp
                                  }
                              }
                              GainOffset_R=GainOffset_R>>1;
                          }
                      }
                      if ( (CheckFlag & BIT1) == 0x00 ) // Check Gch gain is approached target value or not
                      {
                          Diff = pAutoAdc_1_05V.AVG_Gch - pAutoAdc_0_55V.AVG_Gch;
                          //ADC_DPRINTF("G gain Diff value=%d\n", Diff);
                          if( (Diff >= AUTO_GAIN_RGB_MINVAL) && (Diff <= AUTO_GAIN_RGB_MAXVAL) )
                          {
                              CheckFlag|=BIT1;
                              //ADC_DPUTSTR("Gch auto gain complete !!\n");
                          }
                          else
                          {
                              if (Diff< AUTO_GAIN_RGB_MINVAL )
                              {
                                  gGain+=GainOffset_G;
                                  if ( retry == 2)
                                  {
                                      Direction_G = 1; //DownToUp
                                  }
                              }
                              else   //(u16Diff>AUTO_GAIN_MAX )
                              {
                                 gGain-=GainOffset_G;
                                 if ( retry == 2)
                                 {
                                     Direction_G = 2; //DownToUp
                                 }
                              }
                              GainOffset_G=GainOffset_G>>1;
                          }
                      }
                      if ( (CheckFlag & BIT2) == 0x00 )
                      {
                          Diff = pAutoAdc_1_05V.AVG_Bch - pAutoAdc_0_55V.AVG_Bch;
                          //ADC_DPRINTF("B gain Diff value=%d\n", Diff);
                          if( (Diff >= AUTO_GAIN_RGB_MINVAL) && (Diff <= AUTO_GAIN_RGB_MAXVAL) )
                          {
                              CheckFlag|=BIT2;
                              //ADC_DPUTSTR("Bch auto gain complete !!\n");
                          }
                          else
                          {
                              if (Diff< AUTO_GAIN_RGB_MINVAL )
                              {
                                  bGain+=GainOffset_B;
                                  if ( retry == 2)
                                  {
                                      Direction_B = 1; //DownToUp
                                  }
                              }
                              else   //(u16Diff>AUTO_GAIN_MAX )
                              {
C51 COMPILER V9.60.0.0   DRVADC                                                            12/22/2020 19:50:39 PAGE 47  

                                  bGain-=GainOffset_B;
                                  if ( retry == 2)
                                  {
                                      Direction_B = 2; //DownToUp
                                  }
                              }
                              GainOffset_B=GainOffset_B>>1;
                          }
                      }
                      if(retry==1)
                      {
                          if (Direction_R == 1)
                          {
                              rGain-=1;
                          }
                          else if (Direction_R == 2)
                          {
                              rGain+=1;
                          }
                          if (Direction_G == 1)
                          {
                              gGain-=1;
                          }
                          else if (Direction_G == 2)
                          {
                              gGain+=1;
                          }
                          if (Direction_B == 1)
                          {
                              bGain-=1;
                          }
                          else if (Direction_B == 2)
                          {
                              bGain+=1;
                          }
                          drvADC_Write2BytesMask(REG_ADC_DTOP_45_L, rGain, 0x0FFF);
                          drvADC_Write2BytesMask(REG_ADC_DTOP_48_L, gGain, 0x0FFF);
                          drvADC_Write2BytesMask(REG_ADC_DTOP_51_L, bGain, 0x0FFF);
                      }
                      else
                      {
                          drvADC_Write2BytesMask(REG_ADC_DTOP_45_L, rGain, 0x0FFF);
                          drvADC_Write2BytesMask(REG_ADC_DTOP_48_L, gGain, 0x0FFF);
                          drvADC_Write2BytesMask(REG_ADC_DTOP_51_L, bGain, 0x0FFF);
                      }
                      if((CheckFlag&0x07)==0x07)
                          break;
                  }
              
                  if ((CheckFlag&0x07)==0x07)
                  {
                      ADC_DPUTSTR("Auto gain OK");
                      UserPrefAdcRedGain = rGain;
                      UserPrefAdcGreenGain = gGain;
                      UserPrefAdcBlueGain = bGain;
                      ADC_DPRINTF("Rgain = 0x%x", rGain);
                      ADC_DPRINTF("Ggain = 0x%x", gGain);
                      ADC_DPRINTF("Bgain = 0x%x", bGain);
                      return TRUE;
                  }
                  else
                  {
C51 COMPILER V9.60.0.0   DRVADC                                                            12/22/2020 19:50:39 PAGE 48  

                      ADC_DPUTSTR("Auto gain fail !!\n");
                      ADC_DPRINTF("Rgain = 0x%x", rGain);
                      ADC_DPRINTF("Ggain = 0x%x", gGain);
                      ADC_DPRINTF("Bgain = 0x%x", bGain);
                      return FALSE;
                  }
              }
              
              #endif // #ifdef(_DGAIN_CAL_WITHOUT_INPUT_)
2802          
2803          #ifdef _DGAIN_CAL_WITH_INPUT_
              //**************************************************************************
              //  [Function Name]:
              //                  drvADC_FindWhiteRegion()
              //  [Description]:
              //                  Find the white region in line buffer
              //  [Precondition]:
              //
              //  [Arguments]:
              //                 LineBuf: choose one line to read, 0 ~ 3
              //                 Step: comparsion step
              //  [Return]:
              //                  status
              //**************************************************************************
              static WORD drvADC_FindWhiteRegion(BYTE LineBuf, BYTE Step)
              {
                  BYTE i, eqcount=0;
                  msADCAvgVal pAutoAdc_val, pAutoAdc_preval;
                  WORD wStartAdd_White = 0;
              
                  pAutoAdc_preval.AVG_Rch = pAutoAdc_preval.AVG_Gch = pAutoAdc_preval.AVG_Bch = 0;
              
                  drvADC_IsReadLineBuffer(TRUE);
                  for(i=0;i<255;i++)
                  {
                      pAutoAdc_val = drvADC_GetRGBLineBufAverageData(wStartAdd_White+(i*Step), LineBuf, 1); // (2*line b
             -uffer address + average data) < SPRHDC: (2*64+32) < 240
                      if(pAutoAdc_preval.AVG_Gch > (pAutoAdc_val.AVG_Gch + 5))
                      {
                          pAutoAdc_val = drvADC_GetRGBLineBufAverageData(wStartAdd_White+(i*Step)+2, LineBuf, 1);
                          if(pAutoAdc_preval.AVG_Gch > (pAutoAdc_val.AVG_Gch + 5))
                          {
                              pAutoAdc_val = drvADC_GetRGBLineBufAverageData(wStartAdd_White+(i*Step)+4, LineBuf, 1);   
             -       
                              if(pAutoAdc_preval.AVG_Gch > (pAutoAdc_val.AVG_Gch + 5))
                              {   
                                  if(eqcount>=1)
                                      i -= (eqcount > 1 ? (eqcount/2) : 1);
                                  wStartAdd_White += ((i-1)*Step);
                                  ADC_DPRINTF("@@ pre_val = %d", pAutoAdc_val.AVG_Gch);
                                  break;
                              }
                          }
                          eqcount = 0;
                          pAutoAdc_preval.AVG_Rch = pAutoAdc_val.AVG_Rch;
                          pAutoAdc_preval.AVG_Gch = pAutoAdc_val.AVG_Gch;
                          pAutoAdc_preval.AVG_Bch = pAutoAdc_val.AVG_Bch;
                      }
                      else if( (abs(pAutoAdc_preval.AVG_Rch -pAutoAdc_val.AVG_Rch) <=2) && (abs(pAutoAdc_preval.AVG_Gch 
             --pAutoAdc_val.AVG_Gch) <=2) &&
                                      (abs(pAutoAdc_preval.AVG_Bch -pAutoAdc_val.AVG_Bch) <=2) )
                      {
C51 COMPILER V9.60.0.0   DRVADC                                                            12/22/2020 19:50:39 PAGE 49  

                          eqcount++;
                      }
                      else
                      {
                          eqcount = 0;
                          pAutoAdc_preval.AVG_Rch = pAutoAdc_val.AVG_Rch;
                          pAutoAdc_preval.AVG_Gch = pAutoAdc_val.AVG_Gch;
                          pAutoAdc_preval.AVG_Bch = pAutoAdc_val.AVG_Bch;
                          if((i%5) == 0)
                              ADC_DPRINTF("@@ R_val = %d", pAutoAdc_preval.AVG_Gch);
                      }
                  }
                
                  if( (wStartAdd_White == 0) && (eqcount > 0) )
                  {
                      i -= (eqcount > 1 ? (eqcount/2) : 1);
                      wStartAdd_White = ((i-1)*Step);
                  }
              
                  drvADC_IsReadLineBuffer(FALSE);
                  {
                      ADC_DPRINTF("@@EQCount = %d\r\n", eqcount);
                      ADC_DPRINTF("@@EQVal_R = %d\r\n", pAutoAdc_preval.AVG_Rch);
                      ADC_DPRINTF("@@EQVal_G = %d\r\n", pAutoAdc_preval.AVG_Gch);
                      ADC_DPRINTF("@@EQVal_B = %d\r\n", pAutoAdc_preval.AVG_Bch);
                  }
                  ADC_DPRINTF("@@Line Buffer Start Address = %d\r\n", wStartAdd_White);
                  return wStartAdd_White;
              }
              
              
              //**************************************************************************
              //  [Function Name]:
              //                  _msADC_AutoGainAdjustment()
              //  [Description]:
              //                  Adjust gain to approach target value 182(8 bits) => 255 * 0.5/0.7 = 182
              //  [Precondition]:
              //
              //  [Arguments]:
              //                 wLineBufAddress: line buffer address, it should be less than PG Htotal
              //                 LineBuf: choose one line to read, 0 ~ 3
              //                 AvgCnt: average pixel count
              //  [Return]:
              //                  status
              //**************************************************************************
              static Bool drvADC_AutoGainAdjustment_WithInput(WORD wLineBufAddress, BYTE LineBuf, BYTE AvgCnt)
              {
                  msADCAvgVal pAutoAdc_val;
                  WORD rGain, gGain, bGain;
                  WORD maxRGain, maxGGain, maxBGain;
                  WORD minRGain, minGGain, minBGain;
                  BYTE retry=12;
                  BYTE atgFlags=0;
              
                  maxRGain=maxGGain=maxBGain=0xFFF;
                  minRGain=minGGain=minBGain=0;
              
                  while (retry--)
                  {
                      rGain=((WORD)maxRGain+minRGain)/2;
                      gGain=((WORD)maxGGain+minGGain)/2;
                      bGain=((WORD)maxBGain+minBGain)/2;
C51 COMPILER V9.60.0.0   DRVADC                                                            12/22/2020 19:50:39 PAGE 50  

                      drvADC_SetRGBGainCode(rGain, gGain, bGain);
                      Delay1ms(20);
                      drvADC_IsReadLineBuffer(TRUE);
                      pAutoAdc_val = drvADC_GetRGBLineBufAverageData(wLineBufAddress, LineBuf, AvgCnt); // (2*line buffe
             -r address + average data) < SPRHDC: (2*64+32) < 240
                      drvADC_IsReadLineBuffer(FALSE);
              
                      if (pAutoAdc_val.AVG_Rch >= 255)
                      {
                          rGain--;
                          atgFlags |= DGain_OverFlow_R_ch;
                      }
                      else
                      {
                          rGain++;
                          atgFlags |= DGain_NoneOverFlow_R_ch;
                      }
              
                      if (pAutoAdc_val.AVG_Gch >= 255)
                      {
                          gGain--;
                          atgFlags |= DGain_OverFlow_G_ch;
                      }
                      else
                      {
                          gGain++;
                          atgFlags |= DGain_NoneOverFlow_G_ch;
                      }
              
                      if (pAutoAdc_val.AVG_Bch >= 255)
                      {
                          bGain--;
                          atgFlags |= DGain_OverFlow_B_ch;
                      }
                      else
                      {
                          bGain++;
                          atgFlags |= DGain_NoneOverFlow_B_ch;
                      }
              
                      drvADC_SetRGBGainCode(rGain, gGain, bGain);
                      Delay1ms(20);
                      drvADC_IsReadLineBuffer(TRUE);
                      pAutoAdc_val = drvADC_GetRGBLineBufAverageData(wLineBufAddress, LineBuf, AvgCnt); // (2*line buffe
             -r address + average data) < SPRHDC: (2*64+32) < 240
                      drvADC_IsReadLineBuffer(FALSE);
              
                      if (pAutoAdc_val.AVG_Rch >= 255)
                      {
                          maxRGain=rGain+1;
                          atgFlags |= DGain_OverFlow_R_ch;
                      }
                      else
                      {
                          minRGain=rGain-1;
                          atgFlags |= DGain_NoneOverFlow_R_ch;
                      }
              
                      if (pAutoAdc_val.AVG_Gch >= 255)
                      {
                          maxGGain=gGain+1;
                          atgFlags |= DGain_OverFlow_G_ch;
C51 COMPILER V9.60.0.0   DRVADC                                                            12/22/2020 19:50:39 PAGE 51  

                      }
                      else
                      {
                          minGGain=gGain-1;
                          atgFlags |= DGain_NoneOverFlow_G_ch;
                      }
              
                      if (pAutoAdc_val.AVG_Bch >= 255)
                      {
                          maxBGain=bGain+1;
                          atgFlags |= DGain_OverFlow_B_ch;
                      }
                      else
                      {
                          minBGain=bGain-1;
                          atgFlags |= DGain_NoneOverFlow_B_ch;
                      }
                  if (CheckSyncLoss())//||CheckPowerKeyStatus())        
                      //if (_msADC_CheckSyncLoss())
                          return FALSE;
                  }
              
              
              
                  UserPrefAdcRedGain=rGain-1;
                  UserPrefAdcGreenGain=gGain-1;
                  UserPrefAdcBlueGain=bGain-1;
                  drvADC_SetRGBGainCode(UserPrefAdcRedGain, UserPrefAdcGreenGain, UserPrefAdcBlueGain);
                
                  if ((atgFlags&0xFC)!=0xFC)
                  {
                      ADC_DPUTSTR("Auto gain fail !!\n");
                      ADC_DPRINTF("Rgain = 0x%x", rGain);
                      ADC_DPRINTF("Ggain = 0x%x", gGain);
                      ADC_DPRINTF("Bgain = 0x%x", bGain);
                      return FALSE;
                  }
                  else
                  {
                      ADC_DPUTSTR("Auto gain OK");
                      ADC_DPRINTF("Rgain = 0x%x", rGain);
                      ADC_DPRINTF("Ggain = 0x%x", gGain);
                      ADC_DPRINTF("Bgain = 0x%x", bGain);
                      return TRUE;
                  }
              }
              
              #endif //#ifdef(_DGAIN_CAL_WITH_INPUT_)
3022          
3023          void drvADC_SetHsyncRefLevel(ADC_HSYNCLVL_T level)
3024          {
3025   1          msWriteByteMask(REG_ADC_ATOP_20_L, level, 0x07);
3026   1      }
3027          
3028          #if 1
3029          
3030          void drvADC_Test_Funct(BYTE tb1, BYTE tb2)
3031          {
3032   1          BYTE uncallvalue = tb2;
3033   1      
3034   1          switch(tb1)
3035   1          {
C51 COMPILER V9.60.0.0   DRVADC                                                            12/22/2020 19:50:39 PAGE 52  

3036   2              case 0: // mismatch calibration
3037   2                  drvADC_ADCOffsetGainMismatchCal();
3038   2                  break;
3039   2              case 1: // auto phase
3040   2                  mStar_AutoPhase(40);
3041   2                  ADC_DPRINTF("@@ Auto Phase = 0x%x", UserPrefPhase);
3042   2                  break;
3043   2      #if 0
                      case 1: // auto gain with input
                          msADC_ADCAutoGainCalwithInput();
                          break;
                      case 2: // auto gain without input
                          switch(tb2)
                          {
                              case 0:
                                  // 1. backup ADC and Scaler related settings
                                  _msADC_BackupADCSetting();
                                  _msADC_BackupScalerSetting();
              
                                  // 2. Set free run clock at 720p
                                  _msADC_SetFreeRunClock();
                                  break;
                              case 1:
                                  // 3. Enable scaler pattern generator to generate Hsync and Vsync for line buffer
                                  _msADC_EnableScalerPG( E_PG_Htotal_256 );
                                  break;
                              case 2:
                                  // 4. Set ADC input LPF to lowest bandwidth
                                  _msADC_Write2BytesMask( REG_ADC_ATOP_23_L, 0xFFFF, 0xFFFF );
                                  _msADC_Write2BytesMask( REG_ADC_ATOP_24_L, 0x00FF, 0x00FF );
                                  break;
                              case 3:
                                  // 5. Calibrate ADC R/G/B gain setting value
                                  // Set R/G/B gain initial setting value at 0x0400
                                  // 6. Gain calibration target value for RGB color space mode is 182 (8bit data) 255 * 
             -0.5 / 0.7 = 182
                                  // 7. Get the ADC digital output with Turn-On LDO and Set VCAL to 1.05v
                                  // 8. Get the ADC digital output with VCAL to 0.55v
                                  // 9. Calculate the difference between 1.05V and 0.55V of these 3 channels.
                                  //    Compare the difference value with target value (182 at RGB color space) to adjus
             -t R/G/B channel gain register
                                  _msADC_AutoGainAdjustment();
                                  break;
                              case 4:
                                  // 10. recover ADC and scaler related settings & turn off free run clock & turn off in
             -ternal Vcal
                                  _msADC_RecoverADCSetting();
                                  _msADC_RecoverScalerSetting();
                                  break;
              
                              case 5:
                                  msADC_ADCAutoGainCalwithoutInput();
                                  break;
                          }
                          break;
              #endif
3089   2              case 3:
3090   2                  drvADC_AutoAdcColor(20);
3091   2                  break;
3092   2      #ifdef _DGAIN_CAL_WITH_INPUT_
                      case 4:
                     drvADC_ADCAutoGainCalwithInput();
C51 COMPILER V9.60.0.0   DRVADC                                                            12/22/2020 19:50:39 PAGE 53  

                          break;
              #endif
3097   2      #ifdef _DGAIN_CAL_WITHOUT_INPUT_
                      case 5:
                              drvADC_AutoGainAdjustment();
                          break;
              
                      case 6:
                          drvADC_ADCAutoGainCalwithoutInput();
                          break;
                          
                      case 7:
                          ADC_DPUTSTR("LDO:");
                          //drvADC_ADCAutoGainCalwithoutInput();
                          //_msADC_SetInternalVcal(E_Vcal_1_05V);
                          {
                          msADCAvgVal ptmp;
                          msADCAvgVal pAutoAdc_val;
              
                          // 1. backup ADC and Scaler related settings
                          drvADC_BackupADCSetting();
                          drvADC_BackupScalerSetting();
                          
                          // 2. Set free run clock at 720p
                          drvADC_SetFreeRunClock();
                          _msADC_MaskExternalSync(TRUE);            
                          
                          // 3. Enable scaler pattern generator to generate Hsync and Vsync for line buffer
                          drvADC_EnableScalerPG(E_PG_Htotal_256);
                          
                          // 4. Set ADC input LPF to lowest bandwidth
                          drvADC_Write2BytesMask(REG_ADC_ATOP_23_L, 0xFFFF, 0xFFFF);
                          drvADC_Write2BytesMask(REG_ADC_ATOP_24_L, 0x00FF, 0x00FF);
              
                          msWrite2ByteMask(REG_ADC_ATOP_34_L, BIT0, BIT0); // turn on LDO
                          msWrite2ByteMask(REG_ADC_ATOP_54_L, 0, 0xF800); // disable bandgap overwrite
                          msWrite2ByteMask(REG_ADC_ATOP_34_L, BIT2, BIT2); // LDO, Aaron test
                          msWrite2ByteMask(REG_ADC_ATOP_54_L, 0x0003, 0x0003); // set Vcal = 1.05V
                          msWrite2ByteMask(REG_ADC_ATOP_54_L, 0x000C, 0x000C); // set Vcal from LDO
                          msWrite2ByteMask(REG_ADC_ATOP_54_L, 0x0600, 0x0700); // turn on Gcal pulse
              
                          Delay1ms(1500);
                          drvADC_IsReadLineBuffer(TRUE);
                          ptmp = drvADC_GetRGBLineBufAverageData(0x40, 0, 32); // (2*line buffer address + average data)
             - < SPRHDC: (2*64+32) < 240
                          drvADC_IsReadLineBuffer(FALSE);
                          
                          msWrite2ByteMask(REG_ADC_ATOP_34_L, BIT0, BIT0); // turn on LDO
                          msWrite2ByteMask(REG_ADC_ATOP_34_L, BIT2, BIT2); // LDO, Aaron test
                          msWrite2ByteMask(REG_ADC_ATOP_54_L, 0x0002, 0x0003); // set Vcal = 0.55V
                          msWrite2ByteMask(REG_ADC_ATOP_54_L, 0x000C, 0x000C); // set Vcal from LDO
                          msWrite2ByteMask(REG_ADC_ATOP_54_L, 0x0600, 0x0700); // turn on Gcal pulse
              
                          Delay1ms(1500);
                          drvADC_IsReadLineBuffer(TRUE);
                          pAutoAdc_val = drvADC_GetRGBLineBufAverageData(0x40, 0, 32); // (2*line buffer address + avera
             -ge data) < SPRHDC: (2*64+32) < 240
                          drvADC_IsReadLineBuffer(FALSE);
              
                          // 10. recover ADC and scaler related settings & turn off free run clock & turn off internal V
             -cal
                          _msADC_MaskExternalSync(FALSE);
C51 COMPILER V9.60.0.0   DRVADC                                                            12/22/2020 19:50:39 PAGE 54  

                          drvADC_RecoverADCSetting();
                          drvADC_RecoverScalerSetting();
                          
                          ADC_DPRINTF("AVG_R_1.05V= 0x%x", ptmp.AVG_Rch);
                          ADC_DPRINTF("AVG_G_1.05V = 0x%x", ptmp.AVG_Gch);
                          ADC_DPRINTF("AVG_B_1.05V = 0x%x", ptmp.AVG_Bch);
                          ADC_DPRINTF("AVG_R_0.55V = 0x%x", pAutoAdc_val.AVG_Rch);
                          ADC_DPRINTF("AVG_G_0.55V = 0x%x", pAutoAdc_val.AVG_Gch);
                          ADC_DPRINTF("AVG_B_0.55V = 0x%x", pAutoAdc_val.AVG_Bch);    
                          ADC_DPRINTF("AVG_R_diff = 0x%x", ptmp.AVG_Rch - pAutoAdc_val.AVG_Rch);
                          ADC_DPRINTF("AVG_G_diff = 0x%x", ptmp.AVG_Gch - pAutoAdc_val.AVG_Gch);
                          ADC_DPRINTF("AVG_B_diff = 0x%x", ptmp.AVG_Bch - pAutoAdc_val.AVG_Bch);  
                          }
                          break;
                      case 8:
                          ADC_DPUTSTR("Get:");
                          //drvADC_ADCAutoGainCalwithoutInput();
                          //_msADC_SetInternalVcal(E_Vcal_1_05V);
                          {
                          msADCAvgVal ptmp;
              
                          drvADC_IsReadLineBuffer(TRUE);
                          ptmp = drvADC_GetRGBLineBufAverageData(0x40, 0, 32); // (2*line buffer address + average data)
             - < SPRHDC: (2*64+32) < 240
                          drvADC_IsReadLineBuffer(FALSE);
                          
                          ADC_DPRINTF("AVG_R = 0x%x", ptmp.AVG_Rch);
                          ADC_DPRINTF("AVG_G = 0x%x", ptmp.AVG_Gch);
                          ADC_DPRINTF("AVG_B = 0x%x", ptmp.AVG_Bch);
                          }
                          break;
              #endif
3185   2          }
3186   1      }
3187          #endif // #if DEBUG_EN
3188          
3189          
3190          #else
              
              #if DUMMY_CODE_4_LINK_FILE
              BYTE code DrvADCDummy[]={0xFF};
              #endif
              
              #endif //ENABLE_VGA_INPUT
3197          //Jison 110314
3198          void drvADC_PowerCtrl(BYTE u8State)
3199          {
3200   1          if(u8State==ADC_POWER_ON)
3201   1          {
3202   2              msWrite2Byte( REG_ADC_ATOP_04_L, 0x0000 );  // set power-on default value to power down ADC
3203   2              msWriteByteMask(REG_ADC_ATOP_06_L, 0, 0xFF); // ADC clock power on
3204   2              msWriteByteMask(REG_ADC_ATOP_30_L, 0, BIT0); // on-line SOG MUX power on
3205   2      #if _NEW_SOG_DET_ //(SC0_ED[5]==0 while power saving)
3206   2              msWrite2Byte( REG_ADC_ATOP_78_L, 0x0002 );  // set power-on default value to power down ADC
3207   2              msWrite2Byte(REG_ADC_ATOP_79_L, 0x00C8); // ADC clock power down
3208   2              msWriteByteMask(REG_ADC_ATOP_7A_L, BIT2, BIT2|BIT1); // on-line SOG MUX power on
3209   2      #endif
3210   2              Delay1ms(10);
3211   2              msWrite2ByteMask(REG_ADC_ATOP_11_L, BIT8, BIT8); // ADC phase alignment trigger
3212   2              msWrite2ByteMask(REG_ADC_ATOP_11_L, 0, BIT8);    // ADC phase alignment trigger
3213   2      #if CHIP_ID == CHIP_TSUMF
                      msWriteByteMask(REG_ADC_ATOP_05_H, 0, BIT3); // phase digitizer to sync HSYNC (related to phase pe
C51 COMPILER V9.60.0.0   DRVADC                                                            12/22/2020 19:50:39 PAGE 55  

             -rformance)
              #endif
3216   2          }
3217   1          else if(u8State==ADC_POWER_STANDBY)
3218   1          {
3219   2            #if !MS_PM //seperate only
                      msWrite2Byte( REG_ADC_ATOP_04_L, 0x3FFF );  // set power-on default value to power down ADC
                      msWriteByteMask(REG_ADC_ATOP_06_L, 0xFF, 0xFF); // ADC clock power on
                      msWriteByteMask(REG_ADC_ATOP_30_L, BIT0, BIT0); // on-line SOG MUX power down
                    #else //saperate & SOG support
3224   2              #if _NEW_SOG_DET_ //(SC0_ED[5]==0 while power saving)
3225   2              msWrite2Byte( REG_ADC_ATOP_78_L, 0x0002 );  // set power-on default value to power down ADC
3226   2              msWrite2Byte(REG_ADC_ATOP_79_L, 0x00C8); // ADC clock power down
3227   2              msWriteByteMask(REG_ADC_ATOP_7A_L, BIT2, BIT2|BIT1); // on-line SOG MUX power on
3228   2              #endif
3229   2              msWrite2Byte( REG_ADC_ATOP_04_L, 0x79F9 );  // set power-on default value to power down ADC
3230   2              msWriteByteMask(REG_ADC_ATOP_06_L, 0, 0xFF); // ADC clock power on
3231   2              msWriteByteMask(REG_ADC_ATOP_30_L, 0, BIT0); // on-line SOG MUX power on
3232   2      #if CHIP_ID == CHIP_TSUMF
                  msWriteByteMask(REG_ADC_ATOP_05_H, BIT3, BIT3);
              #endif
3235   2      
3236   2            #endif
3237   2          }
3238   1          else //ADC_POWER_DOWN
3239   1          {
3240   2      #if ((CHIP_ID == CHIP_TSUMC) || (CHIP_ID==CHIP_TSUMK) || (CHIP_ID == CHIP_TSUMD)|| (CHIP_ID == CHIP_TSUMJ)
             - || (CHIP_ID == CHIP_TSUM9)|| (CHIP_ID == CHIP_TSUMF))
3241   2              msWrite2Byte( REG_ADC_ATOP_04_L, 0xFFFF );  //  power down ADC
3242   2      #else
                      msWrite2Byte( REG_ADC_ATOP_04_L, 0x7FFF );  //  power down ADC
              #endif
3245   2              
3246   2      #if _NEW_SOG_DET_ //(SC0_ED[5]==0 while power saving)
3247   2              msWrite2Byte( REG_ADC_ATOP_78_L, 0x0000 );  // set power-on default value to power down ADC
3248   2              msWrite2Byte(REG_ADC_ATOP_79_L, 0x0000); // ADC clock power down
3249   2              msWriteByteMask(REG_ADC_ATOP_7A_L, 0, BIT2|BIT1); // on-line SOG MUX power on
3250   2      #endif
3251   2              msWriteByteMask(REG_ADC_ATOP_06_L, 0xFF, 0xFF); // ADC clock power down
3252   2              msWriteByteMask(REG_ADC_ATOP_30_L, BIT0, BIT0); // on-line SOG MUX power down
3253   2      #if CHIP_ID == CHIP_TSUMF
                  msWriteByteMask(REG_ADC_ATOP_05_H, BIT3, BIT3);
              #endif
3256   2          }
3257   1      }
3258          
3259          #endif // _DRVADC_C_


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   5779    ----
   CONSTANT SIZE    =   2107    ----
   XDATA SIZE       =     57       9
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----     162
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
