; ..\DRIVER\USBHost_New\source\drvUsbMain.SRC generated from: ..\DRIVER\USBHost_New\source\drvUsbMain.c
; COMPILER INVOKED BY:
;        C:\Keil\C51\BIN\C51.EXE ..\DRIVER\USBHost_New\source\drvUsbMain.c OPTIMIZE(9,SPEED) BROWSE INCDIR(..\KERNEL\SYSTEM\INC;..\KERNEL\SCALER\INC;..\EXTDEVICE\INC;..\LIB\INC;..\PANEL\INC;..\UI\BOARD;..\UI\INC;..\UI\MODEL;..\DRIVER\INC;..\DRIVER\USBHost_New\include;..\DRIVER\USBHost_New\source) DEFINE(ModelName=TSUMXXD_DEMO) DEBUG OBJECTEXTEND PRINT(.\List\drvUsbMain.lst) OBJECT(.\Obj\drvUsbMain.obj)


NAME	DRVUSBMAIN

?PR?MDrv_UsbHost_Init?DRVUSBMAIN         SEGMENT CODE 
?XD?MDrv_UsbHost_Init?DRVUSBMAIN         SEGMENT XDATA OVERLAYABLE 
?PR?_MDrv_USB_Init?DRVUSBMAIN            SEGMENT CODE 
?PR?ResetUsbHardware?DRVUSBMAIN          SEGMENT CODE 
?PR?UsbPort0UTMIInitial?DRVUSBMAIN       SEGMENT CODE 
?PR?MDrv_UsbDeviceConnect?DRVUSBMAIN     SEGMENT CODE 
?PR?MDrv_Usb_Device_Enum?DRVUSBMAIN      SEGMENT CODE 
?XD?MDrv_Usb_Device_Enum?DRVUSBMAIN      SEGMENT XDATA OVERLAYABLE 
?CO?DRVUSBMAIN       SEGMENT CODE 
?C_INITSEG           SEGMENT CODE 
?XD?DRVUSBMAIN       SEGMENT XDATA 
?PR?DRVUSBMAIN       SEGMENT CODE 
	EXTRN	CODE (_Delay1ms)
	EXTRN	CODE (drvUSBHost_UTMIInitial_Port2)
	EXTRN	CODE (_drvUSBHost_HID_Init)
	EXTRN	CODE (drvUSBHost_isPowerSaveModeEnable)
	EXTRN	CODE (_flib_Host20_Enumerate)
	EXTRN	XDATA (gUSBC_BASE)
	EXTRN	CODE (_MDrv_Timer_DiffTimeFromNow)
	EXTRN	CODE (_USB_Hub_Handle)
	EXTRN	XDATA (sAttachDevice)
	EXTRN	CODE (MDrv_Timer_GetTime0)
	EXTRN	XDATA (gUTMI_BASE)
	EXTRN	XDATA (gUsbDeviceState_Port2)
	EXTRN	CODE (UsbTurnOffPowerDownMode)
	EXTRN	CODE (_flib_OTGH_Init)
	EXTRN	CODE (drvUSBHost_isPort2Enable)
	EXTRN	XDATA (gUHC_BASE)
	EXTRN	CODE (Usb_Hub_Port_Num)
	EXTRN	CODE (UsbTurnOnPowerDownMode)
	EXTRN	XDATA (RecoveryFlag)
	EXTRN	XDATA (Host20_qHD_List_Control1)
	EXTRN	CODE (_printMsg)
	EXTRN	XDATA (gSpeed)
	EXTRN	CODE (jpCVBS5_Get_HK_XDATA_Addr)
	EXTRN	XDATA (gUsbDeviceState)
	EXTRN	CODE (?C?LSTXDATA)
	EXTRN	CODE (?C?ULCMP)
	EXTRN	CODE (?C?LSTKXDATA)
	PUBLIC	USB_BUFFER_START_ADR_4K_ALIGN_Var
	PUBLIC	UsbStartTime
	PUBLIC	UsbPowerSavingTimer
	PUBLIC	usb_host_p1_c51version
	PUBLIC	gUsbStatus
	PUBLIC	NowIsHub
	PUBLIC	gUsbTimeout
	PUBLIC	MDrv_Usb_Device_Enum
	PUBLIC	MDrv_UsbDeviceConnect
	PUBLIC	UsbPort0UTMIInitial
	PUBLIC	ResetUsbHardware
	PUBLIC	_MDrv_USB_Init
	PUBLIC	MDrv_UsbHost_Init

	RSEG  ?XD?MDrv_UsbHost_Init?DRVUSBMAIN
?MDrv_UsbHost_Init?BYTE:
     result?040:   DS   1

	RSEG  ?XD?MDrv_Usb_Device_Enum?DRVUSBMAIN
?MDrv_Usb_Device_Enum?BYTE:
	ORG  3
    PortNum?542:   DS   1
	ORG  4
          i?543:   DS   1
	ORG  5
    devaddr?544:   DS   1
	ORG  0
     result?545:   DS   1
	ORG  1
 RetryCount?546:   DS   1
	ORG  2
rootUSBDeviceInterfaceClass?547:   DS   1

	RSEG  ?XD?DRVUSBMAIN
    gUsbTimeout:   DS   1
       NowIsHub:   DS   1
     gUsbStatus:   DS   1
usb_host_p1_c51version:   DS   3
UsbPowerSavingTimer:   DS   4
   UsbStartTime:   DS   4
USB_BUFFER_START_ADR_4K_ALIGN_Var:   DS   4
xdwin1_lockCount:   DS   1
original_xdwin1_Base:   DS   4

	RSEG  ?CO?DRVUSBMAIN
?SC_0:
	DB  'C' ,'5' ,'1' ,':' ,'8' ,'1' ,'2' ,000H

?SC_8:
	DB  'd' ,'e' ,'v' ,' ' ,'c' ,'h' ,'a' ,'n' ,'g' ,'e' 
	DB  'd' ,',' ,' ' ,'w' ,'e' ,' ' ,'m' ,'i' ,'s' ,'s' 
	DB  'e' ,'d' ,00AH,000H


	RSEG  ?C_INITSEG
	DB	041H
	DW	gUsbStatus
	DB	000H

	DB	041H
	DW	gUsbTimeout
	DB	005H

	DB	044H
	DW	original_xdwin1_Base
	DB	0FFH,0FFH,0FFH,0FFH	; long

	DB	041H
	DW	xdwin1_lockCount
	DB	000H

	DB	043H
	DW	usb_host_p1_c51version
	DB	0FFH	 ; ptr3
	DW	?SC_0	 ; ptr2

	DB	044H
	DW	UsbStartTime
	DB	000H,000H,000H,000H	; long

	DB	044H
	DW	UsbPowerSavingTimer
	DB	000H,000H,000H,000H	; long

; #pragma SRC
; #pragma LARGE
; ///////////////////////////////////////////////////////////////////////////////
; //
; //	File name: drvUsbMain.C
; //	Version: 0.1
; //	Date: 2004/9/20
; //	Company: Faraday Tech. Corp.
; ///////////////////////////////////////////////////////////////////////////////
; #include "USBHostConfig.h"
; //#include <stdlib.h>
; //#include <stdarg.h>
; #ifndef ATV_SERISE_USE
; #include <stdio.h>
; #endif
; #include <string.h>
; //#include "chipset.h"
; //#include "flib.h"
; //#include <MsCommon.h>
; #ifndef ATV_SERISE_USE
; #include "datatype.h"
; #else
; #include "UsbHostDataDef.h"
; #endif
; #include "drvHostLib.h"
; #include "drvHost200.h"
; #include "drvUsbMain.h"
; #ifndef ATV_SERISE_USE
; #include "sysinfo.h"
; #include "drvtimer.h"
; #endif
; #include "drvusb.h"
; #ifdef Enable_Mass_Storage
; #include "drvscsi.h"
; #endif
; //#include <R8051XC.h>
; #ifdef ATV_SERISE_USE
; #include "common.h"
; //#include "uart.h"
; //#include "command.h"
; #endif
; #ifdef CERAMAL_SERISE_USE
; #include "drvtimer.h"
; #include "Board.h"
; #include "drvUTMI.h"
; #else
; //#include "msAPI_Timer.h"
; #endif
; 
; #ifdef OnePort_OTG_EHCI
; #include "MsCompiler.h"
; #include "msusb.h"
; #include "msDRC.h"
; #include "msconfig.h"
; #include "mscpu.h"
; #include "drvisr.h"
; #endif
; 
; #include "drvUSBHost_PTP.h"
; 
; #define DRV_USB_DBG(x)   // x;
; #define MINI_DEBUG(x)      //x;
; 
; U8 gUsbStatus=USB_OK;
; U8 gUsbTimeout=5;
; 
; #if 1
; extern U8 gUsbDeviceState;
; extern U8 gUsbDeviceState_Port2;
; #else
; #ifdef USB_POWER_SAVING_MODE
; U8 gUsbDeviceState=POWER_SAVING;
; #ifdef USBHOST2PORT
; extern U8 gUsbDeviceState_Port2;
; #endif
; #else
; U8 gUsbDeviceState=NO_DEVICE;
; #endif
; #endif
; U8  NowIsHub;
; 
; extern U8 gSpeed;
; static U32 original_xdwin1_Base=0xFFFFFFFF; //use 0xFFFFFFFF to represent void
; static U8 xdwin1_lockCount=0;
; #define STR_C51_VERSION(x) "C51:"##  #x
; 
; #define C51_VERSION(x) STR_C51_VERSION(x)
; 
; char* usb_host_p1_c51version = C51_VERSION(__C51__);
; #if 0
; U8 code USB_VBuf[32] = {'M', 'S', 'V', 'C', '0', '0',			    // 0, 0 fixed
;                         'Z', '2',						            // Library ID
; #ifdef   DTV_STANDARD_LIB
;                         'A', '0', '0', '1', '4', '0',				// build number
; #endif
; #ifdef ATV_SERISE_USE
;                         'B', '0', '0', '1', '2', '4',				// build number
; #endif
; #ifdef CERAMAL_SERISE_USE
;                         'C', '0', '0', '1', '2', '4',				// build number
; #endif
; 
;                         '0', '0', '0', '0', '0', '0', '0', '0',		// change list 46058
;                         'A', '4', 'A', '0', '0', '0', '0', '0', '0',// A4: Saturn, A:LG
;                         'T'};
; #endif
; #ifdef OnePort_OTG_EHCI
; U8 USBMode=0; //set default status=OTG device mode ,{default=0, otg=1, uhci=2}
; extern U8 volatile usbUSBState;
; #endif
; 
; extern U8 RecoveryFlag;
; //extern BOOLEAN gDeviceFatalError;
; 
; #ifdef OnePort_OTG_EHCI
; extern void MDrv_OTG_Init(void);
; extern U8 usbIsUSBConfiged(void);
; enum
; {
;     USBHostMode_disconnect = 0,
;     USBHostMode_connect,
;     USBDeivceMode_disconnect,
; 	USBDeivceMode_connect
; };
; #endif
; 
; extern void drvUSBHost_TurnOffPowerDownMode(void);
; extern void drvUSBHost_TurnOnPowerDownMode(void);
; extern BOOLEAN drvUSBHost_isPowerSaveModeEnable();
; extern void drvUSBHost_UTMIInitial();
; extern void drvUSBHost_UTMIInitial_Port2();
; extern void UsbTurnOffPowerDownMode(void);
; extern void UsbTurnOnPowerDownMode(void);
; extern BOOLEAN drvUSBHost_isPort2Enable();
; #ifdef  Enable_PTP
; extern U8 drvUSBHost_PTP_Init(U8 u8UsbPort);
; #endif
; extern U8 drvUSBHost_HID_Init(U8 u8UsbPort);
; 
; #if 0
; void UsbGetVerString(U8 *pVerString)
; {
; 
;     memcpy(pVerString, &USB_VBuf[0], sizeof(USB_VBuf));
; 
; }
; #endif
; #if 0
; 
; void SetUsbTimeout(U8 x)
; {
;   gUsbTimeout=x;
; }
; 
; //============================================================================= ok
; //		FUSBH200_PHY_Reset()
; //		Description:
; //		input: none
; //		output: none
; //=============================================================================
; void FUSBH200_PHY_Reset(void)
; {
;   //Reset Phy
;   //waiting for mdwOTGC_Control_B_SESS_END_Rd
; 
;   // kcj 2007-06-07	printf(">>> Waiting for B_SESS_END & Phy Reset...(under 5sec)\n");
; 
;   mwOTG20_Control_Phy_Reset_Set();
;   MDrv_Timer_Delayms(1);
;   mwOTG20_Control_Phy_Reset_Clr();
; }
; #endif
; 
; 
; #ifdef USE_XDATA_ADDRESS_0XF000
; void MDrv_USB_SetXdataWindow1(void)
; {
;   if(xdwin1_lockCount==0xFF)
;   {
;     DRV_USB_DBG( printf("error!! MAX allowed lock reached\n"));
;   }
; 
;   if(xdwin1_lockCount==0)
;   {
; 
;     U16 _win1Base = (XBYTE[XDMIU_REG_BASE + 13]<<8 | XBYTE[XDMIU_REG_BASE + 12]);
;     original_xdwin1_Base=(U32)_win1Base;
;     XBYTE[XDMIU_REG_BASE + 13] = (USB_BUFFER_START_ADR_4K_ALIGN_Var>>12)>>8;
;     XBYTE[XDMIU_REG_BASE + 12] = (USB_BUFFER_START_ADR_4K_ALIGN_Var>>12)>>0;
;   }
;   xdwin1_lockCount++;
;   //DRV_USB_DBG(printf("==== WIN1 LOCKED BY USB, COUNT=%bu\n",xdwin1_lockCount););
; }
; void MDrv_USB_ReleaseXdataWindow1(void)
; {
;   if(xdwin1_lockCount==0)
;   {
;     DRV_USB_DBG(printf("error!! no lock to release\n"));
;   }
; 
;   if(xdwin1_lockCount==1)
;   {
;     XBYTE[XDMIU_REG_BASE + 13] = ((U16)original_xdwin1_Base)>>8;
;     XBYTE[XDMIU_REG_BASE + 12] = ((U16)original_xdwin1_Base)>>0;
; 
;     original_xdwin1_Base=0xFFFFFFFF;
;   }
;   xdwin1_lockCount--;
;   //DRV_USB_DBG(printf("==== WIN1 UNLOCKED BY USB, COUNT=%bu\n",xdwin1_lockCount););
; 
; }
; #endif
; #ifdef Enable_Burning_Test
; #ifndef CERAMAL_SERISE_USE
; extern void msAPI_Timer_ResetWDT(void);
; #endif
; //U8 buf1[512];
; void UsbTest()
; {
;   U16 i,j;
;   U32 idx=0,xxx;
;   U8 VailLun,LunIndex;
;   U8 xdata *buf1;
; 
;   printMsg("\r\n USB Burning Test\n");
;   //printf("maxlun :%02bx lunbyte:%02bx\n",maxlun,lunbyte);
;   //MDrv_UsbHost_Init();
; 
;   VailLun=MDrv_GET_MASS_VALID_LUN();
;   printData("VailLun: %bd\n", VailLun);
;   switch (VailLun)
;   {
;     case 0x01:
; 	         LunIndex=0;
; 			 break;
; 	case 0x02:
; 	         LunIndex=1;
; 			 break;
; 	case 0x04:
; 	         LunIndex=2;
; 			 break;
; 	case 0x08:
; 	         LunIndex=3;
; 			 break;
; 	case 0x10:
; 	         LunIndex=4;
; 			 break;
; 	case 0x20:
; 	         LunIndex=5;
; 			 break;
; 	case 0x40:
; 	         LunIndex=6;
; 			 break;
; 	  case 0x80:
; 	         LunIndex=7;
; 			 break;
;   }
; 
;   buf1=(U8 xdata*)(0xFE00);
; 
;   for (i=0 ; i < 0x200 ; i++)
;   {
;     buf1[i]= (i & 0xff);
;   }
; 
;   printData("buf1 real addr: 0x%lX\n", (VirtoPhyAddr((U32)buf1)));
;   //printf("\r\n addr=%x",(VirtoPhyAddr((U32)buf1)>>16));
;   //printf(",%x\n",(VirtoPhyAddr((U32)buf1)));
;   printData("gSpeed: %bd\n", gSpeed);
; 
;   while (1)
;   {
;     #ifndef CERAMAL_SERISE_USE
;     msAPI_Timer_ResetWDT();
;     #endif
;     idx++;
;     //if ((idx & 0x3f)==0)
; 	{
; 	  printData("\r\n Loop:%x",(U16)(idx>>16));
; 	  printData(",%x",(U16)(idx));
; 	}
;     //MDrv_MIU_Copy
; 	xxx=idx % 10000;
;     if (MDrv_UsbBlockWriteFromMIU(LunIndex,50+xxx,1,VirtoPhyAddr((U32)buf1))==FALSE)
;     {
;       printMsg("\r\n write failed\n");
;       break;
;     }
;     if (MDrv_UsbBlockReadToMIU(LunIndex,50+xxx,1,VirtoPhyAddr((U32)buf1))==FALSE)
;     {
;       printMsg("\r\n read failed\n");
;       break;
;     }
; 	//MDrv_Timer_Delayms(10);
;     for (j=0 ; j < 0x200 ; j++)
;     {
;       if (buf1[j]!= (j&0xff)) printMsg("\r\n data error\n");
;     }
;     MDrv_Timer_Delayms(5);
;   }
; 
; }
; #endif
; #if 0
; U8 MDrv_UsbGetInterfaceClass(U8 i,U8 j)
; {
;   U8 tmp;
;   #ifdef USE_XDATA_ADDRESS_0XF000
;   MDrv_USB_SetXdataWindow1();
;   #endif
;   tmp=sAttachDevice.saCD[i].sInterface[j].bInterfaceClass;
;   #ifdef USE_XDATA_ADDRESS_0XF000
;   MDrv_USB_ReleaseXdataWindow1();
;   #endif
; 
;   return tmp;
; }
; #endif
; 
; //====================================================================
; // * Function Name: main
; // * Description:
; // * Input:
; // * OutPut:
; //====================================================================

	RSEG  ?PR?DRVUSBMAIN
Com0059:
L?0090:
	USING	0
	MOV  	DPTR,#gUHC_BASE
	MOVX 	A,@DPTR
	MOV  	R6,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R7,A
	MOV  	R4,AR6
	ORL  	A,#040H
	MOV  	DPL,A
	MOV  	DPH,R4
	MOVX 	A,@DPTR
	ANL  	A,#0EFH
	MOVX 	@DPTR,A
	MOV  	A,#034H
	ADD  	A,R7
	MOV  	DPL,A
	CLR  	A
	ADDC 	A,R6
	MOV  	DPH,A
	MOVX 	A,@DPTR
	ANL  	A,#0BFH
	MOVX 	@DPTR,A
	MOV  	DPTR,#gUHC_BASE
	MOVX 	A,@DPTR
	MOV  	R6,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#034H
L?0091:
	MOV  	DPL,A
	CLR  	A
	ADDC 	A,R6
	MOV  	DPH,A
	MOVX 	A,@DPTR
	RET  	
L?0092:
	USING	0
	MOV  	DPTR,#gUTMI_BASE
	MOVX 	A,@DPTR
	MOV  	R6,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	DPL,A
	MOV  	DPH,R6
	MOVX 	A,@DPTR
	ORL  	A,#01H
	MOVX 	@DPTR,A
	MOV  	DPTR,#gUTMI_BASE
	MOVX 	A,@DPTR
	MOV  	R6,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R7,A
	MOV  	DPL,A
	MOV  	DPH,R6
	INC  	DPTR
	MOVX 	A,@DPTR
	ORL  	A,#040H
	MOVX 	@DPTR,A
	MOV  	DPL,R7
	MOV  	DPH,R6
	INC  	DPTR
	MOVX 	A,@DPTR
	ORL  	A,#02H
L?0093:
	MOVX 	@DPTR,A
L?0094:
	MOV  	DPTR,#gUTMI_BASE
	MOVX 	A,@DPTR
	MOV  	R6,A
	INC  	DPTR
	MOVX 	A,@DPTR
	RET  	
L?0095:
	USING	0
L?0096:
	MOVX 	@DPTR,A
	MOV  	DPTR,#gUHC_BASE
	MOVX 	A,@DPTR
	MOV  	R6,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ORL  	A,#010H
	MOV  	DPL,A
	MOV  	DPH,R6
	MOVX 	A,@DPTR
	ORL  	A,#02H
	MOVX 	@DPTR,A
	RET  	
L?0097:
	USING	0
	MOV  	DPTR,#gSpeed
	MOV  	A,#0FFH
	MOVX 	@DPTR,A
L?0098:
	MOV  	DPTR,#gUHC_BASE
	MOVX 	A,@DPTR
	MOV  	R6,A
	INC  	DPTR
	MOVX 	A,@DPTR
	RET  	
L?0099:
	USING	0
	MOV  	R7,A
	ADD  	A,#02CH
L?0100:
	MOV  	DPL,A
	CLR  	A
	ADDC 	A,R6
	MOV  	DPH,A
	RET  	
L?0101:
	USING	0
	MOVX 	A,@DPTR
	MOV  	R4,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R5,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R6,A
	INC  	DPTR
	MOVX 	A,@DPTR
	RET  	
; END OF Com0059

; BOOLEAN MDrv_UsbHost_Init(void)

	RSEG  ?PR?MDrv_UsbHost_Init?DRVUSBMAIN
MDrv_UsbHost_Init:
	USING	0
			; SOURCE LINE # 326
; {
			; SOURCE LINE # 327
;   BOOLEAN result=FALSE;
			; SOURCE LINE # 328
	CLR  	A
	MOV  	DPTR,#result?040
	MOVX 	@DPTR,A
; 
;   DRV_USB_DBG(printMsg("HOST200_main\n"));
; 
;   MINI_DEBUG(printMsg("uinit\n"));
;   if (gUsbStatus==USB_EJECT)
			; SOURCE LINE # 333
	MOV  	DPTR,#gUsbStatus
	MOVX 	A,@DPTR
	CJNE 	A,#04H,?C0001
;   {
			; SOURCE LINE # 334
;     //printf("2430:%02bx\n",XBYTE[0x2430]);
;     if (UHC_XBYTE(0x30)&2)
			; SOURCE LINE # 336
	LCALL	L?0098
	ADD  	A,#030H
	LCALL	L?0091
	JNB  	ACC.1,?C0002
;     {
			; SOURCE LINE # 337
;       gUsbStatus=USB_OK;
			; SOURCE LINE # 338
	CLR  	A
	MOV  	DPTR,#gUsbStatus
	MOVX 	@DPTR,A
;     }
			; SOURCE LINE # 339
	SJMP 	?C0001
?C0002:
;     else
;       return FALSE;         //eject state
			; SOURCE LINE # 341
	MOV  	R7,#00H
	RET  	
;   }
			; SOURCE LINE # 342
?C0001:
; 
;   #ifdef USE_XDATA_ADDRESS_0XF000
;   MDrv_USB_SetXdataWindow1();
;   #endif
; 
;   //XBYTE[gUTMI_BASE+0x06]|=0x44;        //Force HS TX current enable and CDR stage select
;   XBYTE[gUTMI_BASE+0x06]|=0x40;        //Force HS TX current enable and CDR stage select
			; SOURCE LINE # 349
	LCALL	L?0094
	MOV  	R7,A
	ADD  	A,#06H
	LCALL	L?0091
	ORL  	A,#040H
	MOVX 	@DPTR,A
;   XBYTE[gUTMI_BASE+0x06]&=~0x20;              //clear bit 5
			; SOURCE LINE # 350
	MOV  	A,#06H
	ADD  	A,R7
	LCALL	L?0091
	ANL  	A,#0DFH
; 
;   XBYTE[gUTMI_BASE+0x06]|=0x03;        //reset UTMI
			; SOURCE LINE # 352
	LCALL	L?0093
	MOV  	R7,A
	ADD  	A,#06H
	LCALL	L?0091
	ORL  	A,#03H
	MOVX 	@DPTR,A
;   XBYTE[gUTMI_BASE+0x06]&=0xfc;
			; SOURCE LINE # 353
	MOV  	A,#06H
	ADD  	A,R7
	LCALL	L?0091
	ANL  	A,#0FCH
;   XBYTE[gUTMI_BASE+0x29]=0x08;         //disable full speed retime
			; SOURCE LINE # 354
	LCALL	L?0093
	MOV  	R7,A
	ADD  	A,#029H
	LCALL	L?0100
	MOV  	A,#08H
	MOVX 	@DPTR,A
; #ifdef  Enable_Issue_TestPacket
;   XBYTE[gUTMI_BASE+0x03]=0;         //for device disconnect status bit
; #else
;   XBYTE[gUTMI_BASE+0x03]=0xa8;         //for device disconnect status bit
			; SOURCE LINE # 358
	MOV  	DPL,R7
	MOV  	DPH,R6
	INC  	DPTR
	INC  	DPTR
	INC  	DPTR
	MOV  	A,#0A8H
	MOVX 	@DPTR,A
; #endif
;   //XBYTE[gUTMI_BASE+0x07]|=0x02;      //
;   #ifdef DTV_STANDARD_LIB
;    if  (XBYTE[0x1ecc]==0x02)            //Neptune , after U06
			; SOURCE LINE # 362
	MOV  	DPTR,#01ECCH
	MOVX 	A,@DPTR
	XRL  	A,#02H
	JNZ  	?C0005
;    {
			; SOURCE LINE # 363
;       if (XBYTE[0x1ecf]>= 0x06)              //U07
			; SOURCE LINE # 364
	MOV  	DPTR,#01ECFH
	MOVX 	A,@DPTR
	CLR  	C
	SUBB 	A,#06H
	LCALL	L?0094
	MOV  	R7,A
	JC   	?C0006
;         {
			; SOURCE LINE # 365
;             XBYTE[gUTMI_BASE+0x07]|=0x02;
			; SOURCE LINE # 366
	ADD  	A,#07H
	LCALL	L?0091
	ORL  	A,#02H
	MOVX 	@DPTR,A
;             XBYTE[gUTMI_BASE+0x2c]=0xc1;
			; SOURCE LINE # 367
	MOV  	A,#02CH
	ADD  	A,R7
	LCALL	L?0100
	MOV  	A,#0C1H
;             XBYTE[gUTMI_BASE+0x2d]=0x3b;//enable TX common mode,
			; SOURCE LINE # 368
	LCALL	L?0093
	MOV  	R7,A
	ADD  	A,#02DH
;             XBYTE[gUTMI_BASE+0x2f]|=0x0e;            //preemsis
			; SOURCE LINE # 369
;         }
			; SOURCE LINE # 370
	LJMP 	?C0083
?C0006:
;       else          //before U06
;         {
			; SOURCE LINE # 372
;             XBYTE[gUTMI_BASE+0x2c]|=0x01;
			; SOURCE LINE # 373
;              XBYTE[gUTMI_BASE+0x2d]=0x38;         //disable TX common mode
			; SOURCE LINE # 374
; 
;         }
			; SOURCE LINE # 376
;     }
			; SOURCE LINE # 377
	LJMP 	?C0082
?C0005:
;      else if ((XBYTE[0x1ecc]>=3)&&(XBYTE[0x1ecc]<5))                    //Eris: 3 ,Titania: 4,
			; SOURCE LINE # 378
	MOV  	DPTR,#01ECCH
	MOVX 	A,@DPTR
	CLR  	C
	SUBB 	A,#03H
	JC   	?C0009
	MOVX 	A,@DPTR
	SUBB 	A,#05H
	JNC  	?C0009
;     {
			; SOURCE LINE # 379
;             XBYTE[gUTMI_BASE+0x2c]=0xc5;
			; SOURCE LINE # 380
	LCALL	L?0094
	LCALL	L?0099
	MOV  	A,#0C5H
	MOVX 	@DPTR,A
;             XBYTE[gUTMI_BASE+0x2d]=0x3b;//enable TX common mode,
			; SOURCE LINE # 381
	MOV  	A,#02DH
	ADD  	A,R7
?C0081:
;             XBYTE[gUTMI_BASE+0x2f]|=0x0e;            //preemsis
			; SOURCE LINE # 382
;     }
			; SOURCE LINE # 383
	LJMP 	?C0083
?C0009:
;     else if (XBYTE[0x1ecc]==5)          // Pluto: 5
			; SOURCE LINE # 384
	MOV  	DPTR,#01ECCH
	MOVX 	A,@DPTR
	CJNE 	A,#05H,?C0011
;     {
			; SOURCE LINE # 385
;        //     XBYTE[gUTMI_BASE+0x2c]|=0xc5;
;           //  XBYTE[gUTMI_BASE+0x2d]|=0x3;//enable TX common mode,
;           //  XBYTE[gUTMI_BASE+0x2f]|=0x4a;            //preemsis
;            if (XBYTE[0x1ecf]<= 0x03)
			; SOURCE LINE # 389
	MOV  	DPTR,#01ECFH
	MOVX 	A,@DPTR
	SETB 	C
	SUBB 	A,#03H
	JNC  	?C0008
;                XBYTE[gUTMI_BASE+0x13]|=0x70;        //U04 and later don't set
			; SOURCE LINE # 390
	LCALL	L?0094
	ADD  	A,#013H
	LCALL	L?0091
	ORL  	A,#070H
	MOVX 	@DPTR,A
;      }
			; SOURCE LINE # 391
	LJMP 	?C0008
?C0011:
;     else if (XBYTE[0x1ecc]==0x0b)          // Titania 2
			; SOURCE LINE # 392
	MOV  	DPTR,#01ECCH
	MOVX 	A,@DPTR
	XRL  	A,#0BH
	JNZ  	?C0014
;     {
			; SOURCE LINE # 393
;             XBYTE[gUTMI_BASE+0x2c]|=0xc1;
			; SOURCE LINE # 394
	LCALL	L?0094
	MOV  	R7,A
	ADD  	A,#02CH
	LCALL	L?0091
	ORL  	A,#0C1H
	MOVX 	@DPTR,A
;             XBYTE[gUTMI_BASE+0x2d]|=0x3;//enable TX common mode,
			; SOURCE LINE # 395
	MOV  	A,#02DH
	ADD  	A,R7
	LCALL	L?0091
	ORL  	A,#03H
;             XBYTE[gUTMI_BASE+0x2f]|=0x4a;            //preemsis
			; SOURCE LINE # 396
	LCALL	L?0093
	ADD  	A,#02FH
	LCALL	L?0091
	ORL  	A,#04AH
	MOVX 	@DPTR,A
;      }
			; SOURCE LINE # 397
	SJMP 	?C0008
?C0014:
;     else if (XBYTE[0x1ecc]==6)        //Triton=6
			; SOURCE LINE # 398
	MOV  	DPTR,#01ECCH
	MOVX 	A,@DPTR
	MOV  	DPTR,#gUTMI_BASE
	CJNE 	A,#06H,?C0016
;     {
			; SOURCE LINE # 399
;             XBYTE[gUTMI_BASE+0x2c]=0xc1;
			; SOURCE LINE # 400
	MOVX 	A,@DPTR
	MOV  	R6,A
	INC  	DPTR
	MOVX 	A,@DPTR
	LCALL	L?0099
	MOV  	A,#0C1H
	MOVX 	@DPTR,A
;             XBYTE[gUTMI_BASE+0x2d]=0x3b;//enable TX common mode,
			; SOURCE LINE # 401
	MOV  	A,#02DH
	ADD  	A,R7
?C0083:
	LCALL	L?0100
	MOV  	A,#03BH
	MOVX 	@DPTR,A
;             XBYTE[gUTMI_BASE+0x2f]|=0x0e;            //preemsis
			; SOURCE LINE # 402
	MOV  	A,#02FH
	ADD  	A,R7
	LCALL	L?0091
	ORL  	A,#0EH
	MOVX 	@DPTR,A
;     }
			; SOURCE LINE # 403
	SJMP 	?C0008
?C0016:
; 
;   else                                //before U06
;   {
			; SOURCE LINE # 406
;     XBYTE[gUTMI_BASE+0x2c]|=0x01;
			; SOURCE LINE # 407
	MOVX 	A,@DPTR
	MOV  	R6,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R7,A
?C0082:
	ADD  	A,#02CH
	LCALL	L?0091
	ORL  	A,#01H
	MOVX 	@DPTR,A
;     #ifndef Process_018_USE
;     XBYTE[gUTMI_BASE+0x2d]=0x38;         //disable TX common mode
			; SOURCE LINE # 409
	MOV  	A,#02DH
	ADD  	A,R7
	LCALL	L?0100
	MOV  	A,#038H
	MOVX 	@DPTR,A
;     #endif
;   }
			; SOURCE LINE # 411
?C0008:
;   #endif
; 
;   #ifdef CERAMAL_SERISE_USE
;   if (CHIP_VERSION >= CHIP_VER_U03)
;   {
;     XBYTE[gUTMI_BASE+0x2c]|=0xc1;     //Slew rate control,Common mode voltage,Pre-emphasis select
;     XBYTE[gUTMI_BASE+0x2d]|=0x07;     //HS RTerm current: 5/6,Enable common mode adjust,Enable common mode voltage,Pre-emphasis select
;     XBYTE[gUTMI_BASE+0x2f]|=0x0e;     //Enable pre-emphasis at data enable edge,Enable pre-emphasis at data transition edge,Enable pre-emphasis
;   }
;   #endif
; 
;   if (XBYTE[0x1ecc]==5)                   // If is Pluto
			; SOURCE LINE # 423
	MOV  	DPTR,#01ECCH
	MOVX 	A,@DPTR
	MOV  	DPTR,#gUTMI_BASE
	CJNE 	A,#05H,?C0018
;       XBYTE[gUTMI_BASE+0x09]|=0x01;     //ISI improvement
			; SOURCE LINE # 424
	MOVX 	A,@DPTR
	MOV  	R6,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#09H
	LCALL	L?0091
	ORL  	A,#01H
	MOVX 	@DPTR,A
	SJMP 	?C0019
?C0018:
;   else
;       XBYTE[gUTMI_BASE+0x13]|=0x02;     //ISI improvement
			; SOURCE LINE # 426
	MOVX 	A,@DPTR
	MOV  	R6,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#013H
	LCALL	L?0091
	ORL  	A,#02H
	MOVX 	@DPTR,A
?C0019:
; 
;   XBYTE[gUTMI_BASE+0x09]|=0x60;//0x20;       //patch low tempture,FL meta issue and enable new FL RX engin
			; SOURCE LINE # 428
	LCALL	L?0094
	MOV  	R7,A
	ADD  	A,#09H
	LCALL	L?0091
	ORL  	A,#060H
	MOVX 	@DPTR,A
; 
;    if (mwOTG20_Control_HOST_SPD_TYP_Rd()==1)            //low speed,for HID
			; SOURCE LINE # 430
	MOV  	DPTR,#gUHC_BASE
	MOVX 	A,@DPTR
	MOV  	R4,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ORL  	A,#041H
	MOV  	DPL,A
	MOV  	DPH,R4
	MOVX 	A,@DPTR
	CLR  	C
	RRC  	A
	ANL  	A,#03H
	MOV  	R5,A
	CJNE 	R5,#01H,?C0020
;             XBYTE[gUTMI_BASE+0x09]&=~0x40;                      //old setting
			; SOURCE LINE # 431
	MOV  	A,#09H
	ADD  	A,R7
	LCALL	L?0091
	ANL  	A,#0BFH
	MOVX 	@DPTR,A
?C0020:
; 
; 
;   XBYTE[gUTMI_BASE+0x27]&=0xf3;
			; SOURCE LINE # 434
	LCALL	L?0094
	MOV  	R7,A
	ADD  	A,#027H
	LCALL	L?0091
	ANL  	A,#0F3H
	MOVX 	@DPTR,A
;   XBYTE[gUTMI_BASE+0x27]|=0x08;		//(1) Offset 27 (．h3AA7) bit <3:2> set 2・b10   // RX bias current => 60uA (default 40uA)
			; SOURCE LINE # 435
	MOV  	A,#027H
	ADD  	A,R7
	LCALL	L?0091
	ORL  	A,#08H
; 
;   //(2) Offset 2A (．h3AAA) bit <3:2> set 2・b11               // Squelch voltage => 100mV (default 150mV)
; #ifdef DTV_STANDARD_LIB
;   XBYTE[gUTMI_BASE+0x2a]=0x07;
			; SOURCE LINE # 439
	LCALL	L?0093
	MOV  	R7,A
	ADD  	A,#02AH
	LCALL	L?0100
	MOV  	A,#07H
	MOVX 	@DPTR,A
; #endif
; 
;   XBYTE[gUTMI_BASE+0x15]|=0x20; //HOST CHIRP Detect
			; SOURCE LINE # 442
	MOV  	A,#015H
	ADD  	A,R7
	LCALL	L?0091
	ORL  	A,#020H
	MOVX 	@DPTR,A
; 
;   //(3) Offset 2D (．h3AAD) bit <5:3> set 3・b111           // HS_RTERM bias current 5/6
;   //XBYTE[0x128a]=0x87;            //change UHC priority
;   //XBYTE[0x128d]&=0x0f;                //clear bit 12~15
;   //XBYTE[0x128e]|=0xf;            //upgrade UHC priority, set bit 0~3
;   MDrv_Timer_Delayms(500);
			; SOURCE LINE # 448
	MOV  	R7,#0F4H
	MOV  	R6,#01H
	LCALL	_Delay1ms
; 
; 
;   //MDrv_Sys_SetXdataWindow1Base(USB_BUFFER_START_ADR_4K_ALIGN>>12);        //switch window 1
;   gUsbStatus=USB_OK;
			; SOURCE LINE # 452
	CLR  	A
	MOV  	DPTR,#gUsbStatus
	MOVX 	@DPTR,A
;  // gUsbTimeout=3;  //set at flib_Host20_Enumerate()
;   RecoveryFlag=0;             //initialize recovery flag
			; SOURCE LINE # 454
	MOV  	DPTR,#RecoveryFlag
	MOVX 	@DPTR,A
;   gUsbDeviceState=USB11_DEVICE;           //1.1 at first
			; SOURCE LINE # 455
	MOV  	DPTR,#gUsbDeviceState
	INC  	A
	MOVX 	@DPTR,A
; 
;   //gDeviceFatalError=FALSE;
;   if(flib_OTGH_Init(0))
			; SOURCE LINE # 458
	CLR  	A
	MOV  	R7,A
	LCALL	_flib_OTGH_Init
	MOV  	A,R7
	JZ   	?C0021
;     result =TRUE;
			; SOURCE LINE # 459
	MOV  	DPTR,#result?040
	MOV  	A,#01H
	MOVX 	@DPTR,A
?C0021:
; 
;   #ifdef USE_XDATA_ADDRESS_0XF000
;   MDrv_USB_ReleaseXdataWindow1();
;   #endif
; 
;   return result;
			; SOURCE LINE # 465
	MOV  	DPTR,#result?040
	MOVX 	A,@DPTR
	MOV  	R7,A
; 
; }
			; SOURCE LINE # 467
?C0004:
	RET  	
; END OF MDrv_UsbHost_Init

; #if 0
; BOOLEAN MDrv_UsbHost_Init_Enum(void)
; {
;   BOOLEAN result;
;   result=MDrv_Usb_Device_Enum();
;   return result;
; }
; #endif
; #ifdef Enable_Mass_Storage
; U8 MDrv_UsbGetMaxLUNCount()
; {
;   if (gUsbDeviceState==BAD_DEVICE)
;     return 0;
; 
;   if (mwHost20_PORTSC_ConnectStatus_Rd()==0)
;     return 0;
;   else return (Mass_stor_us1.max_lun+1);
; }
; U8 MDrv_GET_MASS_MAX_LUN()
; {
;   //printf("Get max lun func:%02bx\n",Mass_stor_us1.max_lun);
;   if (mwHost20_PORTSC_ConnectStatus_Rd()==0)
;     return 0;
;   else return Mass_stor_us1.max_lun;
; }
; extern void GetValidLun(void);
; #endif
; 
; 
; #if 0//def ATV_SERISE_USE
; void DisableINT(void)
; {
;   XBYTE[0x2B03]|=0x20;
;   XBYTE[0x2B18]|=0x80;
;   XBYTE[0x2B19]|=0x04;
;   XBYTE[0x2B1A]|=0x80;
; }
; void EnableINT(void)
; {
;   XBYTE[0x2B03]&=0xDF;
;   XBYTE[0x2B18]&=0x7F;
;   XBYTE[0x2B19]&=0xFB;
;   XBYTE[0x2B1A]&=0x7F;
; }
; #endif
; 
; #ifdef Enable_Mass_Storage
; extern U8 ValidLunNum;
; U8 MDrv_GET_VALID_LUN_NUM()
; {
;     return ValidLunNum;
; }
; U8 MDrv_GET_MASS_VALID_LUN()
; {
;   U8 LunMatrix=0,i;
;   struct LUN_Device* LunDevice;
;   //printf("Get valid lun func\n");
;   if (mwHost20_PORTSC_ConnectStatus_Rd()==0)
;     return USB_NOT_RESPONSE;               //device is not connected
; 
;   if (gUsbDeviceState==BAD_DEVICE) return 0;
; 
;   if (gSpeed==1)    return 0;           //low speed device
; 
;   //if (gDeviceFatalError) return USB_NOT_RESPONSE;
;   if (gUsbStatus==USB_EJECT) return USB_NOT_RESPONSE;
; 
;   #ifdef USE_XDATA_ADDRESS_0XF000
;   MDrv_USB_SetXdataWindow1();        //switch window 1
;   #endif
; 
;   LunDevice = Mass_stor_us1.Mass_stor_device;
; 
;   #ifdef ATV_SERISE_USE
;     #ifdef Enable_Close_INT
;     //XBYTE[0x2B00]|=0x02;
;     DisableINT();
;     #endif
;   #endif
;   GetValidLun();
;   #ifdef ATV_SERISE_USE
;     #ifdef Enable_Close_INT
;     //XBYTE[0x2B00]&=0xFD;
;     EnableINT();
;     #endif
;   #endif
; 
;   if (gUsbStatus==USB_TIMEOUT)
;   {
;     #ifdef USE_XDATA_ADDRESS_0XF000
;     MDrv_USB_ReleaseXdataWindow1();
;     #endif
;     return USB_NOT_RESPONSE;            //USB DEVICE not responding
;   }
; 
;   for (i=0; i <= Mass_stor_us1.max_lun ; i++)
;   {
;     LunMatrix=LunMatrix<<1 ;
; 	//printf("bDeviceReady:%02bx\n",LunDevice[Mass_stor_us1.max_lun-i].bDeviceReady);
;  	if (LunDevice[Mass_stor_us1.max_lun-i].bDeviceReady == TRUE)
;  	{
; 	  LunMatrix|=1;
;  	}
;   }
;   //printf("GetReadyLun:%02bx\n",LunMatrix);
;   #ifdef USE_XDATA_ADDRESS_0XF000
;   MDrv_USB_ReleaseXdataWindow1();
;   #endif
; 
;   return LunMatrix;
; }
; #endif
; 
; U32 USB_BUFFER_START_ADR_4K_ALIGN_Var;
; #ifndef USE_XDATA_ADDRESS_0XF000
; #ifndef CERAMAL_SERISE_USE
; extern DWORD jpCVBS5_Get_HK_XDATA_Addr(void);
; #endif
; #endif
; void MDrv_USB_Init(U32 USBAdr)

	RSEG  ?PR?_MDrv_USB_Init?DRVUSBMAIN
_MDrv_USB_Init:
	USING	0
			; SOURCE LINE # 587
;---- Variable 'USBAdr?141' assigned to Register 'R4/R5/R6/R7' ----
; {
			; SOURCE LINE # 588
;   //gProjectCode=ProjectCode;
;   //gDeviceFatalError=FALSE;
; 
;   #ifdef USE_XDATA_ADDRESS_0XF000
;   USB_BUFFER_START_ADR_4K_ALIGN_Var=USBAdr;
;   #else
;   USBAdr=0;
			; SOURCE LINE # 595
	CLR  	A
	MOV  	R7,A
	MOV  	R6,A
	MOV  	R5,A
	MOV  	R4,A
;   #ifdef CERAMAL_SERISE_USE
;   USB_BUFFER_START_ADR_4K_ALIGN_Var=BASEADR_SDRAM_MCU_XDATA;
;   #else
;   USB_BUFFER_START_ADR_4K_ALIGN_Var=jpCVBS5_Get_HK_XDATA_Addr();
			; SOURCE LINE # 599
	LCALL	jpCVBS5_Get_HK_XDATA_Addr
	MOV  	DPTR,#USB_BUFFER_START_ADR_4K_ALIGN_Var
	LCALL	?C?LSTXDATA
;   #endif
;   //printf("\r\n USB_BUFFER_START_ADR_4K_ALIGN_Var=%x",(U16)(USB_BUFFER_START_ADR_4K_ALIGN_Var>>16));
;   //printf(",%x",(U16)(USB_BUFFER_START_ADR_4K_ALIGN_Var));
;   #endif
; 
;   if (USB_BUFFER_START_ADR_4K_ALIGN_Var % 4096 != 0)
			; SOURCE LINE # 605
;   {
			; SOURCE LINE # 606
;     DRV_USB_DBG( printf("Error USB Starting address is not 4K alignmented\n"));
;   }
			; SOURCE LINE # 608
?C0022:
; 
; #if 1
;   if (!drvUSBHost_isPowerSaveModeEnable())
			; SOURCE LINE # 611
	LCALL	drvUSBHost_isPowerSaveModeEnable
	MOV  	A,R7
	JNZ  	?C0024
;   {
			; SOURCE LINE # 612
;     mbFUSBH200_VBUS_ON_Set();
			; SOURCE LINE # 613
;     UHC_XBYTE(0x34)&=0xBF; //set suspend
			; SOURCE LINE # 614
;     UHC_XBYTE(0x34)|=0x40; //clr suspend
			; SOURCE LINE # 615
	LCALL	L?0090
	ORL  	A,#040H
	MOVX 	@DPTR,A
;     MDrv_Timer_Delayms(2);
			; SOURCE LINE # 616
	MOV  	R7,#02H
	MOV  	R6,#00H
	LCALL	_Delay1ms
;     XBYTE[gUTMI_BASE+0x00]|=0x01;		// override mode enable for power down control
			; SOURCE LINE # 617
;     XBYTE[gUTMI_BASE+0x01]|=0x40;	// enable IREF power down
			; SOURCE LINE # 618
;     XBYTE[gUTMI_BASE+0x01]|=0x02;   // enable PLL power down
			; SOURCE LINE # 619
;     XBYTE[gUTMI_BASE+0x01]&=0xFD;   // disable PLL power down
			; SOURCE LINE # 620
	LCALL	L?0092
	MOV  	DPL,A
	MOV  	DPH,R6
	INC  	DPTR
	MOVX 	A,@DPTR
	ANL  	A,#0FDH
;     mbHost20_USBCMD_HCReset_Set();
			; SOURCE LINE # 621
	LCALL	L?0095
;   }
			; SOURCE LINE # 622
; 
; #else
;   #ifndef USB_POWER_SAVING_MODE
;   mbFUSBH200_VBUS_ON_Set();
;   UHC_XBYTE(0x34)&=0xBF; //set suspend
;   UHC_XBYTE(0x34)|=0x40; //clr suspend
;   MDrv_Timer_Delayms(2);
;   XBYTE[gUTMI_BASE+0x00]|=0x01;		// override mode enable for power down control
;   XBYTE[gUTMI_BASE+0x01]|=0x40;	// enable IREF power down
;   XBYTE[gUTMI_BASE+0x01]|=0x02;   // enable PLL power down
;   XBYTE[gUTMI_BASE+0x01]&=0xFD;   // disable PLL power down
;   mbHost20_USBCMD_HCReset_Set();
;   #endif
; #endif
; 
;   #ifdef CERAMAL_SERISE_USE
;     #if (CERAMAL_STEPPING>=2)
;     XBYTE[gUTMI_BASE+0x06]|=0x04; //HSTXIEN
;     XBYTE[gUTMI_BASE+0x00]=0x0;   //disable power down over write
;     XBYTE[0x2601]|=0x20;            //HsEnable set of usb power register
;     XBYTE[gUTMI_BASE+0x01]=0x0;   //disable power down over write  high byte
;     XBYTE[0x2500]|=0x08;            //disable init suspend state
;     MDrv_Timer_Delayms(3);
;     #endif
;   XBYTE[0x2502]|=0x10; //id pull up
;   XBYTE[gUTMI_BASE+0x06]|=0x80; //dual otg mode
;   #endif
; }
			; SOURCE LINE # 650
?C0024:
	RET  	
; END OF _MDrv_USB_Init

; 
; #if 0
; U8  MDrv_GetUsbDeviceStatus()
; {
;   return gUsbDeviceState;
; }
; 
; void MDrv_SetUsbDeviceStatus(U8 status)
; {
;   gUsbDeviceState = status;
; }
; 
; void  MDrv_ClearUsbDeviceStatus()
; {
;   //if (gUsbDeviceState==BAD_DEVICE)
;   //{
;   //  printf("Clear bad device\n");
;   //  gUsbDeviceState=USB11_DEVICE;
;   //}
; }
; #endif
; void ResetUsbHardware()

	RSEG  ?PR?ResetUsbHardware?DRVUSBMAIN
ResetUsbHardware:
	USING	0
			; SOURCE LINE # 672
; {
			; SOURCE LINE # 673
; #if 0
;   XBYTE[gUTMI_BASE+0x06]|=0x03;        //reset UTMI
;   XBYTE[gUTMI_BASE+0x06]&=0xfc;
;   mbHost20_USBCMD_HCReset_Set();
; #else
;     if ( (XBYTE[0x1ecc]==5) && (XBYTE[0x1ecf]<= 0x03) )
			; SOURCE LINE # 679
	MOV  	DPTR,#01ECCH
	MOVX 	A,@DPTR
	XRL  	A,#05H
	JNZ  	?C0025
	MOV  	DPTR,#01ECFH
	MOVX 	A,@DPTR
	SETB 	C
	SUBB 	A,#03H
	JNC  	?C0025
;     {  // Pluto: 5 U02 and U03 has bugs, reset RX would make port2 stoped.
			; SOURCE LINE # 680
;         XBYTE[gUTMI_BASE+0x06]|=0x02;        //reset UTMI
			; SOURCE LINE # 681
	LCALL	L?0094
	ADD  	A,#06H
	LCALL	L?0091
	ORL  	A,#02H
;         mbHost20_USBCMD_HCReset_Set();
			; SOURCE LINE # 682
	LCALL	L?0095
;         MDrv_Timer_Delayms(2);
			; SOURCE LINE # 683
	MOV  	R7,#02H
	MOV  	R6,#00H
	LCALL	_Delay1ms
;         XBYTE[gUTMI_BASE+0x06]&=0xfd;
			; SOURCE LINE # 684
	LCALL	L?0094
	ADD  	A,#06H
	LCALL	L?0091
	ANL  	A,#0FDH
	MOVX 	@DPTR,A
;     }
			; SOURCE LINE # 685
	RET  	
?C0025:
;     else
;     {
			; SOURCE LINE # 687
;         XBYTE[gUTMI_BASE+0x06]|=0x03;        //reset UTMI
			; SOURCE LINE # 688
	LCALL	L?0094
	ADD  	A,#06H
	LCALL	L?0091
	ORL  	A,#03H
;         mbHost20_USBCMD_HCReset_Set();
			; SOURCE LINE # 689
	LCALL	L?0096
;         MDrv_Timer_Delayms(2);
			; SOURCE LINE # 690
	MOV  	R7,#02H
	MOV  	R6,#00H
	LCALL	_Delay1ms
;         XBYTE[gUTMI_BASE+0x06]&=0xfc;
			; SOURCE LINE # 691
	LCALL	L?0094
	ADD  	A,#06H
	LCALL	L?0091
	ANL  	A,#0FCH
	MOVX 	@DPTR,A
;     }
			; SOURCE LINE # 692
; #endif
;   //MDrv_Timer_Delayms(200);
; }
			; SOURCE LINE # 695
?C0027:
	RET  	
; END OF ResetUsbHardware

; UINT32 UsbStartTime=0;
; UINT32 UsbPowerSavingTimer=0;
; 
; #ifdef CERAMAL_SERISE_USE
; void FUSBH200_Driver_VBUS(void)
; {
;   XBYTE[0x1E14]|=0x80; // GPIO AO enable, reg_drvbus_en=1, eable drive vbus pad
;   mbFUSBH200_VBUS_ON_Set();
; }
; #endif
; 
; #if 1
; void UsbPort0UTMIInitial(void)

	RSEG  ?PR?UsbPort0UTMIInitial?DRVUSBMAIN
UsbPort0UTMIInitial:
	USING	0
			; SOURCE LINE # 708
; {
			; SOURCE LINE # 709
;    mbFUSBH200_VBUS_ON_Set();
			; SOURCE LINE # 710
;    UHC_XBYTE(0x34)&=0xBF; //set suspend
			; SOURCE LINE # 711
;    UHC_XBYTE(0x34)|=0x40; //clr suspend
			; SOURCE LINE # 712
	LCALL	L?0090
	ORL  	A,#040H
	MOVX 	@DPTR,A
;    MDrv_Timer_Delayms(2);
			; SOURCE LINE # 713
	MOV  	R7,#02H
	MOV  	R6,#00H
	LCALL	_Delay1ms
;    XBYTE[gUTMI_BASE+0x00]|=0x01;		// override mode enable for power down control
			; SOURCE LINE # 714
;    XBYTE[gUTMI_BASE+0x01]|=0x40;	// enable IREF power down
			; SOURCE LINE # 715
;    XBYTE[gUTMI_BASE+0x01]|=0x02;   // enable PLL power down
			; SOURCE LINE # 716
;    XBYTE[gUTMI_BASE+0x01]&=0xFD;   // disable PLL power down
			; SOURCE LINE # 717
	LCALL	L?0092
	MOV  	R7,A
	MOV  	DPL,A
	MOV  	DPH,R6
	INC  	DPTR
	MOVX 	A,@DPTR
	ANL  	A,#0FDH
	MOVX 	@DPTR,A
;    XBYTE[gUTMI_BASE+0x00]&=~0x01;		// override mode enable for power down control
			; SOURCE LINE # 718
	MOV  	DPL,R7
	MOV  	DPH,R6
	MOVX 	A,@DPTR
	ANL  	A,#0FEH
; 
;    mbHost20_USBCMD_HCReset_Set();
			; SOURCE LINE # 720
	LCALL	L?0096
; }
			; SOURCE LINE # 721
	RET  	
; END OF UsbPort0UTMIInitial

; #else
; #ifdef USB_POWER_SAVING_MODE
; void UsbTurnOffPowerDownMode(void)
; {
;     //Power On
;     XBYTE[gUTMI_BASE+8]&=0x7F;    //PD_BG_CURRENT
;     XBYTE[gUTMI_BASE+0x2c]|=0x04;    //Switch current from DVI
; 
;     //Port0
;     XBYTE[gUTMI_BASE+1]=0x6f;
;     XBYTE[gUTMI_BASE]=0xc4;
;     XBYTE[gUTMI_BASE+0x11]=0x00;
;     XBYTE[gUTMI_BASE+0x10]=0x00;
;     #ifdef USBHOST2PORT
;     //Port1
;     XBYTE[gUTMI2_BASE+1]=0x6f;
;     XBYTE[gUTMI2_BASE]=0xc4;
;     XBYTE[gUTMI2_BASE+0x11]=0x00;
;     XBYTE[gUTMI2_BASE+0x10]=0x00;
;     //Power On End
;     #endif
;     //open port 0
;     XBYTE[gUTMI_BASE+1]=0x00;
;     XBYTE[gUTMI_BASE]=0x00;
;     XBYTE[gUSBC_BASE]|=0x08; //disable init suspend state
;     XBYTE[gUSBC_BASE]|=0x20; //Enable UHC XIU
;     MDrv_Timer_Delayms(3);
;     XBYTE[gUSBC_BASE+2]|=0x01;  //UHC select enable
;     //end
; 
;     // Power On USB UHC0
;     XBYTE[gUHC_BASE+0x34] |= 0x40;
; 
;     MDrv_Timer_Delayms(2);
;     XBYTE[gUHC_BASE+0x40] &=~0x10;
; 
;     #ifdef USBHOST2PORT
;     //open port 1
;     XBYTE[gUTMI2_BASE]=0x00;   //disable power down over write
;     XBYTE[gUTMI2_BASE+1]=0x00;   //disable power down over write high byte
;     XBYTE[gUSBC_BASE]|=0x08;  //disable init suspend state
;     XBYTE[gUSBC_BASE]|=0x20;  //Enable UHC XIU
;     MDrv_Timer_Delayms(3);
;     XBYTE[gUSBC_BASE+2]|=0x01;  //UHC select enable
;     //end
; 
;     // Power On USB UHC1
;     XBYTE[UHC2_BASE+0x34] |= 0x40;
;     MDrv_Timer_Delayms(2);
;     XBYTE[UHC2_BASE+0x40] &=~0x10;
;     #endif
; }
; 
; void UsbTurnOnPowerDownMode(void)
; {
;     MDrv_Timer_Delayms(2);
; 
;    XBYTE[gUSBC_BASE]&=0xD0; //Disable Port0 UHC XIU
;    #ifdef USBHOST2PORT
;    XBYTE[gUSBC2_BASE]&=0xD0; //Disable Port1 UHC XIU
;    #endif
;    XBYTE[gUTMI_BASE+8]|=0x80;    //PD_BG_CURRENT
;    XBYTE[gUTMI_BASE+0x2c]&=0xFB;    //Switch current from REXT, not DVI
; 
;    //Port 0
;    XBYTE[gUTMI_BASE+0x11]=0x88;     //bit<15>:HS_TX_OVERRIDE, bit<11>:FL_TX_OVERRIDE
;    XBYTE[gUTMI_BASE+0x10]=0x00;
;    XBYTE[gUTMI_BASE+3]=0x90;     //bit<15>:reg_hs_rterm_pdn, bit<7>:reg_bond_sel
;    XBYTE[gUTMI_BASE+2]=0x80;
;    XBYTE[gUTMI_BASE+1]=0xef;     //bit<15>:reg_pdn
;    XBYTE[gUTMI_BASE]=0xc7;
;    #ifdef USBHOST2PORT
;    //Port 1
;    XBYTE[gUTMI2_BASE+0x11]=0x88;
;    XBYTE[gUTMI2_BASE+0x10]=0x00;
;    XBYTE[gUTMI2_BASE+3]=0x90;
;    XBYTE[gUTMI2_BASE+2]=0x80;
;    XBYTE[gUTMI2_BASE+1]=0xef;
;    XBYTE[gUTMI2_BASE]=0xc7;
;    #endif
; }
; 
; void UsbPort0UTMIInitial(void)
; {
;    mbFUSBH200_VBUS_ON_Set();
;    UHC_XBYTE(0x34)&=0xBF; //set suspend
;    UHC_XBYTE(0x34)|=0x40; //clr suspend
;    MDrv_Timer_Delayms(2);
;    XBYTE[gUTMI_BASE+0x00]|=0x01;		// override mode enable for power down control
;    XBYTE[gUTMI_BASE+0x01]|=0x40;	// enable IREF power down
;    XBYTE[gUTMI_BASE+0x01]|=0x02;   // enable PLL power down
;    XBYTE[gUTMI_BASE+0x01]&=0xFD;   // disable PLL power down
;    XBYTE[gUTMI_BASE+0x00]&=~0x01;		// override mode enable for power down control
; 
;    mbHost20_USBCMD_HCReset_Set();
; }
; extern void UsbPort1UTMIInitial(void);
; #endif
; #endif
; BOOLEAN MDrv_UsbDeviceConnect(void)

	RSEG  ?PR?MDrv_UsbDeviceConnect?DRVUSBMAIN
MDrv_UsbDeviceConnect:
	USING	0
			; SOURCE LINE # 821
; {
			; SOURCE LINE # 822
;   /*
;   if (gDeviceFatalError)
;   {
;     gDeviceFatalError=FALSE;
;     ResetUsbHardware();
;     return FALSE;
;   }*/
;   #if 1
;   if (drvUSBHost_isPowerSaveModeEnable())
			; SOURCE LINE # 831
	LCALL	drvUSBHost_isPowerSaveModeEnable
	MOV  	A,R7
	JZ   	?C0029
;   {
			; SOURCE LINE # 832
;     //#ifdef USBHOST2PORT
;     if (gUsbDeviceState_Port2==WAIT_INIT)
			; SOURCE LINE # 834
	MOV  	DPTR,#gUsbDeviceState_Port2
	MOVX 	A,@DPTR
	CJNE 	A,#06H,?C0030
;         return FALSE;
			; SOURCE LINE # 835
	MOV  	R7,#00H
	RET  	
?C0030:
;     //#endif
;     if (gUsbDeviceState==WAIT_INIT)
			; SOURCE LINE # 837
	MOV  	DPTR,#gUsbDeviceState
	MOVX 	A,@DPTR
	CJNE 	A,#06H,?C0032
;     {
			; SOURCE LINE # 838
;         if (MDrv_Timer_DiffTimeFromNow(UsbPowerSavingTimer) < 300 )
			; SOURCE LINE # 839
	MOV  	DPTR,#UsbPowerSavingTimer
	LCALL	L?0101
	MOV  	R7,A
	LCALL	_MDrv_Timer_DiffTimeFromNow
	CLR  	A
	MOV  	R3,#02CH
	MOV  	R2,#01H
	MOV  	R1,A
	MOV  	R0,A
	SETB 	C
	LCALL	?C?ULCMP
	JC   	?C0032
;             return FALSE;
			; SOURCE LINE # 840
	MOV  	R7,#00H
	RET  	
;     }
			; SOURCE LINE # 841
?C0032:
;     if (gUsbDeviceState==POWER_SAVING)
			; SOURCE LINE # 842
	MOV  	DPTR,#gUsbDeviceState
	MOVX 	A,@DPTR
	XRL  	A,#05H
	JNZ  	?C0029
;     {
			; SOURCE LINE # 843
;        if (XBYTE[gUSBC_BASE+8]&0x40)
			; SOURCE LINE # 844
	MOV  	DPTR,#gUSBC_BASE
	MOVX 	A,@DPTR
	MOV  	R6,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#08H
	LCALL	L?0091
	JNB  	ACC.6,?C0035
;        {
			; SOURCE LINE # 845
;            UsbTurnOffPowerDownMode();
			; SOURCE LINE # 846
	LCALL	UsbTurnOffPowerDownMode
;            UsbPort0UTMIInitial();
			; SOURCE LINE # 847
	LCALL	UsbPort0UTMIInitial
;            //#ifdef USBHOST2PORT
;            if (drvUSBHost_isPort2Enable())
			; SOURCE LINE # 849
	LCALL	drvUSBHost_isPort2Enable
	MOV  	A,R7
	JZ   	?C0036
;           {
			; SOURCE LINE # 850
;                //UsbPort1UTMIInitial();
;                drvUSBHost_UTMIInitial_Port2();
			; SOURCE LINE # 852
	LCALL	drvUSBHost_UTMIInitial_Port2
;                if (gUsbDeviceState_Port2==POWER_SAVING)
			; SOURCE LINE # 853
	MOV  	DPTR,#gUsbDeviceState_Port2
	MOVX 	A,@DPTR
	CJNE 	A,#05H,?C0036
;                    gUsbDeviceState_Port2=NO_DEVICE;
			; SOURCE LINE # 854
	CLR  	A
	MOVX 	@DPTR,A
;           }
			; SOURCE LINE # 855
?C0036:
;            //#endif
;            UsbPowerSavingTimer = MDrv_Timer_GetTime0();
			; SOURCE LINE # 857
	LCALL	MDrv_Timer_GetTime0
	MOV  	A,R6
	RLC  	A
	SUBB 	A,ACC
	MOV  	R5,A
	MOV  	R4,A
	MOV  	DPTR,#UsbPowerSavingTimer
	LCALL	?C?LSTXDATA
;            gUsbDeviceState=WAIT_INIT;
			; SOURCE LINE # 858
	MOV  	DPTR,#gUsbDeviceState
	MOV  	A,#06H
	MOVX 	@DPTR,A
;            return FALSE;
			; SOURCE LINE # 859
	MOV  	R7,#00H
	RET  	
;            //MDrv_Timer_Delayms(300);
;        }
			; SOURCE LINE # 861
?C0035:
;        else
;        {
			; SOURCE LINE # 863
;            return FALSE;
			; SOURCE LINE # 864
	MOV  	R7,#00H
	RET  	
;        }
			; SOURCE LINE # 865
;     }
			; SOURCE LINE # 866
;   }
			; SOURCE LINE # 867
?C0029:
;   #else
;   #ifdef USB_POWER_SAVING_MODE
;   #ifdef USBHOST2PORT
;   if (gUsbDeviceState_Port2==WAIT_INIT)
;       return FALSE;
;   #endif
;   if (gUsbDeviceState==WAIT_INIT)
;   {
;       if (MDrv_Timer_DiffTimeFromNow(UsbPowerSavingTimer) < 300 )
;           return FALSE;
;   }
;   if (gUsbDeviceState==POWER_SAVING)
;   {
;      if (XBYTE[gUSBC_BASE+8]&0x40)
;      {
;          UsbTurnOffPowerDownMode();
;          UsbPort0UTMIInitial();
;          #ifdef USBHOST2PORT
;          UsbPort1UTMIInitial();
;          if (gUsbDeviceState_Port2==POWER_SAVING)
;              gUsbDeviceState_Port2=NO_DEVICE;
;          #endif
;          UsbPowerSavingTimer = MDrv_Timer_GetTime0();
;          gUsbDeviceState=WAIT_INIT;
;          return FALSE;
;          //MDrv_Timer_Delayms(300);
;      }
;      else
;      {
;          return FALSE;
;      }
;   }
;   #endif
;   #endif
;   if (gUsbStatus==USB_EJECT)
			; SOURCE LINE # 902
	MOV  	DPTR,#gUsbStatus
	MOVX 	A,@DPTR
	CJNE 	A,#04H,?C0039
;   {
			; SOURCE LINE # 903
;     if (UHC_XBYTE(0x30)&2)
			; SOURCE LINE # 904
	LCALL	L?0098
	ADD  	A,#030H
	LCALL	L?0091
	JNB  	ACC.1,?C0040
;     {
			; SOURCE LINE # 905
;       gUsbStatus=USB_OK;
			; SOURCE LINE # 906
	CLR  	A
	MOV  	DPTR,#gUsbStatus
	MOVX 	@DPTR,A
;     }
			; SOURCE LINE # 907
	SJMP 	?C0039
?C0040:
;     else
;       return FALSE;         //eject state
			; SOURCE LINE # 909
	MOV  	R7,#00H
	RET  	
;   }
			; SOURCE LINE # 910
?C0039:
;   //FUSBH200_Driver_VBUS();             //make sure device is connected , then turn on VBUS
; 
;   #ifdef OnePort_OTG_EHCI
;   if((XBYTE[gUTMI_BASE+0x30]&0x80))   //CID==1 device
;   {
;      XBYTE[0x2440]=0x10;                //turn-off vbus control to prevent OVC and VBUSERR
;      XBYTE[0x2502]=0x12;                // Enable OTG
;      if(XBYTE[0x2508] & 0x01)           //VBUSVALID=1
;      {
;         if(USBMode!=1)
;         {
;            //switch to otg mode and call init otg function
;            XBYTE[0x2440]=0x10; //turn-off vbus control to prevent OVC and VBUSERR
;            XBYTE[0x2502]=0x12;
;            //========================================================
;            // Derek testing
;            usbREG_WRITE8(REG_DEVCTL, usbREG_READ8(REG_DEVCTL) & (~M_DEVCTL_SESSION));// disable session
;            usbREG_WRITE8(USB_REG_POWER,usbREG_READ8(USB_REG_POWER)& (~M_POWER_SOFTCONN));
;            XBYTE[gUTMI_BASE+0x00] &= ~(reg_dp_puen+reg_term_override);//disable term_over and dp_puen
;            // Derek Added 2008/01/10, reset OTG IP
;            XBYTE[0x2500] = 0x6;
;            XBYTE[REG_UTMI_REG3]|=0x03;         //reset UTMI: prevent utmi error caused by switch
;            XBYTE[0x2500] = 0x0;
;            XBYTE[REG_UTMI_REG3]&=0xFC;
; 
;            if(XBYTE[0x2508] & 0x01)  // Derek debug
;            {
;                //add init otg here
;                MDrv_OTG_Init();
;                USBMode=1;
;            }
;            else
;            {
;                usbREG_WRITE8(REG_DEVCTL, usbREG_READ8(REG_DEVCTL) & (~M_DEVCTL_SESSION));// disable session
;                //printf("Disable Session\r\n");
;                usbUSBState = 0;
;            }
;         }
;      }
;      else
;      {
;         USBMode=0;
;         // Derek added
;         usbUSBState = 0;
;         usbREG_WRITE8(REG_DEVCTL, usbREG_READ8(REG_DEVCTL) & (~M_DEVCTL_SESSION));// disable session
;         //printf("Disable Session 2\r\n");
;         XBYTE[gUTMI_BASE+0x00] &= ~(reg_dp_puen+reg_term_override);
;      }
;      if(usbIsUSBConfiged())
;         return USBDeivceMode_connect;
;      else
;         return USBDeivceMode_disconnect;
;   }
;   else                                  //CID==0 host
;   {
;      //printf("\r\n SwToUHC\n");
;      if(USBMode!=2)
;      {
;         //disbale interrupt witch be active by OTG and switch to UHCI
;         MDrv_Disable_IRQ(IRQ_INTERRUPT_OTG_INT); //close OTG interrupt
;         XBYTE[0x2502]=0x11; //swicth to FARADAY UHC
;         XBYTE[REG_UTMI_REG3] |= (reg_rx_swreset+reg_utmi_tx_swreset);         //reset UTMI: prevent utmi error caused by switch
;         XBYTE[REG_UTMI_REG3] &= ~(reg_rx_swreset+reg_utmi_tx_swreset);
;         FUSBH200_Driver_VBUS();  //make sure device is connected , then turn on VBUS
;         MDrv_Timer_Delayms(100); //add delay time for UHC to complete device detection
;      }
;      USBMode=2;
;   }
;   #endif
;   if (mwHost20_PORTSC_ConnectStatus_Rd())
			; SOURCE LINE # 980
	LCALL	L?0098
	ORL  	A,#030H
	MOV  	R7,A
	MOV  	DPL,A
	MOV  	DPH,R6
	MOVX 	A,@DPTR
	JNB  	ACC.0,?C0042
;   {
			; SOURCE LINE # 981
;     if ( (gUsbDeviceState==USB11_DEVICE) ||(gUsbDeviceState==USB20_DEVICE) )
			; SOURCE LINE # 982
	MOV  	DPTR,#gUsbDeviceState
	MOVX 	A,@DPTR
	MOV  	R5,A
	XRL  	A,#01H
	JZ   	?C0044
	MOV  	A,R5
	XRL  	A,#02H
	JNZ  	?C0043
?C0044:
;     {
			; SOURCE LINE # 983
;         // If the device is connected and we get a connection change.
;         // It means that the user change the device and we just missed.
;         if (mwHost20_PORTSC_ConnectChange_Rd())
			; SOURCE LINE # 986
	MOV  	DPL,R7
	MOV  	DPH,R6
	MOVX 	A,@DPTR
	JNB  	ACC.1,?C0043
;         {
			; SOURCE LINE # 987
;             printMsg("dev changed, we missed\n");
			; SOURCE LINE # 988
	MOV  	R3,#0FFH
	MOV  	R2,#HIGH (?SC_8)
	MOV  	R1,#LOW (?SC_8)
	LCALL	_printMsg
;             gSpeed=0xff;  //reset this value
			; SOURCE LINE # 989
;             UHC_XBYTE(0x40)&=~0x80;//clear force enter FSmode
			; SOURCE LINE # 990
	LCALL	L?0097
	ADD  	A,#040H
	LCALL	L?0091
	ANL  	A,#07FH
	MOVX 	@DPTR,A
;             gUsbDeviceState = NO_DEVICE;
			; SOURCE LINE # 991
	CLR  	A
	MOV  	DPTR,#gUsbDeviceState
	MOVX 	@DPTR,A
;             return FALSE;
			; SOURCE LINE # 992
	MOV  	R7,A
	RET  	
;         }
			; SOURCE LINE # 993
;     }
			; SOURCE LINE # 994
?C0043:
; 
;      if (gUsbDeviceState==BAD_DEVICE) return FALSE;      //not repeating doing emunerate
			; SOURCE LINE # 996
	MOV  	DPTR,#gUsbDeviceState
	MOVX 	A,@DPTR
	MOV  	R6,A
	CJNE 	A,#03H,?C0046
	MOV  	R7,#00H
	RET  	
?C0046:
; 
;     //if (gSpeed==0x01)
;         //{
; //           MINI_DEBUG(printf("ls-exit\n"));
;     //       return FALSE;
;         //}
;     if (gUsbDeviceState==NO_DEVICE)
			; SOURCE LINE # 1003
	MOV  	A,R6
	JNZ  	?C0047
;         gUsbDeviceState=CONNECT_DEVICE;
			; SOURCE LINE # 1004
	MOV  	DPTR,#gUsbDeviceState
	MOV  	A,#04H
	MOVX 	@DPTR,A
?C0047:
;     #ifdef OnePort_OTG_EHCI
;     return USBHostMode_connect;
;     #else
;     return TRUE;
			; SOURCE LINE # 1008
	MOV  	R7,#01H
	RET  	
;     #endif
;   }
			; SOURCE LINE # 1010
?C0042:
;   else
;   {
			; SOURCE LINE # 1012
; 
;     gSpeed=0xff;  //reset this value
			; SOURCE LINE # 1014
;     UHC_XBYTE(0x40)&=~0x80;//clear force enter FSmode
			; SOURCE LINE # 1015
	LCALL	L?0097
	ADD  	A,#040H
	LCALL	L?0091
	ANL  	A,#07FH
	MOVX 	@DPTR,A
; #if 1
;     if (drvUSBHost_isPowerSaveModeEnable())
			; SOURCE LINE # 1017
	LCALL	drvUSBHost_isPowerSaveModeEnable
	MOV  	A,R7
	JZ   	?C0049
;     {
			; SOURCE LINE # 1018
;         //#ifdef USBHOST2PORT
;         if ((gUsbDeviceState_Port2==NO_DEVICE)||(gUsbDeviceState_Port2==POWER_SAVING))
			; SOURCE LINE # 1020
	MOV  	DPTR,#gUsbDeviceState_Port2
	MOVX 	A,@DPTR
	MOV  	R7,A
	JZ   	?C0051
	CJNE 	A,#05H,?C0050
?C0051:
;         //#endif
;         {
			; SOURCE LINE # 1022
;             if  (gUsbDeviceState!=POWER_SAVING)
			; SOURCE LINE # 1023
	MOV  	DPTR,#gUsbDeviceState
	MOVX 	A,@DPTR
	XRL  	A,#05H
	JZ   	?C0052
;                  UsbTurnOnPowerDownMode();
			; SOURCE LINE # 1024
	LCALL	UsbTurnOnPowerDownMode
?C0052:
;             gUsbDeviceState=POWER_SAVING;
			; SOURCE LINE # 1025
	MOV  	DPTR,#gUsbDeviceState
	MOV  	A,#05H
	MOVX 	@DPTR,A
;             //#ifdef USBHOST2PORT
;             if (drvUSBHost_isPort2Enable())
			; SOURCE LINE # 1027
	LCALL	drvUSBHost_isPort2Enable
	MOV  	A,R7
	JZ   	?C0055
;             {
			; SOURCE LINE # 1028
;                 gUsbDeviceState_Port2=POWER_SAVING;
			; SOURCE LINE # 1029
	MOV  	DPTR,#gUsbDeviceState_Port2
	MOV  	A,#05H
	MOVX 	@DPTR,A
;             }
			; SOURCE LINE # 1030
;             //#endif
;         }
			; SOURCE LINE # 1032
	SJMP 	?C0055
?C0050:
;         //#ifdef USBHOST2PORT
;         else
;             gUsbDeviceState=NO_DEVICE;
			; SOURCE LINE # 1035
;         //#endif
;     }
			; SOURCE LINE # 1037
	SJMP 	?C0084
?C0049:
;     else
;         gUsbDeviceState=NO_DEVICE;
			; SOURCE LINE # 1039
?C0084:
	CLR  	A
	MOV  	DPTR,#gUsbDeviceState
	MOVX 	@DPTR,A
?C0055:
; #else
;     #ifdef USB_POWER_SAVING_MODE
;     #ifdef USBHOST2PORT
;     if ((gUsbDeviceState_Port2==NO_DEVICE)||(gUsbDeviceState_Port2==POWER_SAVING))
;     #endif
;     {
;         if  (gUsbDeviceState!=POWER_SAVING)
;              UsbTurnOnPowerDownMode();
;         gUsbDeviceState=POWER_SAVING;
;         #ifdef USBHOST2PORT
;         gUsbDeviceState_Port2=POWER_SAVING;
;         #endif
;     }
;     #ifdef USBHOST2PORT
;     else
;         gUsbDeviceState=NO_DEVICE;
;     #endif
;     #else
;     gUsbDeviceState=NO_DEVICE;
;     #endif
; #endif
; 
;     #ifndef ATV_SERISE_USE
;     #ifdef CERAMAL_SERISE_USE
;     if (MDrv_Timer_TimeDifference(MDrv_Timer_GetTime0(), UsbStartTime) > 1000UL)
;     #else
;     if (MDrv_Timer_DiffTimeFromNow(UsbStartTime) > 1000 )
;     #endif
;     {
; 
;       UsbStartTime=MDrv_Timer_GetTime0();
;       ResetUsbHardware();
; 
;     }
;     #else
;     UsbStartTime++;
			; SOURCE LINE # 1075
	MOV  	DPTR,#UsbStartTime
	LCALL	L?0101
	ADD  	A,#01H
	MOV  	R7,A
	CLR  	A
	ADDC 	A,R6
	MOV  	R6,A
	CLR  	A
	ADDC 	A,R5
	MOV  	R5,A
	CLR  	A
	ADDC 	A,R4
	MOV  	R4,A
	MOV  	DPTR,#UsbStartTime
	LCALL	?C?LSTXDATA
;     if(UsbStartTime>0x600)
			; SOURCE LINE # 1076
	CLR  	A
	MOV  	R7,A
	MOV  	R6,#06H
	MOV  	R5,A
	MOV  	R4,A
	MOV  	DPTR,#UsbStartTime
	MOVX 	A,@DPTR
	MOV  	R0,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R1,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R3,A
	SETB 	C
	LCALL	?C?ULCMP
	JC   	?C0056
;     {
			; SOURCE LINE # 1077
;       UsbStartTime=0;
			; SOURCE LINE # 1078
	MOV  	DPTR,#UsbStartTime
	LCALL	?C?LSTKXDATA
	DB   	00H
	DB   	00H
	DB   	00H
	DB   	00H
; 	  ResetUsbHardware();
			; SOURCE LINE # 1079
	LCALL	ResetUsbHardware
;     }
			; SOURCE LINE # 1080
?C0056:
;     #endif
;     //MINI_DEBUG( printf("no_con \n"));
;     #ifdef OnePort_OTG_EHCI
;     return USBHostMode_disconnect;
;     #else
;     return FALSE;
			; SOURCE LINE # 1086
	MOV  	R7,#00H
;     #endif
;   }
			; SOURCE LINE # 1088
; }
			; SOURCE LINE # 1089
?C0031:
	RET  	
; END OF MDrv_UsbDeviceConnect

; 
; #ifdef Enable_Mass_Storage
; void MDrv_EjectUsbDevice(void)
; {
;   struct LUN_Device* LunDevice;
;   U8 i;
; 
;   #ifdef USE_XDATA_ADDRESS_0XF000
;   MDrv_USB_SetXdataWindow1();
;   #endif
; 
;   //printf("eject\n");
;   LunDevice = Mass_stor_us1.Mass_stor_device;
;   for (i=0; i <= Mass_stor_us1.max_lun ; i++)
;   {
; 
;     if (LunDevice[i].bDeviceReady == TRUE)
;  	{
; 	  vSCSI_EJECT_DEVICE(i);
;       gUsbStatus=USB_EJECT;
;       mwHost20_PORTSC_ConnectChange_Set();        //clear port connect change bit
;       //printf("ej_ok\n");
;  	}
;   }
;   flib_Host20_Close();
; 
;   #ifdef USE_XDATA_ADDRESS_0XF000
;   MDrv_USB_ReleaseXdataWindow1();
;   #endif
; 
; }
; #endif
; #if 0
; void MDrv_UsbClose(void)
; {
;   flib_Host20_Close();
; }
; #endif
; #ifdef Enable_Mass_Storage
; BOOLEAN MDrv_UsbBlockReadToMIU(U8 lun,U32 u32BlockAddr, U32 u32BlockNum,U32 u32MIUAddr)
; {
;   BOOLEAN result;
;   U8 retrycnt=0;
;   struct LUN_Device* LunDevice = Mass_stor_us1.Mass_stor_device;
; 
;   if (mwHost20_PORTSC_ConnectStatus_Rd()==0)
;     return FALSE;               //device is not connected
; 
;   if (gUsbDeviceState==BAD_DEVICE) return FALSE;
; 
; 
;   if (u32BlockAddr > Mass_stor_us1.Mass_stor_device[lun].u32BlockTotalNum)
;   {
;     MINI_DEBUG(printf("USBRead address is over the range:%lx\n",u32BlockAddr));
;     return FALSE;
;   }
;   //printf("usb read sector:%lx\n",u32BlockNum);
; 
;   #ifdef USE_XDATA_ADDRESS_0XF000
;   MDrv_USB_SetXdataWindow1();       //switch window 1
;   #endif
;   #ifdef ATV_SERISE_USE
;     #ifdef Enable_Close_INT
;     XBYTE[0x2B00]|=0x02;
;     DisableINT();
;     #endif
;   #endif
;   //result= bSCSI_Read_Write10(FALSE,lun,  u32BlockAddr, u32BlockNum, u32MIUAddr);
;   while (1)
;   {
;     retrycnt++;
;     result= bSCSI_Read_Write10(FALSE,lun,  u32BlockAddr, u32BlockNum, u32MIUAddr);
;     if (result==TRUE) break;
;     if (result==FALSE)
;     {
;       if (retrycnt > 3)
;       {
;        if (gUsbStatus==USB_TIMEOUT)
;              gUsbDeviceState=BAD_DEVICE;    //mark as bad device
; #if 0  //Removed. It gets problem if remove card while play from USB card reader.
;        else
;              LunDevice[lun].bDeviceValid=FALSE;      //mark as bad lun
; #endif
;         break;          //return FALSE
;       }
;       MINI_DEBUG( printf("USBDisk Read failed\n"));
;        if (gUsbStatus==USB_TIMEOUT)
;        {
;         if ((retrycnt==2)&&(mwOTG20_Control_HOST_SPD_TYP_Rd()==2) )              //make sure it is hi speed
;         {
;           MINI_DEBUG(printf("Force FS\n"));
;           UHC_XBYTE(0x40)|=0x80;//force enter FSmode
;         }
; 	    #ifndef ATV_SERISE_USE
;         #ifndef CERAMAL_SERISE_USE
;         msAPI_Timer_ResetWDT();
;         #endif
; 		#else
;           #ifdef Enable_Close_INT
;           XBYTE[0x2B00]&=0xFD;
;           EnableINT();
; 	      #endif
; 	    #endif
; 
;         #ifdef Enable_Low_Temperature_Patch
; 	    if(gSpeed==0)
; 	    {
; 	      //printf("\r\n CDR toggle!!",0);
;           XBYTE[gUTMI_BASE+0x0a]^=0x10; //invert CDR_CLOCK
;           XBYTE[gUTMI_BASE+0x06]|=0x03; //reset UTMI
;           XBYTE[gUTMI_BASE+0x06]&=0xfc;
; 	    }
; 	    #endif
; 
;        // MDrv_Usb_Device_Enum();             //reinit usb device
;           if (MDrv_Usb_Device_Enum()==FALSE)
;           	{
;               result=FALSE;
;               break;
;             }
;       }
;     }
; 
;   }
; 
;   #ifdef ATV_SERISE_USE
;     #ifdef Enable_Close_INT
;     XBYTE[0x2B00]&=0xFD;
;     EnableINT();
;     #endif
;   #endif
;   //MDrv_Sys_ReleaseXdataWindow1();
;   if (result==FALSE)
;   {
;     DRV_USB_DBG(printMsg("USBDisk Read failed\n"));
;     //printf("read failed\n");
;   }
; 
;   #ifdef USE_XDATA_ADDRESS_0XF000
;   MDrv_USB_ReleaseXdataWindow1();
;   #endif
;   return result;
; 
; }
; 
; BOOLEAN MDrv_UsbBlockWriteFromMIU(U8 lun, U32 u32BlockAddr, U32 u32BlockNum,U32 u32MIUAddr)
; {
;   BOOLEAN result;
;   if (mwHost20_PORTSC_ConnectStatus_Rd()==0)
;     return FALSE;               //device is not connected
; 
;    if (gUsbDeviceState==BAD_DEVICE) return FALSE;
; 
;   if (u32BlockAddr > Mass_stor_us1.Mass_stor_device[lun].u32BlockTotalNum)
;   {
;     MINI_DEBUG(printData("USBWrite address is over the range:%lx\n",u32BlockAddr));
;     return FALSE;
;   }
; 
;   #ifdef USE_XDATA_ADDRESS_0XF000
;   MDrv_USB_SetXdataWindow1();       //switch window 1
;   #endif
; 
;   result= bSCSI_Read_Write10(TRUE,lun,  u32BlockAddr, u32BlockNum, u32MIUAddr);
; 
;   #ifdef USE_XDATA_ADDRESS_0XF000
;   MDrv_USB_ReleaseXdataWindow1();
;   #endif
; 
;   return result;
; 
; }
; U32 MDrv_GetUsbBlockSize(U8 lun)
; {
;   return Mass_stor_us1.Mass_stor_device[lun].u32BlockSize;
; }
; 
; U32 MDrv_GetUsbBlockNum(U8 lun)
; {
;   return Mass_stor_us1.Mass_stor_device[lun].u32BlockTotalNum;
; }
; #endif
; #if 0
; U8 MDrv_USB_GetXDataExtStackCount()
; {
;   return xdwin1_lockCount;
; }
; #endif
; //---if you don't know how to use it, don't use it
; #if 0
; void EnterUXBMode()
; {
;   MINI_DEBUG( printf("Enter UXB mode\n"));
;   UHC_XBYTE(0x40)|=0x80;//force enter FSmode
;   MDrv_Usb_Device_Enum();
; }
; void LeaveUXBMode()
; {
;   MINI_DEBUG(printf("leave UXB mode \n"));
;   UHC_XBYTE(0x40)&=~0x80;//leave  FSmode
;   MDrv_Usb_Device_Enum();
; 
; }
; #endif
; BOOLEAN  MDrv_Usb_Device_Enum(void)

	RSEG  ?PR?MDrv_Usb_Device_Enum?DRVUSBMAIN
MDrv_Usb_Device_Enum:
	USING	0
			; SOURCE LINE # 1294
; {
			; SOURCE LINE # 1295
;   BOOLEAN result=FALSE;
			; SOURCE LINE # 1296
	CLR  	A
	MOV  	DPTR,#result?545
	MOVX 	@DPTR,A
;   U8  RetryCount=0;
			; SOURCE LINE # 1297
	INC  	DPTR
	MOVX 	@DPTR,A
; 
;   U8 rootUSBDeviceInterfaceClass = USB_INTERFACE_CLASS_NONE;
			; SOURCE LINE # 1299
	INC  	DPTR
	MOVX 	@DPTR,A
; 
;   if (gUsbDeviceState==BAD_DEVICE) return FALSE;        //bad device , no more enumerate
			; SOURCE LINE # 1301
	MOV  	DPTR,#gUsbDeviceState
	MOVX 	A,@DPTR
	CJNE 	A,#03H,?C0057
	MOV  	R7,#00H
	RET  	
?C0057:
; 
;   #ifdef USE_XDATA_ADDRESS_0XF000
;   MDrv_USB_SetXdataWindow1();
;   #endif
;   NowIsHub=0;
			; SOURCE LINE # 1306
	CLR  	A
	MOV  	DPTR,#NowIsHub
	MOVX 	@DPTR,A
; 
; redo_init:
			; SOURCE LINE # 1308
?MDrv_Usb_Device_Enum?redo_init:
;   //USB ROOT
;   RetryCount++;
			; SOURCE LINE # 1310
	MOV  	DPTR,#RetryCount?546
	MOVX 	A,@DPTR
	INC  	A
	MOVX 	@DPTR,A
;   if (MDrv_UsbHost_Init()==FALSE) goto fail_exit;
			; SOURCE LINE # 1311
	LCALL	MDrv_UsbHost_Init
	MOV  	A,R7
	JNZ  	$ + 5H
	LJMP 	?MDrv_Usb_Device_Enum?fail_exit
?C0060:
;   if  (flib_Host20_Enumerate(1,3)==0)
			; SOURCE LINE # 1312
	MOV  	R5,#03H
	MOV  	R7,#01H
	LCALL	_flib_Host20_Enumerate
	MOV  	A,R7
	JNZ  	?C0062
;   {
			; SOURCE LINE # 1313
;     if ((gUsbStatus==USB_TIMEOUT)||(gUsbStatus==USB_INIT_FAIL))
			; SOURCE LINE # 1314
	MOV  	DPTR,#gUsbStatus
	MOVX 	A,@DPTR
	MOV  	R7,A
	XRL  	A,#02H
	JZ   	?C0064
	MOV  	A,R7
	XRL  	A,#05H
	JNZ  	?C0063
?C0064:
;     {
			; SOURCE LINE # 1315
;       #ifdef DTV_STANDARD_LIB
;       if ((RetryCount==2)&&(mwOTG20_Control_HOST_SPD_TYP_Rd()==2))
			; SOURCE LINE # 1317
	MOV  	DPTR,#RetryCount?546
	MOVX 	A,@DPTR
	MOV  	R7,A
	CJNE 	A,#02H,?C0065
	MOV  	DPTR,#gUHC_BASE
	MOVX 	A,@DPTR
	MOV  	R4,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R5,A
	MOV  	R2,AR4
	ORL  	A,#041H
	MOV  	DPL,A
	MOV  	DPH,R2
	MOVX 	A,@DPTR
	CLR  	C
	RRC  	A
	ANL  	A,#03H
	MOV  	R6,A
	CJNE 	R6,#02H,?C0065
;       {                                                               //make sure it is hi speed
			; SOURCE LINE # 1318
;         MINI_DEBUG(printf("Force FS\n"));
;         UHC_XBYTE(0x40)|=0x80;//force enter FSmode
			; SOURCE LINE # 1320
	MOV  	A,#040H
	ADD  	A,R5
	MOV  	DPL,A
	CLR  	A
	ADDC 	A,R4
	MOV  	DPH,A
	MOVX 	A,@DPTR
	ORL  	A,#080H
	MOVX 	@DPTR,A
;       }
			; SOURCE LINE # 1321
?C0065:
;       #endif
;       if (RetryCount >= 3)
			; SOURCE LINE # 1323
	MOV  	A,R7
	CLR  	C
	SUBB 	A,#03H
	JC   	?MDrv_Usb_Device_Enum?redo_init
;       {
			; SOURCE LINE # 1324
;         MINI_DEBUG(printf("bad device\n"));
;         gUsbDeviceState=BAD_DEVICE;
			; SOURCE LINE # 1326
;         goto fail_exit;
			; SOURCE LINE # 1327
	LJMP 	?C0088
;       }
			; SOURCE LINE # 1328
;       #ifndef ATV_SERISE_USE
;       #ifndef CERAMAL_SERISE_USE
;       msAPI_Timer_ResetWDT();
;       #endif
;       #endif
;       goto redo_init;
			; SOURCE LINE # 1334
;     }
			; SOURCE LINE # 1335
?C0063:
;     gUsbDeviceState=BAD_DEVICE;
			; SOURCE LINE # 1336
?C0085:
;     goto fail_exit;
			; SOURCE LINE # 1337
	LJMP 	?C0088
;   }
			; SOURCE LINE # 1338
?C0062:
;   else
;   {
			; SOURCE LINE # 1340
; #ifdef DTV_STANDARD_LIB
;     XBYTE[gUTMI_BASE+0x2a]=0x0;
			; SOURCE LINE # 1342
	LCALL	L?0094
	ADD  	A,#02AH
	LCALL	L?0100
	CLR  	A
	MOVX 	@DPTR,A
; #endif
; 
;     rootUSBDeviceInterfaceClass= sAttachDevice.saCD[0].sInterface[0].bInterfaceClass;
			; SOURCE LINE # 1345
	MOV  	DPTR,#sAttachDevice+024H
	MOVX 	A,@DPTR
	MOV  	DPTR,#rootUSBDeviceInterfaceClass?547
	MOVX 	@DPTR,A
;     //MDrv_UsbGetInterfaceClass(0, 0);
;     DRV_USB_DBG(printf("Check USD Device 4\n"););
; #if 0 // We don't need to check here
;     if(rootUSBDeviceInterfaceClass != 0x08 && rootUSBDeviceInterfaceClass != 0x09)
;     {
;       //printf("unsupport class\n",0);
;       DRV_USB_DBG(printf("unsupport USB root class=%02bx\n", rootUSBDeviceInterfaceClass););
;       result= FALSE;
;       goto fail_exit;
;     }
; #endif
; 
;     DRV_USB_DBG(printf("USB root class=%02bx\n",rootUSBDeviceInterfaceClass););
;     if (rootUSBDeviceInterfaceClass==USB_INTERFACE_CLASS_HUB)//HUB
			; SOURCE LINE # 1359
	XRL  	A,#09H
	JNZ  	?C0068
;     {
			; SOURCE LINE # 1360
;       U8 PortNum,i,devaddr;
; 
;       devaddr=6;
			; SOURCE LINE # 1363
	MOV  	DPTR,#devaddr?544
	MOV  	A,#06H
	MOVX 	@DPTR,A
;       DRV_USB_DBG(printf("Hub class!\n"));
; 
;       PortNum=Usb_Hub_Port_Num();
			; SOURCE LINE # 1366
	LCALL	Usb_Hub_Port_Num
	MOV  	DPTR,#PortNum?542
	MOV  	A,R7
	MOVX 	@DPTR,A
;       for (i=1; i <=PortNum ; i++)
			; SOURCE LINE # 1367
	INC  	DPTR
	MOV  	A,#01H
	MOVX 	@DPTR,A
?C0069:
	MOV  	DPTR,#PortNum?542
	MOVX 	A,@DPTR
	MOV  	R6,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R4,A
	SETB 	C
	SUBB 	A,R6
	JNC  	?C0070
;       {
			; SOURCE LINE # 1368
;         sAttachDevice.bAdd=3;
			; SOURCE LINE # 1369
	MOV  	DPTR,#sAttachDevice
	MOV  	A,#03H
	MOVX 	@DPTR,A
;         Host20_qHD_List_Control1.bDeviceAddress=sAttachDevice.bAdd;
			; SOURCE LINE # 1370
	ANL  	A,#07FH
	MOV  	R6,A
	MOV  	DPTR,#Host20_qHD_List_Control1+04H
	MOVX 	A,@DPTR
	ANL  	A,#080H
	ORL  	A,R6
	MOVX 	@DPTR,A
;         if (USB_Hub_Handle(i)==FALSE)
			; SOURCE LINE # 1371
	MOV  	R7,AR4
	LCALL	_USB_Hub_Handle
	MOV  	A,R7
	JNZ  	?C0072
;         {
			; SOURCE LINE # 1372
;           result=FALSE;
			; SOURCE LINE # 1373
;           continue;
			; SOURCE LINE # 1374
	SJMP 	?C0087
;         }
			; SOURCE LINE # 1375
?C0072:
;         devaddr++;
			; SOURCE LINE # 1376
	MOV  	DPTR,#devaddr?544
	MOVX 	A,@DPTR
	INC  	A
	MOVX 	@DPTR,A
;         NowIsHub=1;
			; SOURCE LINE # 1377
	MOV  	DPTR,#NowIsHub
	MOV  	A,#01H
	MOVX 	@DPTR,A
;         if (flib_Host20_Enumerate(1,devaddr)==0)
			; SOURCE LINE # 1378
	MOV  	DPTR,#devaddr?544
	MOVX 	A,@DPTR
	MOV  	R5,A
	MOV  	R7,#01H
	LCALL	_flib_Host20_Enumerate
	MOV  	A,R7
	JNZ  	?C0073
;         {
			; SOURCE LINE # 1379
;           result=FALSE;
			; SOURCE LINE # 1380
?C0087:
	MOV  	DPTR,#result?545
	MOVX 	@DPTR,A
;           continue;
			; SOURCE LINE # 1381
	SJMP 	?C0071
;         }
			; SOURCE LINE # 1382
?C0073:
;         sAttachDevice.bAdd=devaddr;        
			; SOURCE LINE # 1383
	MOV  	DPTR,#devaddr?544
	MOVX 	A,@DPTR
	MOV  	DPTR,#sAttachDevice
	MOVX 	@DPTR,A
;         #ifdef Enable_Mass_Storage
;         result=MassStorage_Init();              //do mass storage class init
;         #endif
;         if (result==TRUE) break;
			; SOURCE LINE # 1387
	MOV  	DPTR,#result?545
	MOVX 	A,@DPTR
	XRL  	A,#01H
	JZ   	?C0070
;       }
			; SOURCE LINE # 1388
?C0071:
	MOV  	DPTR,#i?543
	MOVX 	A,@DPTR
	INC  	A
	MOVX 	@DPTR,A
	SJMP 	?C0069
?C0070:
;        if (result==FALSE)
			; SOURCE LINE # 1389
	MOV  	DPTR,#result?545
	MOVX 	A,@DPTR
	JNZ  	?MDrv_Usb_Device_Enum?fail_exit
;         {
			; SOURCE LINE # 1390
;              MINI_DEBUG(printf("unsupport hub class device,->bad device\n"));
;              gUsbDeviceState=BAD_DEVICE;
			; SOURCE LINE # 1392
?C0086:
;         }
			; SOURCE LINE # 1393
;     }
			; SOURCE LINE # 1394
	SJMP 	?C0088
?C0068:
; 
;     #ifdef Enable_Mass_Storage
;     else if(rootUSBDeviceInterfaceClass==USB_INTERFACE_CLASS_MSD)//Mass storage class
;     {
;       #ifdef Enable_Mass_Storage       
;       result=MassStorage_Init();
;       #endif
;       #ifdef Enable_Burning_Test
;       UsbTest();
;       #endif
; 
;       #ifdef Enable_Low_Temperature_Patch
; 	  if((gSpeed==0)&&(gUsbStatus==USB_TIMEOUT))
; 	  {
; 	    //printf("\r\n CDR toggle!!",0);
;         XBYTE[gUTMI_BASE+0x0a]^=0x10; //invert CDR_CLOCK
;         XBYTE[gUTMI_BASE+0x06]|=0x03; //reset UTMI
;         XBYTE[gUTMI_BASE+0x06]&=0xfc;
; 	  }
; 	  #endif
; 
;       if((gSpeed==2)&&(gUsbStatus==USB_TIMEOUT))
;       {
; 
;         UHC_XBYTE(0x40)|=0x80; //force enter FS mode
;         goto redo_init;
;       }
; 
;       if(result==FALSE)
;       {
;           if (RetryCount >= 3)
;           {
;              goto fail_exit;
;           }
; 
;           goto redo_init;
;       }
;     }
; 
;    #endif
;    #ifdef  Enable_PTP
;    else  if (rootUSBDeviceInterfaceClass == USB_INTERFACE_CLASS_IMAGE)
;     {
;         if (drvUSBHost_PTP_Init(USB_PORT_0) == PTP_OK)
;         {
;             result = TRUE;
;             DRV_USB_DBG(printf("PTP initial ok\r\n"));
;         }
;     }
;    #endif
;    else if (rootUSBDeviceInterfaceClass==3)//HID
			; SOURCE LINE # 1445
	MOV  	DPTR,#rootUSBDeviceInterfaceClass?547
	MOVX 	A,@DPTR
	CJNE 	A,#03H,?C0077
;     {
			; SOURCE LINE # 1446
;       if (drvUSBHost_HID_Init(USB_PORT_0) == 0)
			; SOURCE LINE # 1447
	CLR  	A
	MOV  	R7,A
	LCALL	_drvUSBHost_HID_Init
	MOV  	A,R7
	JNZ  	?MDrv_Usb_Device_Enum?fail_exit
;         {
			; SOURCE LINE # 1448
;             result = TRUE;
			; SOURCE LINE # 1449
	MOV  	DPTR,#result?545
	INC  	A
	MOVX 	@DPTR,A
;             DRV_USB_DBG(printf("HID initial ok\r\n"));
;         }
			; SOURCE LINE # 1451
;     }
			; SOURCE LINE # 1452
	SJMP 	?MDrv_Usb_Device_Enum?fail_exit
?C0077:
;    else
;     {
			; SOURCE LINE # 1454
;        MINI_DEBUG(printf("unsupport %02bx class device->bad device\n",rootUSBDeviceInterfaceClass));
;        gUsbDeviceState=BAD_DEVICE;           //not belong to any above
			; SOURCE LINE # 1456
?C0088:
	MOV  	DPTR,#gUsbDeviceState
	MOV  	A,#03H
	MOVX 	@DPTR,A
;     }
			; SOURCE LINE # 1457
;     DRV_USB_DBG(printf("USB_CON\n"););
;     //return result;
;   }
			; SOURCE LINE # 1460
; 
; fail_exit:
			; SOURCE LINE # 1462
?MDrv_Usb_Device_Enum?fail_exit:
; 
;   #ifdef USE_XDATA_ADDRESS_0XF000
;   MDrv_USB_ReleaseXdataWindow1();
;   #endif
; 
;   if (mwHost20_PORTSC_ConnectChange_Rd())
			; SOURCE LINE # 1468
	LCALL	L?0098
	ORL  	A,#030H
	MOV  	DPL,A
	MOV  	DPH,R6
	MOVX 	A,@DPTR
	JNB  	ACC.1,?C0080
;     mwHost20_PORTSC_ConnectChange_Set();
			; SOURCE LINE # 1469
	MOVX 	A,@DPTR
	ORL  	A,#02H
	MOVX 	@DPTR,A
?C0080:
; 
;   return result;
			; SOURCE LINE # 1471
	MOV  	DPTR,#result?545
	MOVX 	A,@DPTR
	MOV  	R7,A
; }
			; SOURCE LINE # 1472
?C0058:
	RET  	
; END OF MDrv_Usb_Device_Enum

	END
